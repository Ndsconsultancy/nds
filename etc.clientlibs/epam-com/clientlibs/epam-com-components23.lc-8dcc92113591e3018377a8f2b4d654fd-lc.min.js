/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('WeChatPopup', ['utils-dust', 'utils-a11y', 'constants'], function (dust, utilsA11y, constants) {
    'use strict';

    var classes = {
        id: '.wechat-popup__id',
        close: '.wechat-popup__close',
        qr: '.wechat-popup__qr'
    };

    var $document = $(document),
        $html = $('html'),
        $body = $('body'),
        $overlay = $body.find('.' + constants.Classes.overlay),
        instance;

    function Component() {
        if (instance) {
            return instance;
        }
        instance = this;
        dust.render('wechat-popup', {}, function (result) {
            this.markup = result;
        }.bind(this));

        this.close = this.close.bind(this);
        this.keyupHandler = this.keyupHandler.bind(this);
    }

    Component.prototype.keyupHandler = function (event) {
        if (event.key === constants.Keys.esc) {
            this.close();
        }
    };

    Component.prototype.setData = function (data) {
        this.$qr.attr('src', data.src);
        this.$id.text(CQ.I18n.getMessage('component.we-chat-popup.title', data.id));

        return this;
    };

    Component.prototype.render = function () {
        this.$popup = $body.append(this.markup).children('.' + Component.selector);

        this.$id = this.$popup.find(classes.id);
        this.$close = this.$popup.find(classes.close);
        this.$qr = this.$popup.find(classes.qr);

        this.$close.on('click', this.close);
        Component.rendered = true;
    };

    Component.prototype.open = function (data, focusTarget) {
        if (!Component.rendered) {
            this.render();
        }
        this.focusTarget = focusTarget;
        this.setData(data);
        $document.on('keyup', this.keyupHandler);
        $html.addClass(constants.Classes.noscroll);
        this.$popup.show();
        $overlay.removeClass(constants.Classes.hidden)
            .addClass(constants.Classes.overlayCoverHeader)
            .on('click', this.close);
        utilsA11y.handlePopupFocus(this.$popup);
    };

    Component.prototype.close = function () {
        $html.removeClass(constants.Classes.noscroll);
        this.$popup.hide();
        $document.off('keyup', this.keyupHandler);
        $overlay.addClass(constants.Classes.hidden)
            .removeClass(constants.Classes.overlayCoverHeader)
            .off('click', this.close);
        this.focusTarget.focus();
        this.focusTarget = null;
    };

    Component.selector = 'wechat-popup';
    Component.classes = classes;

    return Component;
});

/* eslint-disable */
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('TabsUtil', ['HistoryUtil', 'constants', 'utils', 'utils-env', 'media'], function (historyUtil, constants, utils, env, media) {
    'use strict';

    var $window = $(window);
    var classes = {
        item: '.js-tabs-item',
        link: '.js-tabs-link',
        links: '.js-tabs-links-list',
        active: 'active',
        stage: '.owl-stage',
        owlItem: '.owl-item',
        controls: '.js-tabs-controls',
        nav: '.js-tabs-nav',
        prevButton: '.js-tabs-prev',
        nextButton: '.js-tabs-next',
        navAllyActiveTab: '.js-nav-a11y-active-tab',
        navAllyContent: '.js-tab-a11y-content',
        navAlly: '.js-nav-a11y',
        linkContent: '.js-tabs-link-content',
        open: 'open'
    };
    var events = {
        tabChange: 'tab.change',
        tabLoaded: 'tab.loaded'
    };
    var activatedComponents = [];

    function pushToHistory(data) {
        var state = {};

        state[data.componentId] = data.activeItem;
        historyUtil.push('activeTabs', state, data.hash && location.pathname + data.hash);
    }

    function assignId(id, el) {
        el.dataset.item = id;
    }

    function getFullWidth(prev, curr) {
        return prev + $(curr).outerWidth(true);
    }

    function Component($el, params) {
        this.config = params || {};

        this.$el = $el;
        this.$list = this.config.links || $el.find(classes.links).first();
        this.$links = this.config.link || this.$list.find(classes.link);
        this.$items = this.config.items || $el.children(classes.item);
        this.$nav = $el.find(classes.nav);
        this.$prevButton = $el.find(classes.prevButton);
        this.$nextButton = $el.find(classes.nextButton);
        this.$navA11y = this.$nav.find(classes.navAlly);

        this.subTabs = this.config.multiLevelSubTabs;
        this.subItemsDataCorrect = false;

        !this.subTabs && this.$links.each(assignId);
        !this.subTabs && this.$items.each(assignId);
        this.subTabs && !this.subItemsDataCorrect && this.updateSubItemsData();

        this.lastIndex = this.$links.length - 1;
        this.useHistory = this.config.useHistory;
        this.skipSwitching = this.config.skipSwitching;
        this.responsiveView = this.config.responsiveView;
        this.carouselView = this.config.carouselView;
        this.carouselForPages = this.config.carouselForPages;
        this.responsiveBreakpoint = this.config.responsiveBreakpoint;
        this.scrollToElement = this.config.scrollToElement;
        this.scrollToElementSelector = this.config.scrollToElementSelector;
        this.scrollToReservedSpace = this.config.scrollToReservedSpace;
        this.multiLevelTabsView = this.config.multiLevelTabsView;
        this.verticalNavigation = this.config.verticalNavigation;
        this.scrollToTopOnTabChange = this.config.scrollToTopOnTabChange;
        this.id = this.$el.attr('id');

        this.onTabChange = this.onTabChange.bind(this);

        this.setEventListeners();
        this.$el.trigger(events.tabChange, { tab: 0, skipHistory: true, skipFocus: true });
        activatedComponents.push(this);

        this.$controls = this.config.controls || $el.find(classes.controls);
        this.dragEnabled = this.shouldEnableDrag();
        this.windowWidth = $window.width();

        this.responsiveView && media.getViewportWidth() <= this.responsiveBreakpoint && this.initCarousel();
        this.responsiveView && !env.isEditMode() && $window.on('resize orientationchange', function() {
            if ($window.width() !== this.windowWidth) {
                this.reInitCarousel();
                this.reInitCarouselOnResponsiveView();
            }
        }.bind(this));

        this.multiLevelTabsView && !env.isEditMode() && $window.on('orientationchange', function() {
            setTimeout(function () {
                this.reInitCarousel();
            }.bind(this), 100);
        }.bind(this));

        this.carouselView && this.initCarousel();

        $('.slider-ui').on('initialized.owl.carousel', function (event) {
            var target = $(event.target);
            var sliderItemWidth = target.find('.owl-item').css('width');
            if (parseFloat(sliderItemWidth) !== 0) {
                this.$sliderItemWidth = sliderItemWidth;
            }
            if (parseFloat(sliderItemWidth) === 0) {
                var items = target.find('.owl-item');
                items.css('width', this.$sliderItemWidth);
            }
        }.bind(this));
    }

    Component.prototype.updateSubItemsData = function () {
        this.$links.each(function (id, el) {
            var $item = this.$items.filter('[data-item-sub="' + el.dataset.itemSub + '"]');
            el.dataset.itemSub = id;
            $item.attr('data-item-sub', id);
        }.bind(this));

        this.subItemsDataCorrect = true;
    };

    Component.prototype.initCarousel = function () {
        if (this.config.multiLevelSubTabs) {
            return;
        }

        this.$list.owlCarousel($.extend({}, this.config, {
            mouseDrag: this.dragEnabled,
            touchDrag: this.dragEnabled
        }));

        this.$controls.find(classes.stage).attr('role', 'tablist');
        this.$controls.find(classes.owlItem).attr('role', 'presentation');
        this.$owlStage = this.$el.find(classes.stage);
        this.carouselWidth = this.$owlStage.width();

        this.updateStagePosition = utils.updateStagePosition(this.$owlStage, this.$controls);
        this.dragEnabled && this.$list.on('translated.owl.carousel', this.updateStagePosition.bind(this, this.carouselWidth));
    };

    Component.prototype.shouldEnableDrag = function () {
        return this.$controls.width() < [].reduce.call(this.$links, getFullWidth, 0);
    };

    Component.prototype.reInitCarousel = function () {
        var dragEnabled =  this.shouldEnableDrag() || this.multiLevelTabsView;

        if (!dragEnabled) {
            return;
        }

        this.dragEnabled = dragEnabled;
        this.$list.owlCarousel('destroy');
        this.initCarousel();
        this.scrollTo();
    };

    Component.prototype.reInitCarouselOnResponsiveView = function() {
        var pageWidth = media.getViewportWidth();

        if (this.responsiveView && pageWidth > this.responsiveBreakpoint) {
            this.$list.owlCarousel('destroy');
            return;
        }

        this.$list.owlCarousel('destroy');
        this.initCarousel();
        this.scrollTo();
    };

    Component.prototype.onLoad = function () {
        if (location.hash) {
            this.switchByHash();
            return;
        }
        this.useHistory && this.updateFromHistory();
        this.$el.trigger(events.tabLoaded);
    };

    Component.prototype.setEventListeners = function () {
        this.$el.on(events.tabChange, this.onTabChange);
        this.$links.on('click', this.onLinkClick.bind(this))
            .on('keydown', this.onKeydown.bind(this));
        this.$nav.on('click', 'button', this.onNavClick.bind(this));
        this.$navA11y.length && this.$nav.on('focus blur', 'button', this.onNavFocusToggle.bind(this));
        this.useHistory && $window.on('popstate', this.updateFromHistory.bind(this));
        $window.on('load', this.onLoad.bind(this));
    };

    Component.prototype.onNavFocusToggle = function () {
        if (this.$navA11y.attr('aria-atomic') || this.$navA11y.attr('aria-polite')) {
            this.$navA11y.removeAttr('aria-atomic aria-live');
        } else {
            this.$navA11y.attr({
                'aria-atomic': true,
                'aria-live': 'polite'
            });
        }
    };

    Component.prototype.updateFromHistory = function () {
        var activeTabs = historyUtil.getStateByKey('activeTabs'),
            activeTab = activeTabs[this.id] || 0;

        this.$el.trigger(events.tabChange, { tab: activeTab, skipHistory: true });
    };

    Component.prototype.afterClick = null;

    Component.prototype.onLinkClick = function (event) {
        var $target = $(event.currentTarget),
            hash = $target.attr('href'),
            targetTab = this.subTabs ? $target.data('item-sub') : $target.data('item'),
            $scrollToSelector = this.scrollToElementSelector || this.$el,
            isMobile = media.getViewportWidth() < media.modes.Tablet.start,
            $parentTarget = $target.parents(classes.links).parent(),
            isScrollOnDropdownClose = isMobile && $parentTarget.hasClass(classes.open);

        var isScroll = this.scrollToElement;
        if (typeof this.scrollToElement === 'function') {
            isScroll = this.scrollToElement();
        }

        this.$el.trigger(events.tabChange, { tab: targetTab, hash: hash });
        this.afterClick && this.afterClick($target);

        var scrollToReservedSpace =
            typeof this.scrollToReservedSpace === 'function' ? this.scrollToReservedSpace() : 100;
        (isScroll && isScrollOnDropdownClose || this.scrollToTopOnTabChange) && $scrollToSelector.scrollToSelector({
            reservedSpace: scrollToReservedSpace,
            duration: 400
        });

        if (isMobile) {
            $parentTarget.toggleClass(classes.open);
        }

        return false;
    };

    Component.prototype.beforeTabChange = function (data) {
        !data.skipSwitching && this.$items.removeClass(classes.active).attr('tabindex', -1);
        this.$links.removeClass(classes.active).attr({
            'aria-selected': 'false',
            'tabindex': -1
        });
        this.$links.parent('.js-tabs-title').removeClass(classes.active);
    };

    Component.prototype.afterTabChange = function (data) {
        this.$list.trigger('to.owl.carousel', this.activeItem);
        var $activeLinks = this.subTabs ? this.$links.filter('[data-item-sub=' + this.activeItem + ']') : this.$links.filter('[data-item=' + this.activeItem + ']');
        var $activeTitle = this.subTabs ? this.$links.filter('[data-item-sub=' + this.activeItem + ']').parent('.js-tabs-title') : this.$links.filter('[data-item=' + this.activeItem + ']').parent('.js-tabs-title');

        $activeLinks.addClass(classes.active)
            .attr({
                'aria-selected': 'true',
                'tabindex': 0
            });
        $activeTitle.addClass(classes.active);

        this.$nav.find(classes.navAllyContent).text($activeLinks.find(classes.linkContent).text());
        this.$nav.find(classes.navAllyActiveTab).text(this.activeItem + 1);
        !data.skipFocus && $activeLinks.focus();
        this.useHistory && !data.skipHistory && pushToHistory({
            componentId: this.id,
            activeItem: this.activeItem,
            hash: data.hash
        });

        this.multiLevelAfterTabChange && this.multiLevelAfterTabChange();
        $window.trigger(constants.Events.tabChanged);
    };

    Component.prototype.multiLevelAfterTabChange = null;

    Component.prototype.onTabChange = function (event, data) {
        if (!$.isNumeric(data.tab) || !data.forceSwitching && this.activeItem === data.tab) {
            return false;
        }
        this.beforeTabChange(data);
        if (data.tab < 0) {
            this.activeItem = this.lastIndex;
        } else if (data.tab > this.lastIndex) {
            this.activeItem = 0;
        } else {
            this.activeItem = data.tab;
        }

        var attr = this.subTabs ? '[data-item-sub=' : '[data-item=';

        !data.skipSwitching && this.$items.filter(attr + this.activeItem + ']')
            .addClass(classes.active)
            .attr('tabindex', 0);
        this.afterTabChange(data);
        return false;
    };

    Component.prototype.onNavClick = function (event) {
        var $scrollToSelector = this.scrollToElementSelector || this.$el;

        event.preventDefault();
        $(event.currentTarget).is(classes.nextButton) && this.$el.trigger(events.tabChange, {
            tab: this.activeItem + 1, skipSwitching: this.skipSwitching, skipFocus: true
        });
        $(event.currentTarget).is(classes.prevButton) && this.$el.trigger(events.tabChange, {
            tab: this.activeItem - 1, skipSwitching: this.skipSwitching, skipFocus: true
        });

        var scrollToReservedSpace =
            typeof this.scrollToReservedSpace === 'function' ? this.scrollToReservedSpace() : 100;
        this.scrollToTopOnTabChange && $scrollToSelector.scrollToSelector({
            reservedSpace: scrollToReservedSpace,
            duration: 400
        });
    };

    Component.prototype.onKeydown = function (event) {
        var nextKey = this.verticalNavigation ? constants.Keys.arrowDown : constants.Keys.arrowRight,
            prevKey = this.verticalNavigation ? constants.Keys.arrowUp : constants.Keys.arrowLeft;

        switch (event.key) {
            case constants.Keys.home: {
                event.preventDefault();
                this.$el.trigger(events.tabChange, { tab: 0 });
                break;
            }
            case constants.Keys.end: {
                event.preventDefault();
                this.$el.trigger(events.tabChange, { tab: this.lastIndex });
                break;
            }
            case nextKey: {
                event.preventDefault();
                this.$el.trigger(events.tabChange, { tab: this.activeItem + 1, skipSwitching: this.skipSwitching });
                break;
            }
            case prevKey: {
                event.preventDefault();
                this.$el.trigger(events.tabChange, { tab: this.activeItem - 1, skipSwitching: this.skipSwitching });
                break;
            }
            case constants.Keys.space:
            case constants.Keys.enter: {
                event.preventDefault();
                this.$el.trigger(events.tabChange, { tab: this.activeItem, forceSwitching: true });
                this.afterClick && this.afterClick($(event.target));
                break;
            }
            default: {
                break;
            }
        }

        if (event.key === constants.Keys.arrowLeft || event.key === constants.Keys.arrowRight) {
            this.scrollTo();
        }
    };

    Component.prototype.beforeScroll = null;

    Component.prototype.scrollTo = function () {
        var $active = this.$links.filter('.' + this.classes.active),
            targetTab = this.subTabs ? $active.data('item-sub') : $active.data('item');

        this.beforeScroll && this.beforeScroll($active);

        this.$list.trigger('to.owl.carousel', targetTab);
    };

    Component.prototype.switchByHash = function () {
        var hash = location.hash.slice(1),
            $active = this.$items.filter('[data-anchor="' + hash + '"]'),
            targetTab = this.subTabs ? $active.data('item-sub') : $active.data('item');

        if (!$active.length || !hash) {
            return;
        }

        this.$el.trigger(events.tabChange, { tab: targetTab, skipHistory: true });
        $active.scrollToSelector({ reservedSpace: 210 });
    };

    Component.prototype.classes = classes;

    Component.pushToHistory = pushToHistory;
    Component.activatedComponents = activatedComponents;
    Component.events = events;
    Component.moduleName = 'TabsUtil';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('SocialIcons', ['WeChatPopup', 'constants'], function (WeChatPopup, constants) {
    'use strict';

    var classes = {
        weChatLink: '.social-icons__link-wechat, .social-icons-23__link-wechat'
    };

    var $html = $('html');

    function Component($el, focusTarget) {
        this.$el = $el;
        this.focusTarget = focusTarget;
        this.$weChatLink = this.$el.find(classes.weChatLink);

        if (this.$weChatLink.length) {
            this.initWeChatPopup();
        }
    }

    Component.prototype.initWeChatPopup = function () {
        this.$weChatPopup = new WeChatPopup();
        this.$weChatLink.on('click', this.openWeChat.bind(this));
    };

    Component.prototype.openWeChat = function (event) {
        event.preventDefault();
        var target = $(event.currentTarget);

        $html.trigger(constants.Events.menuClose);

        this.$weChatPopup.open({
            src: target.data('src'),
            id: target.data('id')
        }, this.focusTarget || this.$weChatLink);
    };

    Component.classes = classes;

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ReCaptcha', [], function () {
    'use strict';

    var $window = $(window);
    var data = {
        siteKey: 'sitekey',
        widgetId: 'recaptcha-widget-id'
    };

    function Component($el, params) {
        var config = params || {};

        this.$el = $el;
        this.reCaptchaEnabled = this.$el.data('recaptcha-enabled');
        this.recaptchaId = this.$el.attr('id');
        this.siteKey = this.$el.data(data.siteKey);
        this.submitForm = config.submitForm;
    }

    Component.prototype.render = function () {
        this.reCaptchaEnabled && $window.on('load', function () {
            this.id = grecaptcha.render(this.recaptchaId, {
                size: 'invisible',
                sitekey: this.siteKey,
                callback: this.submitForm
            });

            this.$el.data(data.widgetId, this.id);
        }.bind(this));
    };

    Component.prototype.execute = function () {
        grecaptcha.execute(this.id);
    };

    Component.prototype.reset = function () {
        setTimeout(function(){
            grecaptcha.reset(this.id);
        }, 500);
    };

    Component.moduleName = 'ReCaptcha';

    return Component;
});
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('multi-select', ['utils-dust', 'constants', 'jquery-plugins'], function(dust, constants) {
      'use strict';

      var $window = $(window),
          $body = $('body');

      var classes = {
          open: 'open',
          selectedParams: '.selected-params',
          dropdown: '.multi-select-dropdown',
          filterWrap: '.multi-select-filter-wrapper',
          selectedItems: '.selected-items',
          counter: '.counter',
          unselectTag: '.unselect-tag',
          filterTag: '.filter-tag',
          checkboxLabel: '.checkbox-custom-label',
          showWaitMessage: 'show-wait-message'
        },
        events = {
          close: 'dropdown:close',
          open: 'dropdown:open',
          focusItem: 'dropdown:focus',
          next: 'dropdown:next',
          prev: 'dropdown:prev',
          change: 'dropdown:change',
        };

      /**
       * Multi select filter constructor
       * @param $select
       * @param config
       * @constructor
       */
      function MultiSelectFilter($select, config) {
        this.$el = $('<div/>').addClass('multi-select-filter')
          .addClass('validation-focus-target')
          .attr('role', 'combobox')
          .attr('tabindex', 0)
          .attr('aria-autocomplete', 'list')
          .attr('aria-haspopup', true)
          .attr('aria-expanded', false)
          .attr('aria-required', config.required)
          .attr('aria-labelledby', config.labelId)
          .attr('aria-describedby', config.errorId);

        config.className && this.$el.addClass(config.className);
        this.$select = $select;
        this.config = config;
        this.$options = this.$select.find('option');
        this.selectedCount = this.$select.find('option:checked').length;
        MultiSelectFilter.counter = MultiSelectFilter.counter || 0;
        this.init();
        this.initItemsUpdateEvent();
        this.isDropdownAbove = this.isDropdownAbove.bind(this);
      }

      /**
       * Initializing
       */
      MultiSelectFilter.prototype.init = function() {
        this.eventNamespace = 'multiSelectFilter' + MultiSelectFilter.counter++;
        this.$select.hide().data('multiSelectFilter', this);
        this.render();
      };

      MultiSelectFilter.prototype.isOpened = function() {
        return this.$el.hasClass(classes.open);
      };

      MultiSelectFilter.prototype.renderCallback = function(output, error) {
        if (error) {
          console.log('"multi-select-dropdown" rendering error: ' + error);
          return;
        }
        this.draw(output);
        typeof this.config.callback === 'function' && this.config.callback();
      };

      /**
       * Render multi select
       */
      MultiSelectFilter.prototype.render = function() {
        dust.render('multi-select-dropdown', this.generateRenderContext(), this.renderCallback.bind(this));
      };

      /**
       * Generate context for DUST template
       * @returns {object}
       */
      MultiSelectFilter.prototype.generateRenderContext = function() {
        var context = {
          defaultText: this.$select.data('defaultText'),
          selectedCountKey: this.config.selectedCount || 'component.multi-select-filter.selected-count',
          selectedCount: this.selectedCount,
          columns: this.config.columns || 2,
          columnSize: this.config.columnSize,
          showTags: this.config.showTags || false,
          options: [],
          emptyOptions: [],
        };

        this.$options.each(function() {
          var $option = $(this),
            selected = $option.prop('selected');

          context.options.push({
            text: $option.html(),
            value: $option.val(),
            selected: selected,
          });
        });

        if (this.$options.length === 0) {
          var errorMessage = CQ.I18n.getMessage('component.general.search-empty-result-for-combination');
          context.emptyOptions = [{
            value: errorMessage,
          }];
        }

        context.columnSize = context.columnSize || Math.ceil(context.options.length / context.columns);
        context.columnLastItemIndex = context.columnSize - 1;
        context.fixedLengthColumns = context.columns - 1;

        return context;
      };

      MultiSelectFilter.prototype.setDrawElements = function(output) {
        this.$el.html(output);
        this.$select.after(this.$el);
        this.$selectedParams = this.$el.find(classes.selectedParams);
        this.$checkboxesContainer = this.$el.find(classes.dropdown);
        this.$checkboxes = this.$checkboxesContainer.find(':checkbox');
        this.currentItemIndex = 0;
        this.$tagsContainer = this.$el.parents(classes.filterWrap).find(classes.selectedItems);
        this.$counterHolder = this.$el.find(classes.counter);
      };

      /**
       * Draw multi select
       * @param {string} output
       */
      MultiSelectFilter.prototype.draw = function(output) {
        this.setDrawElements(output);
        this.initEvents();
        this.onLoad();
      };

      MultiSelectFilter.prototype.initItemsUpdateEvent = function() {
        this.$select.on(constants.Events.multiSelectUpdate, function() {
          $('.multi-select-dropdown').removeClass(classes.showWaitMessage);
          var newOptions = this.$select.find('option');
          this.findMatchOptions(newOptions);
          this.$options = newOptions;
          dust.render('multi-select-dropdown', this.generateRenderContext(), function(output) {
            this.reInitDropdownOptions(output);
            this.resetSkillsCounter();
            this.resetAllTags();
            this.toggleDropdown(true);
          }.bind(this));
          this.checkMatchTags();
        }.bind(this));

        this.$select.one(constants.Events.multiSelectFirstUpdate, function () {
            $('.multi-select-dropdown').removeClass(classes.showWaitMessage);
            this.$options = this.$select.find('option');
            dust.render('multi-select-dropdown', this.generateRenderContext(), function(output) {
                this.reInitDropdownOptions(output);
                this.onLoad();
            }.bind(this));
            this.updateCounter(this.$select.find(':selected').length);
        }.bind(this));

        this.$select.on(constants.Events.multiSelectBeforeUpdate, function () {
            var multiSelectDropdown = $('.multi-select-dropdown');
            multiSelectDropdown.empty();
            multiSelectDropdown.addClass(classes.showWaitMessage);
            multiSelectDropdown.html('<span class="">Waiting for results...</span>');
        });
      };

      MultiSelectFilter.prototype.checkMatchTags = function () {
        for (var i = 0; i < this.$matchedOptions.length; i++) {
          this.select(this.$matchedOptions[i]);
        }
      };

      MultiSelectFilter.prototype.findMatchOptions = function (newOptions) {
        this.$matchedOptions = [];
        var selectedItems = this.getSelectedItems();

        for (var i = 0; i < selectedItems.length; i++) {
          var value = selectedItems[i].value;
          for (var j = 0; j < newOptions.length; j++) {
            if (value === newOptions[j].value) {
              this.$matchedOptions.push(value);
            }
          }
        }
      };

      MultiSelectFilter.prototype.reInitDropdownOptions = function(output) {
        this.setDrawElements(output);
        this.initReusedEvents();
        this.setOverlayScrollbar();
      };

      MultiSelectFilter.prototype.setOverlayScrollbar = function() {
          var isRedesign23 = $body.hasClass('dark-mode') || $body.hasClass('light-mode');

          if (isRedesign23) {
              setTimeout(function () {
                  OverlayScrollbars(this.$el.find(classes.dropdown), { className: 'os-theme-dark'});
              }.bind(this), 100);
          }
      };

      MultiSelectFilter.prototype.toggleDropdown = function(state) {
        this.$checkboxesContainer.toggleClass(constants.Classes.hidden, !state);
        this.$el.toggleClass(classes.open, state);
        $window.off('click.' + this.eventNamespace + ' touchstart.' + this.eventNamespace);

        if (!state) {
          $window.off('scroll resize', this.isDropdownAbove);
          return;
        }
        $window.on('scroll resize', this.isDropdownAbove)
          .on('click.' + this.eventNamespace + ' touchstart.' + this.eventNamespace, this.onWindowClick.bind(this));
        this.isDropdownAbove();
        this.$checkboxes.first().focus().attr('aria-selected', true);
      };

      MultiSelectFilter.prototype.removeTag = function(event) {
        var value = $(event.target).parent().data('value');

        // Check for case when multiple multiselects share single tags container
        this.$options.findByValue(value).length && this.unselect(value);

        return false;
      };

      MultiSelectFilter.prototype.resetAllTags = function() {
        $(classes.selectedItems).empty();
      };

      MultiSelectFilter.prototype.onClose = function() {
        // TODO. For know onClose focus works incorrectly - for example it steals focus from other inputs/dropdowns when we click on them.
        // Focus should be reworked in frames of accessability tasks. 
        // It should be added only when we close dropdown using ESC button.
        // Below string commented during the work on:
        // https://jira.epam.com/jira/browse/EPMWEB-24141
        // this.$el.focus();
        this.$el.attr('aria-expanded', false);
        this.currentItemIndex = 0;
        this.toggleDropdown(false);
        this.config.onClose && this.config.onClose();
      };

      MultiSelectFilter.prototype.onOpen = function() {
        this.$el.attr('aria-expanded', true);
        this.toggleDropdown(true);
        this.config.onOpen && this.config.onOpen();
      };

      MultiSelectFilter.prototype.onEscPress = function() {
        this.isOpened() && this.$el.trigger(events.close);
      };

      MultiSelectFilter.prototype.onTabPress = function() {
        this.isOpened() && this.$el.trigger(events.close);
      };

      MultiSelectFilter.prototype.onSpaceOrEnterPress = function(event) {
        if (this.isOpened()) {
          return;
        }

        event.preventDefault();
        this.$el.trigger(events.open);
      };

      MultiSelectFilter.prototype.onCheckboxChange = function(event) {
        var $checkbox = $(event.target),
          value = $checkbox.data('value');

        if ($checkbox.prop('checked')) {
          this.select(value);
        } else {
          this.unselect(value);
        }
      };

      MultiSelectFilter.prototype.getSelectedItems = function() {
        return this.$options.filter(':selected');
      };

      MultiSelectFilter.prototype.onLoad = function() {
        this.getSelectedItems().each(function(index, el) {
          this.addTag(el.value);
        }.bind(this));
      };

      MultiSelectFilter.prototype.onSync = function() {
        var selectedOptions = this.getSelectedItems();

        this.$checkboxes.each(function(index, checkbox) {
          var $checkbox = $(checkbox),
            value = $checkbox.data('value').toString(),
            isCheckboxActive = $checkbox.prop('checked'),
            isSelectActive = selectedOptions.findByValue(value).length;

          if (isCheckboxActive && !isSelectActive) {
            this.unselect(value, true);
          } else if (!isCheckboxActive && isSelectActive) {
            this.select(value, true);
          }
        }.bind(this));
      };

      MultiSelectFilter.prototype.onWindowClick = function(event) {
        !$(event.target).closest(this.$el).length && this.$el.trigger(events.close);
      };

      MultiSelectFilter.prototype.onArrowDown = function(event) {
        if (!this.isOpened()) {
          return;
        }
        event.preventDefault();
        this.$el.trigger(events.next);
      };

      MultiSelectFilter.prototype.onArrowUp = function(event) {
        if (!this.isOpened()) {
          return;
        }
        event.preventDefault();
        this.$el.trigger(events.prev);
      };

      MultiSelectFilter.prototype.onClick = function(event) {
        var targetIndex = $(event.target).closest('li[role=treeitem]').data('index');

        if (!targetIndex) {
          return;
        }

        this.selectItem(targetIndex);
      };

      MultiSelectFilter.prototype.onKeyDown = function(event) {
        switch (event.key) {
          case constants.Keys.arrowUp: {
            this.onArrowUp(event);
            break;
          }
          case constants.Keys.arrowDown: {
            this.onArrowDown(event);
            break;
          }
          case constants.Keys.tab: {
            this.onTabPress();
            break;
          }
          case constants.Keys.esc: {
            this.onEscPress();
            break;
          }
          case constants.Keys.enter: {
            event.preventDefault();
            this.onSpaceOrEnterPress(event);
            break;
          }
          case constants.Keys.space: {
            this.onSpaceOrEnterPress(event);
            break;
          }
          default: {
            break;
          }
        }
      };

      MultiSelectFilter.prototype.selectItem = function(index) {
        var $item = this.$checkboxes.eq(index);

        this.currentItemIndex = index;
        this.$checkboxes.filter('[aria-selected=true]').attr('aria-selected', false);
        $item.focus().attr('aria-selected', true);
      };

      MultiSelectFilter.prototype.selectPrev = function() {
        if (this.currentItemIndex < 1) {
          return;
        }

        this.selectItem(this.currentItemIndex - 1);
      };

      MultiSelectFilter.prototype.selectNext = function() {
        if (this.currentItemIndex >= this.$checkboxes.length - 1) {
          return;
        }

        this.selectItem(this.currentItemIndex + 1);
      };

      /**
       * init events handlers
       */
      MultiSelectFilter.prototype.initEvents = function() {
        this.$el.on(events.close, this.onClose.bind(this))
          .on(events.open, this.onOpen.bind(this))
          .on(events.next, this.selectNext.bind(this))
          .on(events.prev, this.selectPrev.bind(this))
          .on('click', this.onClick.bind(this))
          .on('keydown', this.onKeyDown.bind(this));

        // Removing tags
        this.$tagsContainer.on('click.' + this.eventNamespace, classes.unselectTag, this.removeTag.bind(this));
        this.initReusedEvents();
      };

      MultiSelectFilter.prototype.initReusedEvents = function() {
        // Checkbox changing
        this.$checkboxesContainer.on('change.' + this.eventNamespace, ':checkbox', this.onCheckboxChange.bind(this));

        // Open/close dropdown
        this.$selectedParams.on('click.' + this.eventNamespace, function() {
          this.$el.trigger(this.isOpened() ? events.close : events.open);
        }.bind(this));

        this.$select.on('synchronize', this.onSync.bind(this));

        //reset skills counter
        this.$select.on('reset', this.resetSkillsCounter.bind(this));
      };

      /**
       * Unselect value in multiselect
       * @param value
       */
      MultiSelectFilter.prototype.unselect = function(value, skipSelectUpdate) {
        this.config.showTags && this.$tagsContainer.children(classes.filterTag).findByAttr('data-value', value.toString()).remove();
        this.$checkboxes.findByAttr('data-value', value).removeAttr('checked');
        !skipSelectUpdate && this.changeSelection(value, false);

        this.decrementCounter();
      };

      MultiSelectFilter.prototype.changeSelection = function(value, isActive) {
        var $option = this.$options.findByValue(value);

        if (isActive) {
          $option.attr('selected', 'selected').prop('selected', true);
        } else {
          $option.removeAttr('selected').prop('selected', false);
        }

        this.$select.trigger('change');
        this.$select.trigger(events.change, value);
      };

      /**
       * Select value in multiselect
       * @param value
       */
      MultiSelectFilter.prototype.select = function(value, skipSelectUpdate) {
        !skipSelectUpdate && this.changeSelection(value, true);
        this.addTag(value);
        this.$checkboxes.findByAttr('data-value', value).prop('checked', true);

        this.incrementCounter();
      };

      MultiSelectFilter.prototype.addTag = function(value) {
        if (!this.config.showTags) {
          return;
        }
        var text = this.$options.findByValue(value).html();
        dust.append('multi-select-filter-tag', {
          text: text,
          value: value,
        }, this.$tagsContainer);
      };

      /**
       * Positioning multiselect dropdown
       */
      MultiSelectFilter.prototype.isDropdownAbove = function() {
        var isDropdownAbove = $window.scrollTop() + $window.height() <
          this.$el.offset().top + this.$el.height() + this.$checkboxesContainer.outerHeight();

        this.isOpened() && this.$el.toggleClass('above', isDropdownAbove);
      };

      /**
       * Add the counter of selected skills
       */
      MultiSelectFilter.prototype.incrementCounter = function() {
        this.$selectedParams.addClass('selected');
        this.selectedCount++;
        this.$counterHolder.html(this.selectedCount);
      };

      MultiSelectFilter.prototype.updateCounter = function (value) {
          if (value > 0) {
              this.$selectedParams.addClass('selected');
              this.selectedCount = value;
              this.$counterHolder.html(this.selectedCount);
          }
      };

      /**
       * Remove the counter of selected skills
       */
      MultiSelectFilter.prototype.decrementCounter = function() {
          this.selectedCount--;

        if (this.selectedCount > 0) {
          this.$counterHolder.html(this.selectedCount);
        } else {
          this.$counterHolder.html('');
          this.$selectedParams.removeClass('selected');
        }
      };

      /**
       * Reset counter and remove selected skills
       */
      MultiSelectFilter.prototype.resetSkillsCounter = function() {
        this.selectedCount = 0;
        this.$counterHolder.html('');
        this.$selectedParams.removeClass('selected');
      };

      /**
       * Destroy component
       */
      MultiSelectFilter.prototype.destroy = function() {
        this.$tagsContainer.off('click.' + this.eventNamespace);
        this.$checkboxesContainer.off('change.' + this.eventNamespace);
        this.$selectedParams.off('click.' + this.eventNamespace);
        $window.off('click.' + this.eventNamespace + ' touchstart.' + this.eventNamespace);
        this.$select.removeData('multiSelectFilter');
        this.$el.remove();
      };

      /**
       * Widget multi select filter
       * @param {object} config
       * @param {function} config.callback callback after multi select initialization
       * @returns {jQuery}
       */
      $.fn.multiSelectFilter = function(config) {
        return this.each(function() {
          new MultiSelectFilter($(this), config || {});
        });
      };

      return MultiSelectFilter;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Text', ['utils'], function (utils) {
    'use strict';

    /**
     * Text component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$el.find('table').wrap('<div class="' + this.classes.tableWrapper + '"></div>');
        utils.insertArrowForLinks(this.$el);
    }

    Component.prototype.classes = {
        tableWrapper: 'text__table-wrapper'
    };

    Component.moduleName = 'Text';
    Component.selector = '.text-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('TextField', ['form', 'form-control', 'OverallExperienceTextField'], function (form, FormControl, OverallExperienceField) {
  'use strict';

  function Component($el) {
    FormControl.call(this, $el);
    this.$input = this.$el.find('input');
    this.registerField();
    this.setUpUrlParams();
    this.checkIfFieldIsOverallExperience();
  }

  Component.prototype = Object.create(FormControl.prototype);

  Component.prototype.checkIfFieldIsOverallExperience = function() {
    var result = OverallExperienceField.isOverExperienceField(this.$el[0]);
    if (result) {
      new OverallExperienceField(this.$el[0], this);
    }
  };

  Component.prototype.setUpUrlParams = function () {
    var textFieldParams = this.$input.attr('data-fill-req-param');
    var reg = new RegExp('[\?&]' + textFieldParams + '=([^&#]*)').exec(window.location.href);
    if (reg) {
      this.$input.val(decodeURIComponent(reg[1]));
    }
  };

  Component.prototype.registerField = function () {
    form.registerField({
      form: this.$form,
      field: this.$input.attr('name'),
      cleanField: this.cleanField.bind(this),
      displayValue: this.displayValue.bind(this),
      cleanError: this.toggleError.bind(this),
      displayError: this.toggleError.bind(this),
      validator: this.getValidator(),
      validationEvent: this.validationEvents
    });
  };

  Component.prototype.getValidator = function () {
    var validatorFactory = this.context.constraintRegex ? form.constraintValidator : form.requiredValidator;
    return validatorFactory(this.$input, this.context);
  };

  Component.prototype.validationEvents = 'change blur DOMAutoComplete';

  Component.moduleName = 'Text Field';
  Component.selector = '.text-field-ui';

  return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('OverallExperienceTextField', [], function() {
    'use strict';

    var INDIA_COUNTRY = 'India';
    var INDEPENDENT_FORM_TYPE = 'epam-com/components/form/action/apply-for-job-independent';
    var classes = {
        location: 'div.country-field-ui[name="applicantCountry"]',
        hidden: 'hidden'
    };

    function Component(el, parentInc) {
        this.el = el;
        this.parentInc = parentInc;
        this.input = this.el.querySelector('input');
        this.locations = null; //locations selector form field
        this.independentForm = false;
        this.init();
    }

    Component.isOverExperienceField = function(el) {
        return el.classList.contains('overall-experience-text-field');
    };

    Component.prototype.init = function() {
        this.checkIsFormIndependent();
        this.findLocationField();
        this.registerLocationsListeners();
    };

    Component.prototype.findLocationField = function() {
        this.locations = document.querySelector(classes.location).parentNode;
    };

    /**
     * for independent form
     */
    Component.prototype.registerLocationsListeners = function() {
        if (this.locations && this.independentForm) {
            $(this.locations).on('location.changed.country:withoutRegions', this.locationsEventHandler.bind(this));
        }
    };

    Component.prototype.checkIsFormIndependent = function() {
        var formType = document.querySelector('.form-type');
        if (formType) {
            this.independentForm = formType.dataset.formType === INDEPENDENT_FORM_TYPE;
        }
    };

    /**
     * @param _
     * @param params - send by location selector
     */
    Component.prototype.locationsEventHandler = function(_, params) {
        var action = params && params.countryName === INDIA_COUNTRY ? 'remove' : 'add';
        this.el.classList[action](classes.hidden);
        this.toggleRequiredOption(action);
    };

    Component.prototype.toggleRequiredOption = function(action) {
        this.parentInc.context.isRequired = action !== 'add';
    };

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Phone', ['form', 'form-control', 'utils'], function (form, FormControl, utils) {
    'use strict';

    var $body = $('body');

    function Component($el) {
        FormControl.call(this, $el);
        this.$input = this.$el.find('input');
        this.inputPlaceholder = this.$input.attr('placeholder');
        this.validations = {
            isRequired: this.$el.data('required')
        };
        this.registerField();
        this.$label = this.$el.find('.form-component__label');
        this.labelText = this.$el.find('.form-component__label').text().trim();
        this.constraintRegex = this.$el.data('required');

        $body.on('select-location:dropdown-change', this.handlePhoneOnCountryChange.bind(this));
    }

    Component.prototype = Object.create(FormControl.prototype);

    Component.prototype.registerField = function () {
        form.registerField({
            form: this.$form,
            field: this.$input.attr('name'),
            cleanField: this.cleanField.bind(this),
            displayValue: this.displayValue.bind(this),
            cleanError: this.toggleError.bind(this),
            displayError: this.toggleError.bind(this),
            validator: this.getValidator(),
            validationEvent: this.validationEvents
        });
    };

    Component.prototype.getValidator = function () {
        var validatorFactory = this.context.constraintRegex ? form.constraintValidator : form.requiredValidator;
        var validator = validatorFactory(this.$input, this.context);
        return function () {
            if (this.context.isRequired) {
                return validator();
            }
            if (this.context.constraintRegex) {
                return validator();
            }
            return [];
        }.bind(this);
    };

    /**
     * Make phone field required for job forms when country is India
     * @param e - event
     * @param param - object with countryName field
     */
    Component.prototype.handlePhoneOnCountryChange = function (e, param) {
        // To get form type <div class="form-type hidden" > with data attribute was added for form-constructor
        var formType = this.$el.parents('.form-constructor-ui').find('.form-type').data('form-type');
        var isApplyForJobIndependent = formType === 'epam-com/components/form/action/apply-for-job-independent';
        var isApplyForJobSpecific = formType === 'epam-com/components/form/action/apply-for-job-specific';
        var isIndiaCountry = param && param.countryName === 'India';

        if ((isApplyForJobIndependent && isIndiaCountry || isApplyForJobSpecific) && !this.context.isRequired ) {
            this.context.isRequired = true;
            this.$label.text(this.labelText + '*');
            if (!utils.isRedesign23()) {
                this.$input.attr('placeholder', this.inputPlaceholder + '*');
            }
        } else {
            this.context.isRequired = this.validations.isRequired;
            this.$label.text(this.labelText);
            this.$input.attr('placeholder', this.inputPlaceholder);
            this.$form.trigger('FIELD_VALIDATION_RESULT:userPhone', { errors: [], checkFields: true });
        }
    };

    Component.prototype.validationEvents = 'change blur DOMAutoComplete';

    Component.moduleName = 'Phone';
    Component.selector = '.phone-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

// eslint-disable-next-line max-params
define('MultiPageForm', ['form', 'form-control', 'TabsUtil', 'constants', 'utils', 'gradients'], function (form, FormControl, TabsUtil, constants, utils, gradients) {
    'use strict';

    var DEFAULT_TOP_OFFSET = 100;

    var classes = {
            page: '.multi-page-form__item',
            formDescription: '.multi-page-form__description',
            controlsDescription: '.multi-page-form__controls-description',
            field: '.form-component__field',
            skipLink: '.multi-page-form__skip-link',
            submit: '.end button[type="submit"]',
            complete: 'complete',
            visible: 'visible',
            mainForm: '[data-open-form]',
            currentPage: 'html, body',
            submitAgainButton: '.submit-again-arrow-container',
            multilineGradient: '.multiline-gradient',
        };

    var captchaName = ':captchaKey';
    var captchaInputName = 'captcha';

    function checkRequiredField($field) {
        return form.requiredValidator($field, {isRequired: true})().length;
    }

    function Component($el) {
        TabsUtil.call(this, $el, {
            items: $el.find(classes.page)
        });
        this.$isNeedToMove = $($el).find(this.classes.mainForm);
        this.$nextButton = $($el).find('.multi-page-form__button--23');
        this.$skipLink = this.$el.find(classes.skipLink);
        this.$formDescription = this.$el.find(classes.formDescription);
        this.$pageCounterHolder = this.$formDescription.find('span');
        this.$controlCounterHolder = this.$el.find(classes.controlsDescription + ' span');
        this.$submit = this.$el.find(classes.submit).on('click', this.onSubmit.bind(this));
        this.itemsLength = this.$items.length;
        this.$nav.off('click').on('click', 'button', this.onNavClick.bind(this));
        this.$nextButton.on('click', this.onNavClick.bind(this));
        this.initForm();
        this.listenChanges();
        this.updatePageStatus(this.activeItem);
        this.addArrow();
        // after first form submit there is no need to apply gradients again
        this.isSubmittedOnce = false;

        if (this.$isNeedToMove) {
            this.scrollToTheBeginningOfTheForm();
        }
    }

    Component.prototype = Object.create(TabsUtil.prototype);

    Component.prototype.addArrow = function () {
        var buttons = this.$el.find(this.classes.submitAgainButton);

        for (var i = 0; i < buttons.length; i++) {
            utils.insertArrowPicture($(buttons[i]));
        }
    };

    Component.prototype.initForm = function () {
        this.formComponent = new form.FormComponent(this.$el);
        this.formComponent.initialize();
        this.requiredFieldsMap = this.mapRequiredFieldsToPages();
        this.formComponent.form.on(form.events.CLEAN_UP, this.clearStatus.bind(this));
        this.$skipLink.on('click', this.handleSkipLink.bind(this));
        this.formComponent.onSuccessfulSubmit = this.onSuccessfulSubmit.bind(this);
    };

    Component.prototype.scrollToTheBeginningOfTheForm = function () {
        if (history.scrollRestoration) {
            history.scrollRestoration = 'manual';
        }

        $(this.classes.currentPage).scrollTop(this.$el.offset().top - DEFAULT_TOP_OFFSET);
    };

    Component.prototype.validatePageFields = function () {
        var pageStatus = this.getPageStatus(this.activeItem);
        if (!pageStatus) {
            $.each(this.requiredFieldsMap[this.activeItem], function (index, item) {
                if (!item[0].value.length) {
                    var $itemWrapper = $(item).closest('[data-required]');
                    $itemWrapper.addClass(FormControl.classes.fieldError);
                    $itemWrapper.find('.' + FormControl.classes.validationText).text($itemWrapper.data('required-msg'));
                }
            });

            this.formComponent.scrollToError();
        }

        return pageStatus;
    };

    Component.prototype.onSubmit = function (event) {
        if (!this.getPageStatus(this.activeItem)) {
            event.preventDefault();
            this.validatePageFields();
        }
    };


    Component.prototype.onNavClick = function (event) {
        event.preventDefault();

        var $target = $(event.currentTarget);

        $target.is(this.classes.prevButton) && this.$el.trigger(TabsUtil.events.tabChange, { tab: this.activeItem - 1 });

        if (!this.getPageStatus(this.activeItem)) {
            this.validatePageFields();

            return;
        }

        $target.is(this.classes.nextButton) && this.$el.trigger(TabsUtil.events.tabChange, { tab: this.activeItem + 1 });

        this.afterClick();
    };

    Component.prototype.mapRequiredFieldsToPages = function () {
        var hasRecaptcha = this.isRecaptchaEnable();
        var map = [];
        $.each(this.$items, function (index, page) {
            if (!map[index]) {
                map[index] = [];
            }
            var $fields = $(page).find('[data-required] [name]:not([data-required=false])');
            $.each($fields, function () {
                var filedName = $(this).attr('name');
                if (
                    filedName === captchaInputName && hasRecaptcha ||
                    filedName === captchaName && hasRecaptcha
                ) {
                    return;
                }
                map[index].push($(this));
            });
        });
        return map;
    };

    Component.prototype.listenChanges = function () {
        var listenChange = function (field) {
            field.on('change', function () {
                this.updatePageStatus();
            }.bind(this));
        }.bind(this);

        this.requiredFieldsMap.forEach(function (fields) {
            fields.map(listenChange);
        });
    };

    Component.prototype.updatePageStatus = function () {
        var activeItem = this.activeItem + 1;
        var itemsLength = this.itemsLength;
        this.$submit.toggleClass(classes.visible, activeItem === this.itemsLength);
        this.$prevButton.toggleClass(constants.Classes.hidden, activeItem <= 1);

        this.$el.find(this.classes.nextButton).each(function () {
            $( this ).toggleClass(constants.Classes.hidden, activeItem >= itemsLength);
        });
    };

    Component.prototype.getPageStatus = function (page) {
        return !this.requiredFieldsMap[page].map(checkRequiredField).filter(Boolean).length;
    };

    Component.prototype.clearStatus = function () {
        this.$el.trigger(TabsUtil.events.tabChange, { tab: 0 });
        this.$controlCounterHolder.text('1');
    };

    Component.prototype.afterClick = function () {
        this.updatePageStatus(this.activeItem);
        this.$el.scrollToSelector({reservedSpace: 100});

        this.$pageCounterHolder.text(this.activeItem + 1);
        this.$controlCounterHolder.text(this.activeItem + 1);
        this.$formDescription.focus();
    };

    Component.prototype.handleSkipLink = function (event) {
        event.preventDefault();

        var focusedButton = this.$prevButton.hasClass('hidden') ? this.$nextButton : this.$prevButton;
        focusedButton.focus().scrollToSelector({reservedSpace: 110});
    };

    Component.prototype.beforeScroll = function ($target) {
        $target.scrollToSelector({
            reservedSpace: 110,
            duration: 500
        });
    };

    Component.prototype.isRecaptchaEnable = function () {
        var recaptcha = this.$el.find('.recaptcha-ui');
        var formEL = this.$el.find('form');
        var captcha = formEL.find('.captcha-ui');
        return recaptcha.length && !captcha.length || recaptcha.length && !!captcha.length && captcha.data('recaptcha-enabled');
    };

    Component.prototype.onSuccessfulSubmit = function () {
        if (this.isSubmittedOnce) {
            return;
          }
          this.isSubmittedOnce = true;
          var nodes = this.$el[0].querySelectorAll(classes.multilineGradient);
          var gradientText = new gradients.GradientText();
          var N & DS_RIGHT_RATIO = 0.5;
          var N & DS_MIDDLE_RATIO = 1.4;
          gradientText.init(nodes, {rightRatio: N & DS_RIGHT_RATIO, middleRatio: N & DS_MIDDLE_RATIO});
    };

    Component.prototype.classes = $.extend({}, TabsUtil.prototype.classes, classes);

    Component.moduleName = 'Multi Page Form';
    Component.selector = '.multi-page-form-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ZipCode', ['AbstractLocationField', 'form', 'utils-env', 'geolocation', 'constants'], function (AbstractLocationField, form, env, geolocation, constants) {
    'use strict';

    /**
     * ZipCode Component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        AbstractLocationField.call(this, $el);
        this.$location.on(this.events.shouldUpdate, this.onParentChange.bind(this));
        this.$location.on(this.events.shouldHide, this.hide.bind(this));

        env.isEditMode() && this.$el.removeClass(constants.Classes.hidden);
        this.$closestForm.on(form.events.ACTIVATE_FORM, function () {
            this.geolocationEnabled && geolocation.onGeolocationUpdate(this.fillWithGeolocation.bind(this));
        }.bind(this));
    }

    Component.prototype = Object.create(AbstractLocationField.prototype);

    Component.prototype.addOption = function (code) {
        this.$select.append('<option value="' + code + '">' + code + '</option>');
    };

    /**
     * hide
     * Hides the field and resets it to the default state
     */
    Component.prototype.hide = function () {
        this.$el.addClass(constants.Classes.hidden);
        this.countryName = '';
        this.cleanField();
    };

    /**
     * onParentChange
     * Handler for parent (city) change event
     * @param { Event } event
     * @param {{ countryName: String, postalCodes: Array }} params
     */
    Component.prototype.onParentChange = function (event, params) {
        this.countryName = params.countryName;

        this.$select.empty()
            .val(null)
            .trigger('change')
            .append(this.getDefaultOption());
        this.registerSelectField({
            validator: this.optionalValidator,
        });

        params.postalCodes.map(this.addOption.bind(this));
        this.$el.removeClass(constants.Classes.hidden + ' ' + this.classes.errorField);

        Array.prototype.slice.call(document.querySelectorAll('.validation-text')).forEach( function (el) {
            el.innerHTML = '';
        });

        this.geolocationEnabled && geolocation.onGeolocationUpdate(this.fillWithGeolocation.bind(this));
        this.$location.trigger(constants.Events.locationSelectZipCodeUpdate);
    };

    Component.prototype.fillWithGeolocation = function (location) {
        var geolocationValue = location.postalCode;
        var zipCodeFieldValue = this.$el.find('.select2-selection__rendered').attr('title');

        if (!zipCodeFieldValue) {
            geolocationValue && this.$select.val(geolocationValue).trigger('change');
        }
    };

    Component.prototype.events = {
        shouldHide: 'location.changed.city:withoutPostalCodes location.changed.region location.changed.country:withRegions location.changed.country:withoutRegions',
        shouldUpdate: 'location.changed.city:withPostalCodes'
    };

    Component.moduleName = 'Zip Code Field';
    Component.selector = '.zip-code-field-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Region', ['AbstractLocationField', 'utils-env', 'geolocation', 'constants', 'form'], function (AbstractLocationField, env, geolocation, constants, form) {
    'use strict';

    var URL = '/services/location/regions';

    var classes = {
        source: '.region-field__source'
    };

    /**
     * Region Component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        AbstractLocationField.call(this, $el);
        this.$source = this.$el.find(classes.source);

        this.$select.on('change', this.onSelectChange.bind(this));
        this.$closestForm.on(form.events.ACTIVATE_FORM, function () {
            this.isGeolocation && geolocation.onGeolocationUpdate(this.fillWithGeolocation.bind(this));
        }.bind(this));
        this.$location.on('location.changed.country:withRegions', this.onParentChange.bind(this));
        this.$location.on('location.changed.country:withoutRegions', this.hide.bind(this));

        env.isEditMode() && this.$el.removeClass(constants.Classes.hidden);

        this.registerSelectField({
            validator: this.optionalValidator
        });
    }

    Component.prototype = Object.create(AbstractLocationField.prototype);

    /**
     * hide
     * Hides the field and resets it to the default state
     */
    Component.prototype.hide = function () {
        this.$el.addClass(constants.Classes.hidden);
        this.countryName = '';
        this.cleanField();
    };

    /**
     * onParentChange
     * Handler for parent (country) change event
     * @param { Event } event
     * @param {{ countryName: String }} params
     */
    Component.prototype.onParentChange = function (event, params) {
        this.$el.removeClass(this.classes.errorField);
        this.shouldValidate = false;
        this.countryName = params.countryName;
        this.isGeolocation = params.isGeolocation;
        this.$select.empty()
            .val(null)
            .trigger('change', { withoutValidation: true })
            .append(this.getDefaultOption())
            .append(this.$source.find('[data-country=' + this.countryName + ']').clone());
        this.$el.removeClass(constants.Classes.hidden);

        this.getRegions();
    };

    /**
     * getRegions
     * Sends Ajax request to get data about regions of the selected country
     */
    Component.prototype.getRegions = function () {
        var data = {
            country: this.countryName,
            locale: CQ.I18n.getLocale()
        };

        $.ajax({
            url: URL,
            data: data,
            cache: true,
            success: this.onLoadSuccess.bind(this),
            error: console.log
        });
    };

    /**
     * onLoadSuccess
     * Saves received data and fills select field with regions list
     * @param data
     */
    Component.prototype.onLoadSuccess = function (data) {
        this.regions = data;
        this.$select.empty()
            .val(null)
            .trigger('change', { withoutValidation: true });
        var appendContent = this.getDefaultOption();

        this.shouldValidate = true;
        this.$el.removeClass(constants.Classes.hidden);

        if (data.length) {
            this.regions.forEach(function (region) {
                var geolocationName = region.geolocationName || region.internationalName;
                appendContent += '<option value="' + region.internationalName + '" data-geolocation-name="' + geolocationName + '" data-iso-code-alpha-2="' + region.isoCodeAlpha2 + '">' + region.name + '</option>';
            });

            this.$select.val('').append(appendContent);
            this.$location.trigger(constants.Events.locationSelectRegionUpdate, {isEmpty: data.length});
        }

        this.isGeolocation && geolocation.onGeolocationUpdate(this.fillWithGeolocation.bind(this));
    };

    Component.prototype.fillWithGeolocation = function (location) {
        var geolocationValue = location.region;

        geolocationValue && this.$select.val(geolocationValue).trigger('change', { isGeolocation: true });
    };

    /**
     * onSelectChange
     * Handler for self change
     * Triggers event for City field
     */
    Component.prototype.onSelectChange = function (event, params) {
        var regionName = this.$select.val();

        if (!regionName) {
            return;
        }

        this.$location.trigger('location.changed.region', {
            countryName: this.countryName,
            regionName: regionName,
            isGeolocation: params && params.isGeolocation
        });
    };

    Component.prototype.classes = $.extend({}, AbstractLocationField.prototype.classes, classes);

    Component.moduleName = 'Region Field';
    Component.selector = '.region-field-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Country', ['AbstractLocationField', 'constants', 'geolocation', 'utils-env', 'form'], function (AbstractLocationField, constants, geolocation, env, form) {
    'use strict';

    var SELECT_NAMES = {
      PREFERABLE_COUNTRY: 'candidatePreferableCountry',
    };

    var $body = $('body');

    /**
     * Country Component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        AbstractLocationField.call(this, $el);
        this.configurationWithRegions = this.$location.data('configuration').indexOf('region') > -1;

        this.$select.on('change', this.onSelectChange.bind(this));
        this.$closestForm.on(form.events.ACTIVATE_FORM, function () {
            this.geolocationEnabled && geolocation.onGeolocationUpdate(this.checkAdditionalCondition.bind(this, this.fillWithGeolocation));
        }.bind(this));
        this.registerSelectField();
        this.$selection.addClass(this.classes.validationTarget)
            .attr('aria-required', this.$el.data('required'));
        if (!env.isEditMode() && this.$select.val() !== '') {
            setTimeout(function () {
                this.onSelectChange();
            }.bind(this), 0);
        }
    }

    Component.prototype = Object.create(AbstractLocationField.prototype);

    /**
     * In some cases we need to skip first 'ACTIVE_FIRST' event
     */
    Component.prototype.checkAdditionalCondition = function (callback, location) {
        var locationFieldName = this.$el.attr('name');
        var locationFieldValue = this.$el.find('.select2-selection__rendered').attr('title');
        locationFieldValue = locationFieldValue && locationFieldValue.trim();

        if (locationFieldName === SELECT_NAMES.PREFERABLE_COUNTRY && !this.$select.find('[data-geolocation-name="' + location.country + '"]').val()) {
            return;
        }

        /**
         * if we've already chosen some value and user make some mistakes during form fill
         * prevent setting default geolocation value
         */
        if (!locationFieldValue) {
            callback.call(this, location);
        }
    };

    Component.prototype.hasRegions = function (countryName) {
        return !!this.$select.children('[value="' + countryName + '"]').data('hasRegion');
    };

    /**
     * onSelectChange
     * Triggers event for showing regions, if needed
     * Otherwise, event for showing cities is triggered
     */
    Component.prototype.onSelectChange = function (event, params) {
        var selectNameAttribute = this.$el.attr('name');
        var vacancyCountriesDropDown = $('.dropdown-list-ui[displayconditions="vacancyCountry"]');
        var vacancyCountries = vacancyCountriesDropDown.attr('showdropdownlist');
        var isApplicantPreferredCountry = selectNameAttribute === 'applicantPreferredCountry';
        var isApplicantCountry = selectNameAttribute === 'applicantCountry';

        if (isApplicantPreferredCountry) {
            var titleAttributeValue = this.$el.find('.select2-selection__rendered').attr('title');
            var targetDropDown = $('.dropdown-list-ui[applicantpreferredcountries]');
            if (titleAttributeValue && targetDropDown[0]) {
                var currentSelectionOption = titleAttributeValue.trim();
                var preferredCountry = targetDropDown.attr('applicantpreferredcountries').split(',');
                if (preferredCountry.indexOf(currentSelectionOption) !== -1) {
                    targetDropDown.removeClass('hidden');
                    targetDropDown.trigger('setValidation', {isRequired: true});
                } else {
                    targetDropDown.addClass('hidden');
                    targetDropDown.trigger('setValidation', {isRequired: false});
                }
            } else {
                targetDropDown.addClass('hidden');
                targetDropDown.trigger('setValidation', {isRequired: false});
            }
        } else if (vacancyCountriesDropDown && vacancyCountries === 'false') {
            vacancyCountriesDropDown.addClass('hidden');
            vacancyCountriesDropDown.trigger('setValidation', {isRequired: false});
        }

        var countryName = this.$select.val(),
            eventName = this.configurationWithRegions && this.hasRegions(countryName) ? 'location.changed.country:withRegions' : 'location.changed.country:withoutRegions';
        if (countryName) {
            this.$el.find('.select2-selection__rendered').addClass('country-filled');
        }
        this.$location.trigger(eventName, {
            countryName: countryName,
            isGeolocation: params && params.isGeolocation
        });

        if (isApplicantCountry) {
            var internationCountryName = this.$select.find('option:selected').attr('data-geolocation-name');
            $body.trigger('select-location:dropdown-change', {
                countryName: internationCountryName ,
            });
        }
    };

    Component.prototype.fillWithGeolocation = function (location) {
        var countryName = location.country;

        if (!countryName) {
            return;
        }

        var geolocationValue = this.$select.find('[data-geolocation-name="' + countryName + '"]').val();

        this.$select.val(geolocationValue).trigger('change', { isGeolocation: true });
    };

    Component.prototype.wcmModeChange = null;

    Component.moduleName = 'Country Field';
    Component.selector = '.country-field-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('AbstractLocationField', ['form', 'form-control'], function (form, FormControl) {
    'use strict';

    var $body = $('body');

    var classes = {
        errorField: FormControl.classes.fieldError,
        errorTooltip: FormControl.classes.errorTooltip,
        validationText: FormControl.classes.validationText,
        input: '.form-component__input',
        label: '.form-component__label',
        formComponentField: 'form-component__field',
        field: 'location-fields__column',
        select: '.location-fields__select',
        location: '.location-fields-ui',
        placeholder: 'placeholder',
        selection: '.select2-selection',
        selectBoxContainer: '.select2-container',
        validationTarget: 'validation-focus-target',
        selectedPlaceholder: '.dropdown-list__selected-placeholder',
        epamContinuumStyle: 'epam-continuum-style',
    };

    /**
     * AbstractLocationField
     * @abstract
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$closestForm = this.$el.closest('form');
        this.$select = this.$el.find(classes.select);
        this.$input = this.$el.find(classes.input);
        this.$label = this.$el.find(classes.label);
        this.$errorTooltip = this.$el.find('.' + classes.errorTooltip);
        this.$location = this.$el.closest(classes.location);
        this.id = this.$select.attr('id');
        this.geolocationEnabled = this.$location.data('useGeolocation');
        this.initSelect();
        this.$selection = this.$el.find(classes.selection)
            .attr('aria-describedby', this.id + '-error');
        this.$selectedPlaceholder = this.$el.find(this.classes.selectedPlaceholder);
        this.isEpamContinuumStyle = this.$el.parents('.' + classes.epamContinuumStyle).length > 0;
        this.initialLabelText = this.$label.text();
        this.overlayScrollbarInstance = null;
    }

    Component.prototype.isActive = function () {
        return !!this.countryName;
    };

    /**
     * registerSelectField
     * Register single location field for validation
     * @param {{ [context]: Object, [validator]: Function }} [params]
     */
    Component.prototype.registerSelectField = function (params) {
        var options = params || {},
            context = options.context || form.extractValidationContext(this.$el),
            validator = options.validator && options.validator.bind(this) || form.requiredValidator;

        return form.registerField({
            form: this.$closestForm,
            field: this.fieldName || this.$select.attr('name'),
            cleanError: this.toggleError.bind(this),
            displayError: this.toggleError.bind(this),
            cleanField: this.cleanField.bind(this),
            validator: validator(this.$select, context),
            validationEvent: this.validationEvent
        });
    };

    Component.prototype.customMatcher = function (params, data) {
        if ($.trim(params.term) === '') {
            return data;
        }

        var term = params.term.toUpperCase();
        var termExp = '(^|.*\\s)(' + term + ')';

        if (term.match(/^[0-9]+$/)) {
            var regExp1 = new RegExp(term, 'i');
            if (data.text.match(regExp1)) {
                return data;
            }
        }

        if (data.text.trim().toUpperCase().match(termExp) !== null) {
            return data;
        }

        return null;
    };

    Component.prototype.initSelect = function () {
        this.$select.selectWoo({
            dropdownParent: this.$input,
            width: 'off',
            matcher: this.customMatcher.bind(this),
        });
        this.$selectBoxContainer = this.$el.find(classes.selectBoxContainer);
        this.$visibleInput = this.$el.find(classes.selection);
        this.$selectBoxContainer.addClass(classes.formComponentField);

        this.$visibleInput.on('blur', function () {
            this.$select.trigger('select2:blur');
        }.bind(this));

        this.$select.on('select2:selecting', function (event) {
            this.$selectedPlaceholder.text(event.params.args.data.text);
        }.bind(this));

        this.setOverlayScrollbar();
    };

    /**
     * OverlayScrollbar functionality
     */
    Component.prototype.setOverlayScrollbar = function () {
        var isRedesign23 = $body.hasClass('dark-mode') || $body.hasClass('light-mode');

        if (isRedesign23) {
            this.$select.on('select2:open', this.openDropdownScrollbar.bind(this));
            this.$select.on('select2:closing', this.destroyDropdownScrollbar.bind(this));
            $(document).on('input', this.$select.parent().find('.select2-search__field'), this.customizeDropdownScrollbar.bind(this));
            
        }
    };

    Component.prototype.openDropdownScrollbar = function () {
        this.destroyDropdownScrollbar();

        setTimeout(function () {
            var $list = this.$el.find('ul.select2-results__options');
            var $inputField = this.$select.parent().find('.select2-search__field');

            $list.unbind('mousewheel');
            this.overlayScrollbarInstance = OverlayScrollbars($list, { className: 'os-theme-dark'});
            this.destroyDropdownScrollbar();
            $inputField.trigger('input');
        }.bind(this), 10);
    };

    Component.prototype.customizeDropdownScrollbar = function () {
        this.destroyDropdownScrollbar();

        setTimeout(function () {
            var $list = this.$el.find('ul.select2-results__options');
            var $inputField = this.$select.parent().find('.select2-search__field');

            $list.unbind('mousewheel');
            this.overlayScrollbarInstance = OverlayScrollbars($list, { className: 'os-theme-dark'});
            $inputField.trigger('focus');
        }.bind(this), 10);
    };

    Component.prototype.destroyDropdownScrollbar = function () {
        if (this.overlayScrollbarInstance instanceof OverlayScrollbars) {
            this.overlayScrollbarInstance.destroy();
        }
    };

    /**
     * cleanField
     * Deselect any values from select without triggering validation
     */
    Component.prototype.cleanField = function () {
        this.$select.val('').trigger('change', { withoutValidation: true });
    };

    /**
     * toggleError
     * Show or hide error with passed text
     * @param { String } error
     */
    Component.prototype.toggleError = function (error) {
        this.$el.toggleClass(classes.errorField, !!error);
        this.$el.find('.' + classes.validationText).text(error || '');
        this.$errorTooltip.find('.is-a11y-only').toggleClass('hidden', !error);
    };

    /**
     * optionalValidator
     * validator function for N & DS.form
     * Makes current field required only when it is required for selected country
     * @param { jQuery } $select
     * @param { Object } context N & DS.form context
     * @return {function(this:Component)} onValidation callback
     */
    Component.prototype.optionalValidator = function ($select, context) {
        var requiredValidator = form.requiredValidator($select, context);

        return function () {
            if (this.isActive()) {
                return requiredValidator();
            }
            return [];
        }.bind(this);
    };

    /**
     * getDefaultOption
     * Returns placeholder element, needed for correct default selection behavior
     * @return {string}
     */
    Component.prototype.getDefaultOption = function () {
        return '<option value="" disabled selected/>';
    };

    /**
     * wcmModeChange
     * Handler for showing all fields in the edit mode
     * @param { String } wcmMode
     */
    Component.prototype.wcmModeChange = function (wcmMode) {
        var isEdit = wcmMode === 'edit';
        this.$el.toggleClass('hidden', !isEdit);
    };

    Component.prototype.validationEvent = 'change blur select2:close';
    Component.prototype.classes = classes;

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('City', ['AbstractLocationField', 'form-control', 'form', 'utils-env', 'geolocation', 'constants'], function (AbstractLocationField, FormControl, form, env, geolocation, constants) {
    'use strict';

    var URL = '/services/location/cities';

    var classes = {
        inputField: '.city-field__input',
        renderedField: '.select2-selection__rendered',
    };

    /**
     * City Component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        AbstractLocationField.call(this, $el);
        this.configuration = this.$location.data('configuration');
        this.locationsType = this.$location.data('locationsType');

        var disallowOtherList = this.$el.data('disallowOther');
        this.countriesWithoutOther = disallowOtherList && disallowOtherList.split(',');

        this.$select.on('change', this.onSelectChange.bind(this));
        this.$selectBox = this.$el.find('.select2');
        this.$inputField = this.$el.find(classes.inputField);
        this.fieldName = this.$el.data('fieldName');
        this.dontShowCities = this.$el.data('dontShowCities');
        this.shouldValidate = false;

        this.$location.on('location.changed.country:withoutRegions', this.onParentChange.bind(this))
            .on('location.changed.region', this.onParentChange.bind(this))
            .on('location.changed.country:withRegions', this.cleanField.bind(this));

        env.isEditMode() && this.$el.removeClass(constants.Classes.hidden);
        this.validationCallback = this.registerSelectField({
            validator: this.validator
        });
        this.$closestForm.on(form.events.ACTIVATE_FORM, function (event, eventType) {
            this.cancelValidation = null;
            if (eventType === 'pageshow') {
                this.cancelValidation = {withoutValidation: true};
            }
            this.geolocationEnabled && geolocation.onGeolocationUpdate(this.checkAdditionalCondition.bind(this, this.fillWithGeolocation));
        }.bind(this));
        this.$selection.addClass(this.classes.validationTarget);

        this.$inputField.on('keydown', function () {
          this.isMaxLengthReached();
        }.bind(this));
    }

    Component.prototype = Object.create(AbstractLocationField.prototype);

    Component.prototype.checkAdditionalCondition = function (callback, location) {
        var locationFieldValue = this.$el.find(classes.renderedField).attr('title');

        /**
         * if we've already chosen some value and user make some mistakes during form fill
         * prevent setting default geolocation value
         */
        if (!locationFieldValue) {
            callback.call(this, location);
        }
    };

    /**
     * validator
     * Custom field validation for N & DS.form
     * Makes select required when other value disallowed or not selected
     * Otherwise input field is required
     * @param { jQuery } $select
     * @param { Object } context N & DS.form context
     * @return {function(this:Component)} onValidation callback
     */
    Component.prototype.validator = function ($select, context) {
        var requiredValidator = form.requiredValidator($select, context),
            inputValidator = form.requiredValidator(this.$inputField, context);

        return function () {
            if (!this.isActive() || !this.shouldValidate) {
                return [];
            }
            if (this.$inputField.hasClass(constants.Classes.hidden)) {
                return requiredValidator();
            }
            return inputValidator();
        }.bind(this);
    };

    Component.prototype.isMaxLengthReached = function () {
        var maxLengthMessage = Number(this.$inputField.attr('maxlength'));
        var errorMessage = this.$inputField.attr('data-constraint-msg');
        if ( maxLengthMessage === this.$inputField.val().length ) {
            this.$el.addClass('validation-field');
            $('.validation-text').text(errorMessage);
            setTimeout(function () {
                $('.city-field-ui').removeClass('validation-field');
            }, 5000);
        }
    };

    /**
     * isOtherValueDisallowed
     * Checks whether selected country allows custom city input or no
     * @return {boolean}
     */
    Component.prototype.isOtherValueDisallowed = function () {
        return this.countriesWithoutOther && this.countriesWithoutOther.indexOf(this.countryName) > -1;
    };

    /**
     * cleanField
     * Hides field and resets it to its default state
     */
    Component.prototype.cleanField = function () {
        this.$el.addClass(constants.Classes.hidden);
        this.toggleField(this.$inputField);
        this.toggleField(this.$select, true);
        this.$inputField.removeClass(FormControl.classes.focusTarget);
        this.$selection.addClass(FormControl.classes.focusTarget);
        this.countryName = '';
    };

    /**
     * onParentChange
     * Event handler for selection of parent location
     * @param { Event } event
     * @param {{ countryName: String, regionName: String }} params
     */
    Component.prototype.onParentChange = function (event, params) {
        this.$el.removeClass(this.classes.errorField);
        this.shouldValidate = false;
        this.countryName = params.countryName;
        this.regionName = params.regionName;
        this.isGeolocation = params.isGeolocation;

        this.countryName && this.getCities();
    };

    /**
     * getCities
     * Sends Ajax request to get data about cities of the selected country (and region)
     */
    Component.prototype.getCities = function () {
        var data = {
            country: this.countryName,
            locale: CQ.I18n.getLocale(),
            configuration: this.configuration,
            locationsType: this.locationsType
        };

        if (this.regionName) {
            data.region = this.regionName;
        }

        $.ajax({
            url: URL,
            data: data,
            cache: true,
            success: function (event) {
                this.clearRenderedTitle();
                this.onLoadSuccess(event);
            }.bind(this),
            error: console.log
        });
    };

    /**
     * clear previous settled value in 'title' prop
      */
    Component.prototype.clearRenderedTitle = function () {
        this.$el.find(classes.renderedField).attr('title', '');
    };

    /**
     * onLoadSuccess
     * Saves received data and fills select field with cities list
     * @param data
     */
    Component.prototype.onLoadSuccess = function (data) {
        this.cities = data;
        this.$select.empty()
            .val(null)
            .trigger('change', { withoutValidation: true });
        var isOtherAllowed = !this.isOtherValueDisallowed(),
            isInputShown = !data.length && isOtherAllowed,
            appendContent = this.getDefaultOption();

        this.shouldValidate = true;
        this.$el.removeClass(constants.Classes.hidden);
        this.$inputField.val(null);
        this.toggleField(this.$inputField, isInputShown);
        this.toggleField(this.$select, !isInputShown);

        if  (this.cities.length === 0 && this.dontShowCities) {
            this.$el.addClass('hidden');
        }

        if (data.length) {
            this.cities.forEach(function (city) {
                var geolocationName = city.geolocationName || city.internationalName;
                appendContent += '<option value="' + city.internationalName + '" data-geolocation-name="' + geolocationName + '">' + city.name + '</option>';
            });

            this.$select.val('');
        }

        if (isOtherAllowed) {
            appendContent += '<option value="other" data-geolocation-name="other">' + CQ.I18n.getMessage('component.location-fields.other-city') + '</option>';
        }

        if (data.length || isOtherAllowed) {
            this.$select.append(appendContent);
        }

        this.isGeolocation && geolocation.onGeolocationUpdate(this.fillWithGeolocation.bind(this));
        this.$location.trigger(constants.Events.locationSelectCityUpdate, {isEmpty: data.length});
    };

    Component.prototype.fillWithGeolocation = function (location) {
        var cityName = location.city;

        if (!cityName || this.cities === undefined || this.cities.length === 0) {
            return;
        }

        var geolocationValue = this.$select.find('[data-geolocation-name="' + cityName + '"]').val();

        if (!geolocationValue) {
            this.cityIsNotFound = true;
        }
        this.$select.val(geolocationValue ? geolocationValue : 'other').trigger('change');
        geolocationValue && this.$inputField.val(cityName);
    };

    /**
     * onSelectChange
     * Shows input for other value, if needed
     * Otherwise triggers event to show postalCodes, if needed
     */
    Component.prototype.onSelectChange = function () {
        var selectedCityName = this.$select.val();

        if (selectedCityName === null) {
            return;
        }

        this.$el.removeClass(this.classes.errorField);

        if (selectedCityName === 'other') {
            if (!this.dontShowCities) {
                this.toggleField(this.$select);
                this.toggleField(this.$inputField, true);
                this.$inputField.val(null);
                this.$selection.removeClass(FormControl.classes.focusTarget);
                this.$inputField.addClass(FormControl.classes.focusTarget);
                this.$location.trigger('location.changed.city:withoutPostalCodes');
            }
            if (!this.cityIsNotFound && !this.cancelValidation) {
                this.$inputField.focus();
            }
            this.cityIsNotFound = false;
            return;
        }

        var selectedCity = this.cities.find(function (el) {
                return el.internationalName === selectedCityName;
            }),
            postalCodes = selectedCity && selectedCity.postalCodes,
            eventName = postalCodes.length ? 'location.changed.city:withPostalCodes' : 'location.changed.city:withoutPostalCodes';

        this.$location.trigger(eventName, !postalCodes ? null : {
            postalCodes: postalCodes,
            countryName: this.countryName,
            isGeolocation: this.isGeolocation
        });
    };

    Component.prototype.toggleField = function ($field, isShown) {
        var $visibleField = this.$select === $field ? this.$selectBox : $field;

        if (isShown) {
            $visibleField.removeClass(constants.Classes.hidden);
            $field.attr('name', this.fieldName).on(this.validationEvent, function(event) {
                this.validationCallback(event, this.cancelValidation);
            }.bind(this));
            return;
        }
        $visibleField.addClass(constants.Classes.hidden);
        $field.removeAttr('name').off(this.validationEvent, this.validationCallback);
    };

    Component.prototype.classes = $.extend({}, AbstractLocationField.prototype.classes, classes);

    Component.moduleName = 'City Field';
    Component.selector = '.city-field-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('LocationField', ['LocationField-City', 'LocationField-Country'], function (City, Country) {
    'use strict';

    var classes = {
        country: '.country-field',
        city: '.city-field'
    };

    function Component($el) {
        this.$el = $el;
        this.$form = this.$el.closest('form');
        this.$country = this.$el.find(classes.country);
        this.$city = this.$el.find(classes.city);

        this.showCity = this.$el.data('showCity');
        this.fieldOptions = {
            $form: this.$form,
            requiredType: this.$el.data('requiredType'),
            requiredMsg: this.$el.data('requiredMsg'),
            geolocationEnabled: this.$el.data('useGeolocation')
        };

        this.showCity && this.initCityField();
        this.initCountryField();
    }

    Component.prototype.initCityField = function () {
        var options = $.extend({ $el: this.$city }, this.fieldOptions);

        this.city = new City(options);
    };

    Component.prototype.initCountryField = function () {
        var options = $.extend({
            $el: this.$country,
            showCity: this.showCity,
            city: this.city
        }, this.fieldOptions);

        this.country = new Country(options);
    };

    Component.prototype.classes = classes;

    Component.moduleName = 'Location Field';
    Component.selector = '.location-field-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('LocationField-City', ['form', 'geolocation', 'constants', 'form-control'], function (form, geolocation, constants, FormControl) {
    'use strict';

    var classes = {
        column: '.location-field__column',
        input: '.city-field__input',
        select: '.city-field__selection',
        selectBox: '.select2',
        options: 'city-field__options',
        visibleInput: 'select2-selection',
        selectBoxContainer: '.select2-container',
        formComponentField: 'form-component__field',
        selectedPlaceholder: '.dropdown-list__selected-placeholder'
    };

    function Component(options) {
        this.$el = options.$el;
        this.$form = options.$form;

        this.requiredType = options.requiredType;
        this.requiredMsg = options.requiredMsg;

        this.$column = this.$el.closest(classes.column);
        this.$input = this.$el.find(classes.input).show().detach();
        this.$select = this.$el.find(classes.select);
        this.$options = this.$el.find('.' + classes.options);
        this.$errorTooltip = this.$el.find('.' + FormControl.classes.errorTooltip);
        this.$errorText = this.$el.find('.' + FormControl.classes.validationText);
        this.id = this.$input.attr('id');
        this.$selectedPlaceholder = this.$column.find(this.classes.selectedPlaceholder);

        this.eventListened = {
            select: false,
            input: false
        };

        this.fieldName = this.$el.data('name');
        this.validationCallback = form.validationCallback(this.$form, this.fieldName, this.validator.bind(this));

        this.initSelect();
        this.registerField();
    }

    Component.prototype.initSelect = function () {
        this.$select.selectWoo({
            dropdownParent: this.$el,
            width: 'off'
        }).detach();
        this.$selectBox = this.$el.find(classes.selectBox).addClass(constants.Classes.hidden);

        this.$select.on('change', this.onSelectChange.bind(this));

        this.$selectBoxContainer = this.$el.find(classes.selectBoxContainer);
        this.$selectBoxContainer.addClass(classes.formComponentField);

        this.visibleInput = this.$el.find('.' + classes.visibleInput);
        this.visibleInput.addClass(FormControl.classes.focusTarget)
            .attr('aria-describedby', this.id + '-error');

        this.visibleInput.on('blur', function () {
            this.$select.trigger('select2:blur');
        }.bind(this));

        this.$select.on('select2:selecting', function (event) {
            this.$selectedPlaceholder.text(event.params.args.data.text);
        }.bind(this));
    };

    Component.prototype.fillWithGeolocation = function (location) {
        var cityName = location.city;

        if (!cityName) {
            return;
        }

        var geolocationValue = this.$select.find('[data-geolocation-name="' + cityName + '"]').val();

        if (geolocationValue) {
            this.$select.val(geolocationValue).trigger('change');
        } else {
            this.$select.val('Other').trigger('change');
            this.$input.val(cityName);
        }
    };

    Component.prototype.onSelectChange = function () {
        if (this.isCityOther(this.$select.val())) {
            this.setInputVisibility(true);
            this.toggleError(false);
        }
    };

    Component.prototype.changeSelectionSet = function (country) {
        var $cities = this.$options.children('[data-country="' + country + '"]');

        this.$select.children('[data-country]').appendTo(this.$options);
        this.$select.children(':first').after($cities);

        this.setInputVisibility(!this.hasCityOptions());
        return this;
    };

    Component.prototype.setInputVisibility = function (turnTextFieldActive) {
        if (turnTextFieldActive) {
            this.$select = this.turnActiveContainer(this.$input, this.$select, 'input', 'blur change DOMAutoComplete', this.validationCallback.bind(this));
            this.visibleInput.removeClass(FormControl.classes.focusTarget);
        } else {
            this.$input = this.turnActiveContainer(this.$select, this.$input, 'select', 'change blur select2:blur', this.selectionValidationCallback.bind(this));
            this.visibleInput.addClass(FormControl.classes.focusTarget);
        }
        this.$selectBox.toggleClass(constants.Classes.hidden, turnTextFieldActive);
    };

    Component.prototype.turnActiveContainer = function (active, inactive, inputType, event, handler) {
        var detached = inactive.detach();
        this.$el.prepend(active);
        active.addClass(FormControl.classes.focusTarget);
        inactive.removeClass(FormControl.classes.focusTarget);
        if (!this.eventListened[inputType]) {
            active.on(event, handler);
            this.eventListened[inputType] = true;
        }
        return detached;
    };

    Component.prototype.selectionValidationCallback = function (event, data) {
        if (!this.isCityOther(this.$select.val())) {
            this.validationCallback(event, data);
        }
    };

    Component.prototype.isCityOther = function (value) {
        return value && value.toLowerCase() === this.constants.CITY_OTHER.toLowerCase();
    };

    Component.prototype.registerField = function () {
        form.registerField({
            form: this.$form,
            field: this.fieldName,
            cleanError: this.toggleError.bind(this),
            displayError: this.toggleError.bind(this),
            cleanField: this.cleanField.bind(this),
            displayValue: this.setValue.bind(this),
            validator: this.validator.bind(this)
        });
    };

    Component.prototype.toggleError = function (error) {
        this.$column.toggleClass(FormControl.classes.fieldError, !!error);
        this.$errorText.text(error || '');
        this.$errorTooltip.find('.is-a11y-only').toggleClass('hidden', !error);
        return this;
    };

    Component.prototype.cleanField = function () {
        var defaultValue = this.hasCityOptions() ? '' : this.constants.CITY_OTHER;

        this.$select.val(defaultValue).trigger('change', { withoutValidation: true });
        this.$input.val('');
        return this;
    };

    Component.prototype.setValue = function (event, value) {
        var hasCityOptions = this.hasCityOptions();

        if (hasCityOptions) {
            this.$select.val(value).change();
        } else {
            this.$input.val(value);
        }
        this.setInputVisibility(!hasCityOptions);
    };

    Component.prototype.hasCityOptions = function () {
        return this.$select.children().length > this.constants.DEFAULT_OPTIONS;
    };

    Component.prototype.validator = function () {
        var result = [];
        if (this.requiredType === 'countryAndCity') {
            var selectionValue = this.$select.val(),
                inputValue = this.$input.val();

            if (!selectionValue || this.isCityOther(selectionValue) && !inputValue) {
                result.push(this.requiredMsg);
            }
        }
        return result;
    };

    Component.prototype.toggle = function (enable) {
        this.$column.toggleClass(constants.Classes.hidden, !enable);
        return this;
    };

    Component.prototype.constants = {
        CITY_OTHER: 'Other',
        DEFAULT_OPTIONS: 2
    };
    Component.prototype.classes = classes;

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('LocationField-Country', ['form', 'form-control', 'geolocation'], function (form, FormControl, geolocation) {
    'use strict';

    var classes = {
        column: '.location-field__column',
        select: '.country-field__selection',
        visibleInput: '.select2-selection',
        selectBoxContainer: '.select2-container',
        formComponentField: 'form-component__field',
        selectedPlaceholder: '.dropdown-list__selected-placeholder'
    };

    function Component(options) {
        FormControl.call(this, options.$el);

        this.requiredType = options.requiredType;
        this.requiredMsg = options.requiredMsg;
        this.showCity = options.showCity;
        if (this.showCity) {
            this.city = options.city;
        }

        this.$column = this.$el.closest(classes.column);
        this.$input = this.$el.find(classes.select);
        this.id = this.$input.attr('id');
        this.$selectedPlaceholder = this.$column.find(this.classes.selectedPlaceholder);

        this.initSelect();
        this.registerField();
        if (options.geolocationEnabled) {
            geolocation.onGeolocationUpdate(this.fillWithGeolocation.bind(this));
            this.showCity && geolocation.onGeolocationUpdate(this.city.fillWithGeolocation.bind(this.city));
        }

        if (this.$input.val() !== '' && this.showCity) {
            this.onSelectChange();
        }
    }

    Component.prototype = Object.create(FormControl.prototype);

    Component.prototype.initSelect = function () {
        this.$input.selectWoo({
            dropdownParent: this.$el,
            width: 'off'
        });

        this.$selectBoxContainer = this.$el.find(classes.selectBoxContainer);
        this.$selectBoxContainer.addClass(classes.formComponentField);
        this.visibleInput = this.$el.find(classes.visibleInput);
        this.visibleInput.addClass(FormControl.classes.focusTarget)
            .attr('aria-describedby', this.id + '-error');

        if (this.showCity) {
            this.$input.on('change', this.onSelectChange.bind(this));
        }

        this.visibleInput.on('blur', function () {
            this.$input.trigger('select2:blur');
        }.bind(this));

        this.$input.on('select2:selecting', function (event) {
            this.$selectedPlaceholder.text(event.params.args.data.text);
        }.bind(this));
    };

    Component.prototype.fillWithGeolocation = function (location) {
        var countryName = location.country;

        if (!countryName) {
            return;
        }

        var geolocationValue = this.$input.find('[data-geolocation-name="' + countryName + '"]').val();

        geolocationValue && this.$input.val(geolocationValue).trigger('change');
    };

    Component.prototype.onSelectChange = function () {
        this.city.changeSelectionSet(this.$input.val())
            .toggleError(false)
            .toggle(true)
            .cleanField();
    };

    Component.prototype.registerField = function () {
        form.registerField({
            form: this.$form,
            field: this.$el.data('name'),
            cleanError: this.toggleError.bind(this),
            displayError: this.toggleError.bind(this),
            cleanField: this.cleanField.bind(this),
            displayValue: this.setValue.bind(this),
            validator: this.validator.bind(this),
            validationEvent: this.validationEvent
        });
    };

    Component.prototype.setValue = function (event, value) {
        this.$input.val(value).change();
    };

    Component.prototype.cleanField = function () {
        this.$input.val('').trigger('change', { withoutValidation: true });
        if (this.showCity) {
            this.city.toggle();
        }
    };

    Component.prototype.toggleError = function (error) {
        this.$column.toggleClass(FormControl.classes.fieldError, !!error);
        this.$errorText.text(error || '');
        this.$errorTooltip.find('.is-a11y-only').toggleClass('hidden', !error);
    };

    Component.prototype.validator = function () {
        var result = [];
        if (this.requiredType !== 'notRequired' && !this.$input.val()) {
            result.push(this.requiredMsg);
        }
        return result;
    };

    Component.prototype.validationEvent = 'change blur select2:blur';
    Component.prototype.classes = $.extend({}, FormControl.prototype.classes, classes);

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('LinkedInSummary', ['form', 'form-control', 'LinkedInSummaryPopup', 'linkedInSummaryParser', 'utils'], function (form, FormControl, SummaryPopup, summaryParser, utils) {
    'use strict';

    var $body = $('body');

    var CLASSES = {
        N & DS_CONTINUUM_STYLE: 'epam-continuum-style',
        LABEL: 'form-component__label',
        FAKE_PLACEHOLDER: 'fake-placeholder',
        HIDDEN: 'hidden',
        STANDALONE: 'form-component--standalone',
        BUTTON_LINK: '.linkedin-summary__button-link',
        EDIT_POPUP: '.linkedin-summary-popup-ui',
        TEXT_AREA_FIELD: '.linkedin-summary__input',
    };

    var EVENTS = {
        openPopup: 'summary.popup.open'
    };

    function Component($el) {
        this.$el = $el;
        FormControl.call(this, $el);
        /*
        exclude hidden linkedin summary textarea filed
         */
        this.$input = this.$el.find('textarea:not(.linkedin-summary__input)');
        this.registerField();

        this.isEpamContinuumStyle = !!this.$el.parents('.' + CLASSES.N & DS_CONTINUUM_STYLE).length;
        this.isStandalone = !!this.$el.parents('.' + CLASSES.STANDALONE).length;

        if (this.isEpamContinuumStyle && this.$input.attr('placeholder') && !this.isGoogleChrome()) {
            this.$label = this.$el.find('.' + CLASSES.LABEL);
            this.createFakePlaceholder();
            this.removeRealPlaceholder();
            this.addEventListener(this.fakePlaceholder);
            this.triggerEvent();
        }

        var formComponent = this.$el.closest('.form-constructor-ui');
        this.$isStandAloneForm = formComponent.hasClass('form-component--standalone');
        this.$buttonLink = this.$el.find(CLASSES.BUTTON_LINK);
        this.$editPopup = this.$el.find(CLASSES.EDIT_POPUP);
        this.$textAreaInput = this.$el.find(CLASSES.TEXT_AREA_FIELD);
        new SummaryPopup(this.$editPopup, this.$textAreaInput);
        this.init();
    }

    Component.prototype = Object.create(FormControl.prototype);

    Component.prototype.init = function () {
        this.initEvents();
        if (!this.$isStandAloneForm) {
            this.$textAreaInput.attr('readonly', true);
        }

        this.setOverlayScrollbar();
    };

    Component.prototype.setOverlayScrollbar = function () {
        var isRedesign23 = $body.hasClass('dark-mode') || $body.hasClass('light-mode');
        if (isRedesign23) {
            OverlayScrollbars(this.$input, { className: 'os-theme-dark'});
        }
    };

    Component.prototype.initEvents = function () {
        this.$buttonLink.on('click', this.onButtonLinkHandler.bind(this));
        $(window).on('linkedin.data.received', this.linkedinDataReceivedEventHandler.bind(this));
        $(window).resize(utils.debounce(this.resizeEventHandler.bind(this), 250));
    };

    Component.prototype.resizeEventHandler = function () {
        if (this.isStandalone) {
            if (window.matchMedia('(max-width: 991px)').matches) {
                this.$textAreaInput.attr('readonly', true);
            } else {
                this.$textAreaInput.attr('readonly', false);
            }
        }
    };

    Component.prototype.linkedinDataReceivedEventHandler = function (event, data) {
        var parsedSummaryData = summaryParser.formattingLinkedinSummary(data.linkedinData);
        this.$textAreaInput.val(parsedSummaryData);
    };

    Component.prototype.onButtonLinkHandler = function () {
        this.$editPopup.trigger(EVENTS.openPopup);
        this.$editPopup.removeClass(CLASSES.HIDDEN);
    };

    Component.prototype.cleanFieldOverride = function () {
        var textarea = $('textarea.linkedin-summary__input');
        var summaryFieldHtmlMarkUp = $('.linkedin-summary-ui');
        textarea.val('');
        summaryFieldHtmlMarkUp.addClass('hidden');
    };

    Component.prototype.registerField = function () {
        form.registerField({
            form: this.$form,
            field: this.$input.attr('name'),
            cleanField: this.cleanFieldOverride,
            displayValue: this.displayValue.bind(this),
            cleanError: this.toggleError.bind(this),
            displayError: this.toggleError.bind(this),
            validator: form.requiredValidator(this.$input, this.context),
            validationEvent: this.validationEvents
        });
    };

    Component.prototype.isGoogleChrome = function() {
        return window.navigator.userAgent.indexOf('Chrome') !== -1;
    };

    Component.prototype.createFakePlaceholder = function() {
        let placeholderText = this.$input.attr('placeholder');
        this.fakePlaceholder = $('<span>' + placeholderText + '</span>');
        this.fakePlaceholder.addClass(CLASSES.FAKE_PLACEHOLDER);
        this.calcPaddingBottom();
        this.setFakePlaceholderHeight();
        this.fakePlaceholder.appendTo(this.$el);
    };

    Component.prototype.calcPaddingBottom = function() {
        this.paddingBottom = this.isStandalone ? 6.7 : 6.1;
    };

    Component.prototype.setFakePlaceholderHeight = function() {
        this.fakePlaceholder.css('bottom', this.pixelsToRems(this.$label.height()) + this.paddingBottom + 'rem');
    };

    Component.prototype.pixelsToRems = function(valueInPixels) {
        return valueInPixels / 10;
    };

    Component.prototype.removeRealPlaceholder = function() {
        this.$input.removeAttr('placeholder');
    };

    Component.prototype.addEventListener = function($fakePlaceholder) {
        this.$input.on('input keydown', function() {
            $(this).val()
                ? $fakePlaceholder.addClass(CLASSES.HIDDEN)
                : $fakePlaceholder.removeClass(CLASSES.HIDDEN);
        });
    };

    Component.prototype.triggerEvent = function() {
        var event = jQuery.Event('keydown');
        this.$input.trigger(event);
    };

    Component.prototype.validationEvents = 'blur';

    Component.moduleName = 'LinkedInSummary';
    Component.selector = '.linkedin-summary-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('LinkedInSummaryPopup', [], function () {
    'use strict';

    var $body = $('body');

    var CLASSES = {
        CLOSE_BUTTON: '.linkedin-summary-close-button',
        SAVE_BUTTON: '.linkedin-summary__button-save',
        CANCEL_BUTTON: '.linkedin-summary__button-cancel',
        HIDDEN: 'hidden',
        SUMMARY_INPUT: 'linkedin-summary__input',
        EDIT_TEXTAREA: '.linkedin-summary__textarea',
        WARNING_POPUP: '.linkedin-summary-warning-popup',
        BUTTON_NO: '.linkedin-summary__warning-button-no',
        BUTTON_YES: '.linkedin-summary__warning-button-yes',
    };

    function Component($el, $textAreaInput) {
        this.$el = $el;
        this.$textAreaInput = $textAreaInput;
        this.$closeButton = $el.find(CLASSES.CLOSE_BUTTON);
        this.$cancelButton = $el.find(CLASSES.CANCEL_BUTTON);
        this.$saveButton = $el.find(CLASSES.SAVE_BUTTON);
        this.$editTextArea = $el.find(CLASSES.EDIT_TEXTAREA);
        this.$warningPopup = $el.find(CLASSES.WARNING_POPUP);
        this.$buttonNo = $el.find(CLASSES.BUTTON_NO);
        this.$buttonYes = $el.find(CLASSES.BUTTON_YES);
        this.hasChanged = false;

        this.init();
    }

    Component.prototype.init = function () {
        this.initEvents();
        this.setOverlayScrollbar();
    };

    Component.prototype.setOverlayScrollbar = function () {
        var isRedesign23 = $body.hasClass('dark-mode') || $body.hasClass('light-mode');

        if (isRedesign23) {
            OverlayScrollbars(this.$textAreaInput, { className: 'os-theme-dark'});
        }
    };

    Component.prototype.initEvents = function () {
        this.$closeButton.on('click', this.onCloseButtonClick.bind(this));
        this.$cancelButton.on('click', this.onCloseButtonClick.bind(this));
        this.$el.on('summary.popup.open', this.summaryPopupOpenEventHandler.bind(this));
        this.$editTextArea.on('keyup', this.onKeyPress.bind(this));
        this.$buttonNo.on('click', this.onButtonNoClick.bind(this));
        this.$buttonYes.on('click', this.onButtonYesClick.bind(this));
        this.$saveButton.on('click', this.onSaveButtonClick.bind(this));
    };

    Component.prototype.onSaveButtonClick = function (event) {
        event.preventDefault();
        var modifiedSummary = this.$editTextArea.val();
        this.$textAreaInput.val(modifiedSummary);
        this.hasChanged = false;
        this.$el.addClass(CLASSES.HIDDEN);
    };

    Component.prototype.onButtonNoClick = function (event) {
        event.preventDefault();
        this.$warningPopup.addClass(CLASSES.HIDDEN);
    };

    Component.prototype.onButtonYesClick = function (event) {
        event.preventDefault();
        this.$warningPopup.addClass(CLASSES.HIDDEN);
        this.$el.addClass(CLASSES.HIDDEN);
        this.hasChanged = false;
    };

    Component.prototype.onKeyPress = function () {
        this.hasChanged = true;
    };

    Component.prototype.onCloseButtonClick = function (event) {
        event.preventDefault();
        if (this.hasChanged) {
            this.$warningPopup.removeClass(CLASSES.HIDDEN);
        } else {
            this.$el.addClass(CLASSES.HIDDEN);
            this.hasChanged = false;
        }
    };

    Component.prototype.summaryPopupOpenEventHandler = function () {
        var textAreaInput = this.$textAreaInput.val();
        this.$editTextArea.val(textAreaInput);
    };

    Component.moduleName = 'LinkedInSummaryPopup';
    Component.selector = '.linkedin-summary-popup-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('HiddenField', [], function() {
  'use strict';

  var CONSTANTS = {
    mode : 'data-value-mode',
    cookieName: 'data-value-cookie-name',
    clientIdCookie: '_ga',
    contextHubPersistence: 'ContextHubPersistence',
    contextHubKey: 'data-context-hub-key',
    contextHubRoot: 'store.',
  };

  function Component($el) {
    this.$el = $el;
    this.$firstRun = true;
    this.$mode = this.$el.attr(CONSTANTS.mode);
    this.containingForm = $el.closest('form');

    this.init();
  }

  Component.prototype.init = function() {
    if (this.$mode === 'cookie') {
      this.setUpCookie();
    } else if (this.$mode === 'contextHub' && this.containingForm.length) {
        this.containingForm.on('AJAX_START', this.updateFieldByContextHub.bind(this));
    }
  };

  Component.prototype.setUpCookie = function() {
    var cookieName = this.$el.attr(CONSTANTS.cookieName);
    var reg = new RegExp(cookieName + '=(.*)');
    var cookie = document.cookie.split(';');
    var filteredCookie = [];

    $.each(cookie, function(index, item) {
      var group = item.match(reg);

      if (group) {
        filteredCookie.push(group[1]);
      }
    });

    this.$el.val(Array.prototype.join.call(filteredCookie, ','));

    /**
     * production has issue when in some cases cookie inaccessible,
     * in this case repeat action after 5sec
     */
    if (cookieName === CONSTANTS.clientIdCookie && !this.$el.val().length && this.$firstRun) {
      setTimeout(function () {
        this.$firstRun = false;
        this.setUpCookie();
      }.bind(this), 5000);
    }
  };

  Component.prototype.updateFieldByContextHub = function() {
    var contextHubKey = this.$el.attr(CONSTANTS.contextHubKey);
    var contextHubJson = window.localStorage.getItem(CONSTANTS.contextHubPersistence);
    if (!contextHubKey || !contextHubJson) {
      return;
    }
    contextHubKey = contextHubKey.startsWith(CONSTANTS.contextHubRoot) ? contextHubKey : CONSTANTS.contextHubRoot + contextHubKey;
    try {
      var store = JSON.parse(contextHubJson);
      var value = contextHubKey.split('.').reduce(
        function (accumulator, key) {
          return accumulator[key];
        }, store
      );
      if (value) {
        this.$el.val(value);
      }
    } catch (e) {
      console.error(e);
    }
  };

  Component.moduleName = 'Hidden Field';
  Component.selector = '.hidden-field-ui';

  return Component;
});
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
/* eslint-disable max-params */
define('GatedForm', ['form', 'utils', 'utils-browser', 'analytics', 'constants', 'gradients'], function (form, utils, browser, analytics, constants, gradients) {
    'use strict';
/* eslint-enable max-params */
    var isIE = browser.isInternetExplorer();
    var $body = $(document.body);

    function Component($el) {
        this.$el = $el;
        this.$continuumStyle = this.$el.hasClass('epam-continuum-style');
        this.checkPageStyle();
        this.$form = this.$el.find('form');
        this.$email = this.$form.find('input[name="email"]');
        this.$originalEmail = this.$form.find('input[name=":originalEmail"]');
        this.$cancelLink = this.$el.find('.' + this.classes.cancelLink);
        this.$downloadButton = this.$el.find('.' + this.classes.downloadButton);
        this.$downloadLink = this.$el.find('.' + this.classes.downloadLink);
        this.$callToActionButton = this.$el.find('.' + this.classes.callToAction);
        this.validationCode = utils.getQueryParameters(window.location.href).validationCode;
        this.expanded = this.$el.data('expanded');
        this.formPath = this.$el.data('form-path');
        this.filePath = this.$downloadButton.attr('href');

        this.$cancelLink.on('click', this.collapseForm.bind(this));
        this.$callToActionButton.on('click', this.expandForm.bind(this));

        this.$downloadLink.on('click', this.sendPath.bind(this));
        this.$downloadButton.on('click', function() {
            this.sendPath();
            this.sendDownloadEvent();
        }.bind(this));

        this.initSubmitAgainLink();
        this.initFormComponent();
        this.addArrow();
        // after first form submit there is no need to apply gradients again
        this.isSubmittedOnce = false;

        if ($.cookie('gated-recognition') || this.validationCode && $.cookie('gated-validation')) {
            this.loadUserData();
        } else if (this.validationCode) {
            this.displayFailedConfirmation();
        }
    }

    /*
    old style and new style. new style including themes
     */
    Component.prototype.checkPageStyle = function () {
        if ($body.hasClass('dark-mode') || $body.hasClass('light-mode') || $body.hasClass('ec-mode')) {
            this.classes.submitAgain = 'submit-again-redesign';
        }
    };

    Component.prototype.collapseForm = function () {
        if (this.expanded) {
            return false;
        }
        this.$el.removeClass(this.classes.expandedForm + ' ' + this.classes.forceDownload);
        this.formComponent.cleanForm();
        this.$el.trigger(constants.Events.gatedFormCollapse);
        this.$el.scrollToSelector({ reservedSpace: 100 });
        return false;
    };

    Component.prototype.expandForm = function () {
        this.$el.addClass(this.classes.expandedForm);
        this.$el.trigger(constants.Events.gatedFormExpanded);
        return false;
    };

    Component.prototype.initSubmitAgainLink = function () {
        var $emailUpdateLink = this.$el.find('.' + this.classes.emailUpdate + ' .' + this.classes.submitAgain),
            $infoUpdateLink = this.$el.find('.' + this.classes.infoUpdate + ' .' + this.classes.submitAgain),
            $failedConfirmationLink = this.$el.find('.' + this.classes.failedConfirmation + ' .' + this.classes.submitAgain);

        $emailUpdateLink.on('click', this.hideMessage.bind(this, this.classes.emailUpdateState));
        $infoUpdateLink.on('click', this.hideMessage.bind(this, this.classes.infoUpdateState));
        $failedConfirmationLink.on('click', this.hideMessage.bind(this, this.classes.failedConfirmationState));
    };

    Component.prototype.hideMessage = function (messageClass) {
        this.$el.removeClass(messageClass);
        this.formComponent.activateForm();
        return false;
    };

    Component.prototype.initFormComponent = function () {
        this.formComponent = new form.FormComponent(this.$el, this.$continuumStyle);
        $.extend(this.formComponent, {
            baseSubmitForm: this.formComponent.submitForm,
            displaySuccessMessage: this.displaySuccessMessage.bind(this),
            submitForm: this.submitForm.bind(this),
            cleanForm: this.cleanForm.bind(this)
        });

        this.formComponent.initialize();
        this.formComponent.onSuccessfulSubmit = this.onSuccessfulSubmit.bind(this);
        this.downloadGtmEventData = this.collectDownloadGtmEventData();
    };

    Component.prototype.displaySuccessMessage = function () {
        var messageClass = this.classes.successState;
        if (this.userEmail) {
            var isSameEmail = this.equalsIgnoreCase(this.userEmail, this.$email.val());
            messageClass =  isSameEmail ? this.classes.infoUpdateState : this.classes.emailUpdateState;
        }
        this.$el.addClass(messageClass);
        this.$el.trigger('form.showMessage');
        this.formComponent.cleanForm();
        this.syncUserData();
    };

    Component.prototype.collectDownloadGtmEventData = function() {
        return this.formComponent.gtmEventData && $.extend({}, this.formComponent.gtmEventData, {
            eventAction: 'download'
        });
    };

    Component.prototype.sendDownloadEvent = function() {
        analytics.push(this.downloadGtmEventData);
    };

    Component.prototype.sendPath = function() {
        $.ajax({
            url: '/services/interaction/notification/download/asset',
            type: 'POST',
            data: {
                formPath: this.formPath,
                filePath: this.filePath
            }
        });
    };

    Component.prototype.equalsIgnoreCase = function (first, second) {
        return first.toLowerCase() === second.toLowerCase();
    };

    Component.prototype.cleanForm = function () {
        if (this.userData) {
            this.$form.trigger(form.events.CLEAN_UP, {mandatoryOnly: true});
        } else {
            this.$form.trigger(form.events.CLEAN_UP);
        }
    };

    Component.prototype.syncUserData = function () {
        if (!this.userData) {
            return;
        }

        $.each(this.$form.find(':not(input[type=hidden])').serializeArray(), this.updateUserProperty.bind(this));
    };

    Component.prototype.updateUserProperty = function (index, field) {
        if (!this.shouldIgnoreField(field.name)) {
            this.userData[field.name] = field.value;
        }
    };

    Component.prototype.submitForm = function () {
        if (this.isUserDataChanged()) {
            this.formComponent.baseSubmitForm();
            this.$el.removeClass(this.classes.forceDownload);
        } else {
            this.sendDownloadEvent();
            window.location = this.$downloadButton.attr('href');
            this.formComponent.activateForm();
            return false;
        }
    };

    Component.prototype.isUserDataChanged = function () {
        if (!this.userData) {
            return true;
        }

        return $.grep(this.$form.find(':not(input[type=hidden])').serializeArray(), this.isUserPropertyChanged.bind(this)).length > 0;
    };

    Component.prototype.isUserPropertyChanged = function (field) {
        return !this.shouldIgnoreField(field.name) && this.isFieldChanged(field);
    };

    Component.prototype.shouldIgnoreField = function (fieldName) {
        return fieldName.indexOf(':') === 0 || this.constants.IGNORED_FIELDS.indexOf(fieldName) >= 0;
    };

    Component.prototype.isFieldChanged  = function (field) {
        var isNewField = typeof this.userData[field.name] === 'undefined';
        if (isNewField && field.value.length === 0) {
            return false;
        }
        return isNewField || !this.equalsIgnoreCase(this.userData[field.name], field.value);
    };

    Component.prototype.loadUserData = function () {
        $.ajax({
            url: '/services/interaction/gated-form/user-data',
            type: 'GET',
            data: {validationCode: this.validationCode},
            cache: false,
            success: this.onSuccessfulDataLoaded.bind(this),
            error: this.onErrorDataLoaded.bind(this)
        });
    };

    Component.prototype.onSuccessfulDataLoaded = function (response) {
        if (!$.isEmptyObject(response) && response.formData) {
            this.userData = response.formData;
            this.displayUserData(response);
        }
    };

    Component.prototype.displayUserData = function (response) {
        var expandedFormClasses = this.classes.expandedForm + ' ' + this.classes.validatedForm;

        this.userEmail = response.formData.email;
        this.$originalEmail.val(response.originalEmail);

        $.each(response.formData, this.displayFieldValue.bind(this));

        if (response.gatedContentPath) {
            this.sendDownloadEvent();
            expandedFormClasses += ' ' + this.classes.forceDownload;
            if (isIE === 11) {
                this.setWindowLocation(response.gatedContentPath);
            }
            this.setWindowLocation(response.gatedContentPath);
            this.reCheckLinkedinAutofillForm();
        }
        this.$el.addClass(expandedFormClasses);
    };

    Component.prototype.addArrow = function () {
        var buttons = this.$el.find(this.classes.submitAgainButton);

        for (var i = 0; i < buttons.length; i++) {
            utils.insertArrowPicture($(buttons[i]));
        }
    };
    /**
     * in case the link is used to download .pdf file
     * load event inside linkedin script doesn't trigger.
      */
    Component.prototype.reCheckLinkedinAutofillForm = function () {
        var isIframeAdded = document.querySelector('.IN-widget');
        var inFormScript = document.querySelector('script[type="IN/Form2"]');
        if (!isIframeAdded && inFormScript) {
            dispatchEvent(new Event('load'));
        }
    };

    Component.prototype.setWindowLocation = function (gatedContentPath) {
        window.location = gatedContentPath;
    };

    Component.prototype.displayFieldValue = function (field, value) {
        this.$form.trigger(form.events.DISPLAY_VALUE + ':' + field, value);
    };

    Component.prototype.onErrorDataLoaded = function (response) {
        if (response.status === 400) {
            this.displayFailedConfirmation();
        }
    };

    Component.prototype.displayFailedConfirmation = function () {
        this.$el.addClass(this.classes.expandedForm + ' ' + this.classes.failedConfirmationState);
        this.$el.trigger('form.showMessage');
    };

    Component.prototype.onSuccessfulSubmit = function () {
        if (this.isSubmittedOnce) {
          return;
        }
        this.isSubmittedOnce = true;
        var nodes = this.$el[0].querySelectorAll(this.classes.multilineGradient);
        var gradientText = new gradients.GradientText();
        var N & DS_RIGHT_RATIO = 0.5;
        var N & DS_MIDDLE_RATIO = 1.4;
        gradientText.init(nodes, {rightRatio: N & DS_RIGHT_RATIO, middleRatio: N & DS_MIDDLE_RATIO});
    };

    Component.prototype.constants = {
        IGNORED_FIELDS: ['captcha']
    };

    Component.prototype.classes = {
        callToAction: 'gated-form__call-to-action-button',
        cancelLink: 'cancel-link',
        emailUpdate: 'gated-form__email-update',
        infoUpdate: 'gated-form__info-update',
        failedConfirmation: 'gated-form__unsuccessful-confirmation',
        submitAgain: 'submit-again',
        downloadButton: 'gated-form__download-button-link',
        downloadLink: 'gated-form__download-link',
        expandedForm : 'gated-form--expanded',
        validatedForm: 'gated-form--validated',
        successState: 'show-success',
        emailUpdateState: 'show-email-update',
        infoUpdateState: 'show-info-update',
        failedConfirmationState: 'show-unsuccessful-confirmation',
        forceDownload: 'force-download',
        submitAgainButton: '.submit-again-arrow-container',
        multilineGradient: '.multiline-gradient',
    };

    Component.moduleName = 'Gated Form';
    Component.selector = '.gated-form-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define('FormConstructor', ['form', 'constants', 'utils', 'gradients'], function (form, constants, utils, gradients) {
    'use strict';

    var $html = $('html');
    var $overlay = $('.' + constants.Classes.overlay);
    var JOB_INDEPENDENT_FORM_TYPE = 'epam-com/components/form/action/apply-for-job-independent';
    var formType = null;

    function Component($el) {
        this.$el = $el;
        this.$selfIdLink = this.$el.find('.' + this.classes.selfIdLink);
        this.$selfIdPopup = this.$el.find('.' + this.classes.selfIdPopup);
        this.$popupCloseTargets = this.$el.find('.' + this.classes.popupCloseButton).add(this.$overlay);
        this.$continuumStyle = this.$el.hasClass('epam-continuum-style');
        // after first form submit there is no need to apply gradients again
        this.isSubmittedOnce = false;

        this.formComponent = new form.FormComponent(this.$el, this.$continuumStyle);

        if (this.$selfIdLink.length) {
            this.$selfIdLink.on('click', function () {
                if (formType !== JOB_INDEPENDENT_FORM_TYPE) {
                    this.togglePopup(false);
                }
            }.bind(this));
            this.$popupCloseTargets.on('click', this.togglePopup.bind(this, false));
            this.selfIdFormPath = this.$selfIdLink.attr('href');
            this.formComponent.onSuccessfulSubmit = this.onSuccessfulSubmit.bind(this);
        } else {
            this.formComponent.onSuccessfulSubmit = this.applySuccessMessageGradient.bind(this);
        }
        this.formComponent.initialize();
        this.addArrow();
    }

    /*
    add arrow to 'submit again' buttons
     */
    Component.prototype.addArrow = function () {
        var buttons = this.$el.find(this.classes.submitAgainButton);

        for (var i = 0; i < buttons.length; i++) {
            utils.insertArrowPicture($(buttons[i]));
        }
    };

    Component.prototype.onSuccessfulSubmit = function (response) {
        formType = response.formType;
        this.updateSelfIdLink(response);
        if (formType === JOB_INDEPENDENT_FORM_TYPE) {
          if (response.isTwoStepCountry) {
            this.$el.find(this.classes.twoStepsSuccessMessage).removeClass('hidden');
            this.togglePopup(true);
          } else {
            this.$el.find(this.classes.singleStepSuccessMessage).removeClass('hidden');
          }
        } else {
            this.$el.find(this.classes.twoStepsSuccessMessage).removeClass('hidden');
            this.togglePopup(true);
        }

        this.applySuccessMessageGradient();
    };

    Component.prototype.updateSelfIdLink = function (response) {
        if (response.vacancyId !== undefined) {
            this.$selfIdLink.attr('href', this.selfIdFormPath + '?submitId=' + response.submitId  + '&vacancyId=' + response.vacancyId);
        } else {
            this.$selfIdLink.attr('href', this.selfIdFormPath + '?submitId=' + response.submitId);
        }
    };

    Component.prototype.togglePopup = function (show) {
        $html.toggleClass(constants.Classes.noscroll, show);
        this.$selfIdPopup.toggleClass(constants.Classes.hidden, !show);
        $overlay.toggleClass(constants.Classes.hidden, !show).toggleClass(constants.Classes.overlayCoverHeader, show);
    };

    Component.prototype.applySuccessMessageGradient = function () {
        if (this.isSubmittedOnce) {
            return;
          }
          this.isSubmittedOnce = true;
          var nodes = this.$el[0].querySelectorAll(this.classes.multilineGradient);
          if (nodes.length > 0) {
            var gradientText = new gradients.GradientText();
            var N & DS_RIGHT_RATIO = 0.5;
            var N & DS_MIDDLE_RATIO = 1.4;
            gradientText.init(nodes, {rightRatio: N & DS_RIGHT_RATIO, middleRatio: N & DS_MIDDLE_RATIO});
          }
    };

    Component.prototype.classes = {
        selfIdLink: 'form-component__self-id-link',
        selfIdPopup: 'popup--self-id',
        popupCloseButton: 'form-component__popup-close',
        twoStepsSuccessMessage: '.form-component__two-steps-success-message',
        singleStepSuccessMessage: '.form-component__single-steps-success-message',
        submitAgainButton: '.submit-again-arrow-container',
        multilineGradient: '.multiline-gradient',
    };

    Component.moduleName = 'Form Constructor';
    Component.selector = '.form-constructor-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('FileUpload', ['form', 'form-control', 'utils-browser', 'utils'], function (form, FormControl, browser, utils) {
    'use strict';

    var DEFAULT_MAX_SIZE = 10 * 1024 * 1024,
        DEFAULT_ALLOWED_EXTENSIONS = [
            'docx', 'txt', 'pdf', 'xlsx'
        ];

    function Component($el) {
        FormControl.call(this, $el);
        this.$input = this.$el.find('.' + this.classes.input);
        this.field = this.$input.attr('name');
        this.$hasRedesign23Style = $(document.body).hasClass('dark-mode') || $(document.body).hasClass('light-mode');

        if (this.isStandard()) {
            this.$path = this.$el.find('.' + this.classes.path);
            this.defaultPathValue = this.$path.val();
        } else {
            this.$filename = this.$el.find('.' + this.classes.filename);
            this.$remove = this.$el.find('.' + this.classes.removeFile);
            this.$remove.on('click', this.cleanField.bind(this, false));
        }

        this.context = this.initValidationContext();
        this.registerField();
        this.$input.on('change', this.uploadDone.bind(this));
        this.$el.toggleClass(this.classes.standardField, this.isStandard());
    }

    Component.prototype = Object.create(FormControl.prototype);

    Component.prototype.uploadDone = function () {
        var filename = this.$input.get(0).files[0].name;

        this.toggleUploadState(true);

        if (this.isStandard()) {
            this.$path.val(filename);
        } else {
            this.$filename.text(filename);
        }
    };

    Component.prototype.toggleUploadState = function (isUploadDone) {
        this.$el.toggleClass(this.classes.uploadDone, isUploadDone);
    };

    Component.prototype.registerField = function () {
        form.registerField({
            form: this.$form,
            field: this.field,
            cleanError: this.toggleError.bind(this),
            cleanField: this.extendedCleanField.bind(this),
            displayError: this.toggleError.bind(this),
            validator: this.fileValidator.bind(this),
            validationEvent: this.validationEvents
        });
    };

    Component.prototype.extendedCleanField = function () {
        this.cleanField();
        if (this.isStandard()) {
            this.$path.val(this.defaultPathValue);
        }
    };

    Component.prototype.afterClean = function () {
        this.toggleUploadState(false);
    };

    Component.prototype.fileValidator = function () {
        var result = [];

        var value = this.$input.val();

        if (value && !result.length) {
            var extension = value.match(/\.(\w+$)/)[1];
            if (!this.isAllowedExtension(extension) || !this.isAllowedSize()) {
                result.push(this.context.constraintMsg);
            }
        }

        if (utils.hasTouchEvents()) {
            return result;
        }

        if (this.context.isRequired && !value) {
            result.push(this.context.requiredMsg);
        }

        return result;
    };

    Component.prototype.initValidationContext = function () {
        var context = form.extractValidationContext(this.$el),
            maxSize = this.$el.data('maxSize'),
            allowedExtensions = this.$el.data('allowedExtensions');

        context.maxSize = isNaN(maxSize) ? DEFAULT_MAX_SIZE : maxSize * 1024 * 1024;

        if (!allowedExtensions) {
            context.allowedExtensions = DEFAULT_ALLOWED_EXTENSIONS;
        } else {
            context.allowedExtensions = allowedExtensions.toLowerCase().split(',');
        }

        return context;
    };

    Component.prototype.isAllowedExtension = function (extension) {
        if (!extension) {
            return false;
        }
        return this.context.allowedExtensions.indexOf(extension.toLowerCase()) !== -1;
    };

    Component.prototype.isAllowedSize = function () {
        var uploadFiles = this.$input[0].files;
        return !uploadFiles || uploadFiles[0].size <= this.context.maxSize;
    };

    Component.prototype.isStandard = function () {
        return browser.isInternetExplorer() || utils.hasTouchEvents() && !this.$hasRedesign23Style;
    };

    Component.prototype.validationEvents = 'change';
    Component.prototype.classes = $.extend({}, FormControl.prototype.classes, {
        removeFile: 'file-upload__remove',
        standardField: 'file-upload--standard',
        uploadDone: 'file-upload--done',
        path: 'file-upload__path',
        filename: 'file-upload__filename',
        input: 'file-upload__input',
        field: 'file-upload__field',
        redesign23Style: '.epam-redesign-23-style',
    });

    Component.moduleName = 'File Upload';
    Component.selector = '.file-upload-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('DropdownList', ['form', 'form-control', 'AdditionalField', 'constants', 'multi-select'], function(form, FormControl, AdditionalField, constants) {
    'use strict';

    var $body = $('body');

    function Component($el) {
        FormControl.call(this, $el);
        this.$select = this.$el.find('.' + this.classes.select);
        this.multiple = this.$select.prop('multiple');
        this.defaultValues = (this.$select.data('defaultValues') || '').toString();
        this.defaultValues = this.multiple ? this.defaultValues.split(',') : this.defaultValues;
        this.id = this.$select.attr('id');
        this.errorId = this.id + '-error';
        this.$selectedPlaceholder = this.$el.find(this.classes.selectedPlaceholder);
        this.$additionalFieldHolder = this.$el.parent().find(this.classes.additionalFieldHolder);
        var additionalField = new AdditionalField(this.$additionalFieldHolder);
        this.validations = { isRequired: this.$el.data('required') };
        this.$el.on('setValidation', function(event, param) {
            this.validations.isRequired = param.isRequired;
        }.bind(this));
        this.isEpamContinuumStyle = this.$el.parents('.epam-continuum-style').length > 0;
        this.initSelect();
        this.registerField();
        additionalField.initAdditionalField();
        var currentTriggerEvent = this.getCurrentOptionTriggerEvent();
        if (currentTriggerEvent) {
            this.updateLabelsByEvent(currentTriggerEvent);
        }
        this.overlayScrollbarInstance = null;
        this.name = this.$select.attr('name');
        $body.on('select-location:dropdown-change', this.handleExperienceNoticeDropdown.bind(this));
    }

    Component.prototype = Object.create(FormControl.prototype);

    Component.prototype.toggleErrorContinuumStyle = function(error) {
        var hasError = !!error;

        this.$el.toggleClass(FormControl.classes.fieldError, hasError);
        this.$input.attr('aria-invalid', hasError);
        this.$errorTooltip.find('.is-a11y-only').toggleClass('hidden', !hasError);
        this.$errorText.text(error || '');
        if (!error) {
            this.$errorText.text(this.$errorText.attr('data-title'));
        }
    };

    Component.prototype.escapeRegExp = function(input) {
        var source = typeof input === 'string' || input instanceof String ? input : '';
        return source.replace(/[-[/\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    };

    Component.prototype.customSearchMatcher = function(params, data) {
        if ($.trim(params.term) === '') {
            return data;
        }

        var term = this.escapeRegExp(params.term);
        if (term.match(/[/#+-.&\\]/)) {
            var regExp1 = new RegExp(term, 'i');
            if (data.text.match(regExp1)) {
                return data;
            }
        }

        var regExp2 = new RegExp('^' + term, 'i');
        var arr = data.text.split(/[\s.&\(/]+/);
        for (var i = 0; i < arr.length; i++) {
            if (arr[i].match(regExp2) !== null) {
                return data;
            }
        }
        return null;
    };

    /*
    override method (abstract-location-field)
     */
    Component.prototype.optionalValidator = function($select, context) {
        var requiredValidator = form.requiredValidator($select, context);

        return function() {
            if (this.validations.isRequired) {
                return requiredValidator();
            }
            return [];
        }.bind(this);
    };

    Component.prototype.registerField = function() {
        form.registerField({
            form: this.$form,
            field: this.$select.attr('name'),
            displayValue: this.setValue.bind(this),
            cleanField: this.setValue.bind(this),
            cleanError: this.toggleError.bind(this),
            displayError: this.toggleError.bind(this),
            validator: this.optionalValidator(this.$select, this.context),
            validationEvent: this.validationEvents
        });
    };

    Component.prototype.setValue = function(event, value) {
        this.$select.val(value || this.defaultValues);
        this.hideAdditionalField();
        this.multiple ? this.$select.trigger('synchronize') : this.$select.trigger('change', { withoutValidation: true });
        this.toggleError();
    };

    Component.prototype.hideAdditionalField = function() {
        this.$additionalFieldHolder.addClass(constants.Classes.hidden);
    };

    Component.prototype.sanitizeInput = function(input) {
        return typeof input === 'string' ? input.replace(/[^a-zA-Z0-9-_]/g, '') : input;
    };

    Component.prototype.getCurrentOptionTriggerEvent = function() {
        var dataTriggerEvent = this.$select.find('option:selected').attr('data-trigger-event');
        return this.sanitizeInput(dataTriggerEvent);
    };

    Component.prototype.updateLabelsByEvent = function(dataTriggerEvent) {
        $('[data-show-for-event]').addClass('hidden');
        $('input').toArray().forEach(function(input) {
            var inputId = CSS.escape($(input).attr('id'));
            var labelsOfInput = $('[data-show-for-event~="' + dataTriggerEvent + '"][for=' + inputId + ']');
            if (labelsOfInput.length) {
                labelsOfInput.removeClass('hidden');
            } else {
                $('label[for=' + inputId + '][data-show-for-event="default"]').removeClass('hidden');
            }
        });
        $('input').prop('checked', false);
    };

    Component.prototype.initSelect = function() {
        var required = this.$el.data('required');
        var self = this;

        this.$select
            .change(function() {
                var currentTriggerEvent = self.getCurrentOptionTriggerEvent();
                if (currentTriggerEvent) {
                    self.updateLabelsByEvent(currentTriggerEvent);
                }
            });

        if (this.multiple) {
            this.$select.multiSelectFilter({
                required: required,
                labelId: this.id + '-label',
                errorId: this.errorId,
                onOpen: this.openDropdownScrollbar.bind(this),
                onClose: this.destroyDropdownScrollbar.bind(this)
            });
            this.$input = this.$el.find('.multi-select-filter');
            this.setOverlayScrollbar();
            return;
        }

        this.$select.selectWoo({
            dropdownParent: this.$el.find('.' + this.classes.parent),
            width: 'off',
            placeholderOption: 'first',
            matcher: this.customSearchMatcher.bind(this)
        });

        this.$selectBoxContainer = this.$el.find(this.classes.selectBoxContainer);
        this.$selectBoxContainer.addClass(this.classes.formComponentField);

        this.$input = this.$el.find('.' + this.classes.visibleInput);
        this.$input.addClass(FormControl.classes.focusTarget)
            .attr('aria-describedby', this.errorId)
            .attr('aria-labelledby', this.id + '-label select2-' + this.id + '-container');

        this.$input.on('blur', function() {
            this.$select.trigger('select2:blur');
        }.bind(this));

        this.$select.on('select2:selecting', function(event) {
            this.$selectedPlaceholder.text(event.params.args.data.text);
        }.bind(this));

        this.setOverlayScrollbar();
    };

    /**
     * OverlayScrollbar functionality
     */
    Component.prototype.setOverlayScrollbar = function() {
        var isRedesign23 = $body.hasClass('dark-mode') || $body.hasClass('light-mode');

        if (isRedesign23) {
            this.$select.on('select2:open', this.openDropdownScrollbar.bind(this));
            this.$select.on('select2:closing', this.destroyDropdownScrollbar.bind(this));
            $(document).on('input', this.$select.parent().find('.select2-search__field'), this.customizeDropdownScrollbar.bind(this));
        }
    };

    Component.prototype.openDropdownScrollbar = function() {
        this.destroyDropdownScrollbar();

        if (this.multiple) {
            setTimeout(function() {
                OverlayScrollbars(this.$el.find('.multi-select-dropdown'), { className: 'os-theme-dark' });
            }.bind(this), 100);
            return;
        }

        setTimeout(function() {
            var $list = this.$el.find('ul.select2-results__options');
            var $inputField = this.$select.parent().find('.select2-search__field');

            $list.unbind('mousewheel');
            this.overlayScrollbarInstance = OverlayScrollbars($list, { className: 'os-theme-dark' });
            this.destroyDropdownScrollbar();
            $inputField.trigger('input');
        }.bind(this), 10);
    };

    Component.prototype.customizeDropdownScrollbar = function() {
        this.destroyDropdownScrollbar();

        if (this.multiple) {
            return;
        }

        setTimeout(function() {
            var $list = this.$el.find('ul.select2-results__options');
            var $inputField = this.$select.parent().find('.select2-search__field');

            $list.unbind('mousewheel');
            this.overlayScrollbarInstance = OverlayScrollbars($list, { className: 'os-theme-dark' });
            $inputField.trigger('focus');
        }.bind(this), 10);
    };

    Component.prototype.destroyDropdownScrollbar = function() {
        if (this.overlayScrollbarInstance instanceof OverlayScrollbars) {
            this.overlayScrollbarInstance.destroy();
        }
    };

    /**
     * Hide/unhide Experience/Notice dropdown
     * @param e - event
     * @param param - object with countryName field
     */
    Component.prototype.handleExperienceNoticeDropdown = function(e, param) {
        // To get form type <div class="form-type hidden" > with data attribute was added for form-constructor
        var formType = this.$el.parents('.form-constructor-ui').find('.form-type').data('form-type');
        var isApplyForJobIndependent = formType === 'epam-com/components/form/action/apply-for-job-independent';
        var isExperienceNoticeDropdown = this.name === 'applicantYearsOfExperience' || this.name === 'applicantNoticePeriod';

        if (isExperienceNoticeDropdown && isApplyForJobIndependent) {
            var isIndiaCountry = param && param.countryName === 'India';
            this.$el.toggleClass(constants.Classes.hidden, !isIndiaCountry);
            this.toggleExperienceNoticeDropdown(isIndiaCountry, isIndiaCountry ? this.name : '');
        }
    };

    /**
     *
     * @param isRequired - show if validation for field is needed
     * @param name - name attribute for field
     */
    Component.prototype.toggleExperienceNoticeDropdown = function(isRequired, name) {
        this.validations.isRequired = isRequired;
        this.$select.attr('name', name);
    };

    Component.prototype.validationEvents = 'change blur select2:close';
    Component.prototype.classes = $.extend({}, FormControl.prototype.classes, {
        select: 'dropdown-list__selection',
        visibleInput: 'select2-selection',
        parent: 'form-component__input',
        selectBoxContainer: '.select2-container',
        formComponentField: 'form-component__field',
        label: 'form-component__label',
        selectedPlaceholder: '.dropdown-list__selected-placeholder',
        additionalFieldHolder: '.dropdown-list__additional-field-holder'
    });

    Component.moduleName = 'Dropdown List';
    Component.selector = '.dropdown-list-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define('AdditionalField', ['form', 'form-control', 'constants'], function (form, FormControl, constants) {
    'use strict';

    function Component($el) {
        FormControl.call(this, $el);
        this.$el = $el;
        this.$select = this.$el.parent().find('.' + this.classes.select);
        this.$input = this.$el.find(this.classes.additionalField);
        this.$additionalFieldLabel = this.$el.find(this.classes.additionalFieldLabel);
    }

    Component.prototype = Object.create(FormControl.prototype);

    Component.prototype.initAdditionalField = function () {
        this.$select.on('select2:select', function (event) {
            this.toggleAdditionalField(event);
        }.bind(this));

        this.$input.on('blur', function () {
            this.$input.trigger('change');
        }.bind(this));

        this.registerField();
    };

    Component.prototype.toggleAdditionalField = function (event) {
        var additionalField = event.params.data.element.dataset.additionalValue,
            isRequired = event.params.data.element.hasAttribute('data-required-field'),
            requiredMessage = event.params.data.element.dataset.requiredMessage,
            isFieldPresentAndRequired = isRequired && additionalField,
            additionalFieldMessage = isFieldPresentAndRequired ? additionalField + '*' : additionalField,
            isRedesign23 = $('body').hasClass(this.classes.darkMode) || $('body').hasClass(this.classes.lightMode),
            isInsideInlineForm = this.$input.closest(this.classes.formComponentInline).length > 0,
            isECStyleForm = this.$input.closest(this.classes.epamContinuumStyle).length > 0,
            placeholder = isRedesign23 || !(isInsideInlineForm && !isECStyleForm) ? '' : additionalFieldMessage;

        this.$input.val('').attr('placeholder', placeholder);
        this.$el.attr({
            'data-required': isFieldPresentAndRequired ? isRequired : 'false',
            'data-required-msg': isFieldPresentAndRequired ? requiredMessage : null
        });
        this.$additionalFieldLabel.text(additionalFieldMessage);
        this.$el.toggleClass(constants.Classes.hidden, !additionalField);
        !isRequired && this.$input.trigger('change');
    };

    Component.prototype.registerField = function () {
        form.registerField({
            form: this.$form,
            field: this.$input.attr('name'),
            cleanField: this.cleanField.bind(this),
            displayValue: this.displayValue.bind(this),
            cleanError: this.toggleError.bind(this),
            displayError: this.toggleError.bind(this),
            validator: this.getValidator.bind(this),
            validationEvent: this.validationEvents
        });
    };

    Component.prototype.getValidator = function () {
        var result = [],
            textfieldRequiredMessage = this.$el.attr('data-required-msg'),
            additionalField = this.$input[0];

        if (additionalField && !additionalField.value) {
            textfieldRequiredMessage && result.push(textfieldRequiredMessage);
        }
        return result;
    };

    Component.prototype.validationEvents = 'focusout change DOMAutoComplete';
    Component.prototype.classes = $.extend({}, FormControl.prototype.classes, {
        select: 'dropdown-list__selection',
        additionalField: '.dropdown-list__additional-field',
        additionalFieldLabel: '.dropdown-list__additional-field-label',
        formComponentInline: '.form-component--inline',
        epamContinuumStyle: '.epam-continuum-style',
        darkMode: 'dark-mode',
        lightMode: 'light-mode'
    });

    Component.moduleName = 'Additional Field';
    Component.selector = '.dropdown-list__additional-field-holder';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Comment', ['form', 'form-control'], function (form, FormControl) {
    'use strict';

    var $body = $('body');

    var CLASSES = {
        N & DS_CONTINUUM_STYLE: 'epam-continuum-style',
        LABEL: 'form-component__label',
        FAKE_PLACEHOLDER: 'fake-placeholder',
        HIDDEN: 'hidden',
        STANDALONE: 'form-component--standalone',
    };

    function Component($el) {
        this.$el = $el;
        FormControl.call(this, $el);
        this.$input = this.$el.find('textarea');
        this.isRedesign23 =  $body.hasClass('dark-mode') || $body.hasClass('light-mode');

        this.registerField();
        this.setOverlayScrollbar();
        this.onFocus();

        this.isEpamContinuumStyle = this.$el.parents('.' + CLASSES.N & DS_CONTINUUM_STYLE).length > 0;
        this.isStandalone = !!this.$el.parents('.' + CLASSES.STANDALONE).length;

        if (this.isEpamContinuumStyle && this.$input.attr('placeholder') && !this.isGoogleChrome()) {
            this.$label = this.$el.find('.' + CLASSES.LABEL);
            this.createFakePlaceholder();
            this.removeRealPlaceholder();
            this.addEventListener(this.fakePlaceholder);
            this.triggerEvent();
        }
    }

    Component.prototype = Object.create(FormControl.prototype);

    Component.prototype.setOverlayScrollbar = function () {
        if (this.isRedesign23) {
            setTimeout(function () {
                this.scrollbarInstance = OverlayScrollbars(this.$input, {
                    className: 'os-theme-dark',
                    textarea: {
                        dynHeight: true,
                    },
                });
            }.bind(this), 100);
        }
    };

    Component.prototype.onFocus = function () {
        if (this.isRedesign23) {
            this.$input.on('focus', function () {
                this.$el.addClass('focused');
            }.bind(this));

            this.$input.on('focusout', function () {
                this.$el.removeClass('focused');
            }.bind(this));
        }
    };

    Component.prototype.registerField = function () {
        form.registerField({
            form: this.$form,
            field: this.$input.attr('name'),
            cleanField: this.cleanField.bind(this),
            displayValue: function (event, value) {
                this.displayValue(event, value);
                if (this.isRedesign23) {
                    this.scrollbarInstance.update();
                }
            }.bind(this),
            cleanError: this.toggleError.bind(this),
            displayError: this.toggleError.bind(this),
            validator: form.requiredValidator(this.$input, this.context),
            validationEvent: this.validationEvents
        });
    };

    Component.prototype.isGoogleChrome = function () {
        return window.navigator.userAgent.indexOf('Chrome') !== -1;
    };

    Component.prototype.createFakePlaceholder = function () {
        let placeholderText = this.$input.attr('placeholder');
        this.fakePlaceholder = $('<span>' + placeholderText + '</span>');
        this.fakePlaceholder.addClass(CLASSES.FAKE_PLACEHOLDER);
        this.calcPaddingBottom();
        this.setFakePlaceholderHeight();
        this.fakePlaceholder.appendTo(this.$el);
    };

    Component.prototype.calcPaddingBottom = function () {
        this.paddingBottom = this.isStandalone ? 6.7 : 6.1;
    };

    Component.prototype.setFakePlaceholderHeight = function () {
        this.fakePlaceholder.css('bottom', this.pixelsToRems(this.$label.height()) + this.paddingBottom + 'rem');
    };

    Component.prototype.pixelsToRems = function (valueInPixels) {
        return valueInPixels / 10;
    };

    Component.prototype.removeRealPlaceholder = function () {
        this.$input.removeAttr('placeholder');
    };

    Component.prototype.addEventListener = function ($fakePlaceholder) {
        this.$input.on('input keydown', function () {
            $(this).val()
                ? $fakePlaceholder.addClass(CLASSES.HIDDEN)
                : $fakePlaceholder.removeClass(CLASSES.HIDDEN);
        });
    };

    Component.prototype.triggerEvent = function () {
        var event = jQuery.Event('keydown');
        this.$input.trigger(event);
    };

    Component.prototype.validationEvents = 'blur';

    Component.moduleName = 'Comment';
    Component.selector = '.comment-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Checkbox', ['form', 'form-control'], function (form, FormControl) {
    'use strict';

    function Component($el) {
        FormControl.call(this, $el);
        this.$checkboxHolder = this.$el.find('.' + this.classes.checkboxHolder);
        this.$input = this.$el.find('input');
        this.$errorTooltip = this.$el.find('.' + FormControl.classes.errorTooltip);
        this.validator = form.requiredValidator(this.$input, this.context);
        this.registerField();
    }

    Component.prototype = Object.create(FormControl.prototype);

    Component.prototype.registerField = function () {
        form.registerField({
            form: this.$form,
            field: this.$input.attr('name'),
            cleanField: this.cleanField.bind(this),
            cleanError: this.toggleError.bind(this),
            displayError: this.toggleError.bind(this),
            validator: this.validator,
            validationEvent: this.validationEvents
        });
    };

    Component.prototype.cleanField = function () {
        this.toggleError();
        this.$input.prop('checked', false);
    };

    Component.prototype.toggleError = function (error) {
        var hasError = !!error;

        this.$checkboxHolder.toggleClass(FormControl.classes.fieldError, hasError);
        this.$input.attr('aria-invalid', hasError);
        this.$errorTooltip.text(error || '');
    };

    Component.prototype.validationEvents = 'change DOMAutoComplete';
    Component.prototype.classes = $.extend({}, FormControl.prototype.classes, {
        checkboxHolder: 'checkbox__holder'
    });

    Component.moduleName = 'Checkbox';
    Component.selector = '.checkbox-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Captcha', ['form', 'form-control', 'utils-env', 'constants'], function (form, FormControl, env, constants) {
    'use strict';

    var CAPTCHA_REFRESH_INTERVAL = 60 * 1000,
        JCR_CONTENT = 'jcr_content_',
        currentCaptcha = {};

    var captchaEndpoints = {
        oldView: '/services/interaction/captcha.png?:captchaKey=',
        redesignView: '/services/interaction/captcha23.png?:captchaKey='
    };
    var $body = $(document.body);

    function Component($el) {
        this.$el = $el;
        this.updateThemeMode();
        this.isEditMode = env.isEditMode();
        this.reCaptchaEnabled = this.$el.data('recaptcha-enabled');

        if (this.reCaptchaEnabled && !this.isEditMode) {
            return;
        }

        this.$window = $(window);
        this.$form = this.$el.closest('form');
        this.$input = this.$el.find('.' + this.classes.input);
        this.$captchaImage = this.$el.find('.' + this.classes.captchaImage);
        this.$captchaKey = this.$el.find('input[name=":captchaKey"]');
        this.$errorTooltip = this.$el.find('.' + FormControl.classes.errorTooltip);

        this.context = form.extractValidationContext(this.$el);

        this.interval = setInterval(this.refreshCaptcha.bind(this), CAPTCHA_REFRESH_INTERVAL);
        this.isTabActive = !document.hidden;
        this.captchaId = this.$captchaKey.attr('id');
        this.captchaId = this.captchaId.substring(this.captchaId.indexOf(JCR_CONTENT) + JCR_CONTENT.length);

        this.registerField();
        this.$window.blur(this.windowBlur.bind(this));
        this.$window.focus(this.windowFocus.bind(this));
        $.when(currentCaptcha.loadPromise).then(currentCaptcha.loadPromise
            ? this.refreshCaptcha.bind(this) : this.initLoadPromise.bind(this));
 
        $body.on(constants.Events.themeSwitch, this.refreshCaptcha.bind(this));
    }

    Component.prototype.registerField = function () {
        form.registerField({
            form: this.$form,
            field: this.$input.attr('name'),
            mandatoryCleanUp: true,
            cleanField: this.cleanField.bind(this),
            cleanError: this.cleanError.bind(this),
            displayError: this.displayError.bind(this),
            validator: form.requiredValidator(this.$input, this.context)
        });
    };

    Component.prototype.windowBlur = function () {
        this.isTabActive = false;
        clearInterval(this.interval);
    };

    Component.prototype.windowFocus = function () {
        this.isTabActive = true;
        this.updateCaptcha();
    };

    Component.prototype.cleanField = function () {
        this.$input.val('');
        this.updateCaptcha();
    };

    Component.prototype.cleanError = function () {
        this.$el.removeClass(FormControl.classes.fieldError);
        this.$errorTooltip.text('');
    };

    Component.prototype.displayError = function (error) {
        this.$el.toggleClass(FormControl.classes.fieldError, !!error);
        this.$errorTooltip.text(error || '');
        this.updateCaptcha();
    };

    Component.prototype.refreshCaptcha = function () {
        if (this.isTabActive) {
            var captchaKey = this.captchaId + '_' + new Date().getTime();
            this.modifyCaptchaSrcAttribute(captchaKey);
            this.$captchaKey.val(captchaKey);
        }
    };

    Component.prototype.updateThemeMode = function () {
        this._lightMode = $body.hasClass(this.classes.lightMode);
        this._darkMode = $body.hasClass(this.classes.darkMode);
    };

    Component.prototype.modifyCaptchaSrcAttribute = function (captchaKey) {
        this.updateThemeMode();

        if (this._lightMode) {
            this.$captchaImage.attr('src', captchaEndpoints.redesignView + captchaKey + '&mode=light');
            return;
        }

        if (this._darkMode) {
            this.$captchaImage.attr('src', captchaEndpoints.redesignView + captchaKey + '&mode=dark');
            return;
        }

        this.$captchaImage.attr('src', captchaEndpoints.oldView + captchaKey);
    };

    Component.prototype.initLoadPromise = function () {
        var deferred = $.Deferred();
        this.$captchaImage.one('load', function () {
            deferred.resolve();
        });
        this.refreshCaptcha();
        currentCaptcha.loadPromise = deferred.promise();
    };

    Component.prototype.updateCaptcha = function () {
        clearInterval(this.interval);
        this.refreshCaptcha();
        this.interval = setInterval(this.refreshCaptcha.bind(this), CAPTCHA_REFRESH_INTERVAL);
    };

    Component.prototype.classes = {
        input: 'captcha__input',
        captchaImage: 'captcha__image',
        parentForm: '.form-component',
        darkMode: 'dark-mode',
        lightMode: 'light-mode',
    };

    Component.moduleName = 'Captcha';
    Component.selector = '.captcha-ui';

    return Component;
});

/*
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define('autofill-with-linkedin', ['linkedInUtils'], function(linkedinUtils) {
    'use strict';

    function prepareOptions(rawData) {
        return {
            locationFieldsContainer: $('.location-fields-ui'),
            getCountryFieldValue: function() {
                return $('.country-field-ui .select2-selection__rendered').text();
            },
            linkedinData: {
                country: rawData.country.toUpperCase(),
                region: rawData.state,
                city: rawData.city,
                zipCode: rawData.zip,
            },
            isAlphaCodeUse: true,

        };
    }

    window.addEventListener('message', function(event) {
        try {
            var message = JSON.parse(event.data);
            if (message.type === 'formData') {
                var rawData = message.data;
                var options = prepareOptions(rawData);
                var isPrefillWithGeolocation = $('.geolocation-country').length > 0;

                if (isPrefillWithGeolocation) {
                    return;
                }
                linkedinUtils.fillLocationFormFields(options);
            }
        } catch (e) {
            return;
        }
    });
});
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('linkedinModule', ['analytics'], function (analytics) {
    'use strict';

    var isPageWithLinkedinForm = document.querySelector('script[data-mode=\'BUTTON_DATA\']');
    var pushEventOnStartForm = null;
    var localForm = null;

    if (isPageWithLinkedinForm) {
        localStorage.setItem('isAppliedWithLinkedin', 'false');

        N & DS.pushLinkedinApplyGtmEvent = function () {
            pushEventOnStartForm();
            var event = analytics.getEvent(localForm);

            event = event && $.extend({}, event, {
                eventAction: 'Clicks on AWL',
            });

            if (event) {
                analytics.push(event);
            }
        };
    }

    function addForm(form) {
        localForm = form;
    }

    function initLinkedin(originalDataMode, targetDataMode) {
        if (isAppliedWithLinkedin()) {
            if (!isTwoStepsForm()) {
                changeLinkedinMode(originalDataMode, targetDataMode);
                triggerLinkedInScript();
            }
        }
    }

    function isAppliedWithLinkedin() {
        return JSON.parse(localStorage.getItem('isAppliedWithLinkedin'));
    }

    function getLinkedInConfigByType(originalDataMode) {
        return document.querySelector('script[data-mode=\'' + originalDataMode + '\']');
    }

    function changeLinkedinMode(originalDataMode, targetDataMode) {
        var linkedinConfigurationScript = getLinkedInConfigByType(originalDataMode);
        linkedinConfigurationScript.setAttribute('data-mode', targetDataMode);
    }

    function triggerLinkedInScript() {
        var widgetHolder = document.querySelector('[name=\'widget-holder\']');
        var linkedinScript = document.createElement('script');
        linkedinScript.src = 'https://www.linkedin.com/mjobs/awli/awliWidget';
        widgetHolder.appendChild(linkedinScript);
        showLinkedinWidgetV3(); // for new linkedin style
    }

    function isSecondStep() {
        var url = window.location.href;
        return url.indexOf('vacancyId') !== -1;
    }

    function isTwoStepsForm() {
        return !!document.querySelector('.form-component__self-id-link');
    }

    function resetApplyWithLinkedin() {
        localStorage.setItem('isAppliedWithLinkedin', 'false');
    }

    function hideLinkedinWidget() {
        $('.IN-Awli-widget').addClass('hidden');
    }

    /*
    for new linkedin style
     */
    function hideLinkedinWidgetV3() {
        $('.IN-widget').addClass('hidden');
    }

    function showLinkedinWidget() {
        $('.IN-Awli-widget').removeClass('hidden');
    }

    function showLinkedinWidgetV3() {
        $('.IN-widget').removeClass('hidden');
    }

    function addCallbackForStartForm(callback) {
        pushEventOnStartForm = callback;
    }

    return {
        initLinkedin: initLinkedin,
        resetApplyWithLinkedin: resetApplyWithLinkedin,
        isTwoStepsForm: isTwoStepsForm,
        isSecondStep: isSecondStep,
        changeLinkedinMode: changeLinkedinMode,
        triggerLinkedInScript: triggerLinkedInScript,
        isAppliedWithLinkedin: isAppliedWithLinkedin,
        getLinkedInConfigByType: getLinkedInConfigByType,
        hideLinkedinWidget: hideLinkedinWidget,
        hideLinkedinWidgetV3: hideLinkedinWidgetV3,
        showLinkedinWidgetV3: showLinkedinWidgetV3,
        showLinkedinWidget: showLinkedinWidget,
        addCallbackForStartForm: addCallbackForStartForm,
        addForm: addForm,
    };
});

define('linkedInUtils', ['constants'], function (constants) {
    'use strict';
    /**
     * @param dataGeolocationName there are two ways to obtain select data 1)data-geolocation-name 2)data-iso-code-alpha-2
     */
    function getLocationSelectVal (select, dataGeolocationName, useAlphaCode) {
        var selectVal = null;

        if (useAlphaCode) {
            selectVal = select.find('option[data-iso-code-alpha-2="' + dataGeolocationName + '"]').val();
        } else {
            selectVal = select.find('option[data-geolocation-name="' + dataGeolocationName + '"]').val();
        }
        return selectVal;
    }

    function fillFormField (formField, value) {
        if (formField && value) {
            formField.value = value;
            // trigger manual event to reset field validation message
            var event = new Event('change');
            formField.dispatchEvent(event);
        }
    }

    /**
     * fill simple input  fields without dropdown
     */
    function fillCasualFormFields (options) {
        var fieldsObject = [
            {
                formFieldName: 'applicantFirstName',
                linkedInResponsePropName: 'firstName'
            },
            {
                formFieldName: 'applicantLastName',
                linkedInResponsePropName: 'lastName'
            },
            {
                formFieldName: 'applicantEmail',
                linkedInResponsePropName: 'emailAddress'
            },
            {
                formFieldName: 'applicantMessage',
                linkedInResponsePropName: 'publicProfileUrl'
            },
            {
                formFieldName: 'applicantPhone',
                linkedInResponsePropName: 'phoneNumber'
            }
        ];

        for (var i = 0; i < fieldsObject.length; i++) {
            var field =  document.querySelector('[name=\'' + fieldsObject[i].formFieldName + '\']');
            if (field) {
                fillFormField(field,  options.linkedinData[fieldsObject[i].linkedInResponsePropName]);
            }
        }
    }

    function fillLocationZipCodeField (options) {
        options.locationFieldsContainer.one(constants.Events.locationSelectZipCodeUpdate, function () {
            var zipCodeSelect = getLocationFieldsSelector('zip-code');
            zipCodeSelect.val(options.linkedinData.zipCode).trigger('change');
        });
    }

    function fillLocationCityFiled (options) {
        /**
         * dataObj - define what kind of field should be used.
         * if dataObj.isEmpty === 0 means dropdown has no value, so input should be used instead
         */
        options.locationFieldsContainer.one(constants.Events.locationSelectCityUpdate, function (event, dataObj) {
            if (dataObj.isEmpty === 0) {
                var cityInputField = getLocationFieldsSelector('city', true);
                cityInputField.val(options.linkedinData.city);
            } else {
                var citySelect = getLocationFieldsSelector('city');
                citySelect.val(getLocationSelectVal(
                  citySelect,
                  options.linkedinData.city
                )).trigger('change');
            }
        });
    }

    function fillLocationRegionField (options) {
        options.locationFieldsContainer.one(constants.Events.locationSelectRegionUpdate, function () {
            var regionSelect = getLocationFieldsSelector('region');
            regionSelect.val(getLocationSelectVal(
              regionSelect,
              options.linkedinData.region,
              options.isAlphaCodeUse
            )).trigger('change');
        });
    }

    function fillLocationCountryField (options) {
        var countrySelect = getLocationFieldsSelector('country');
        var countrySelectValue = getLocationSelectVal(countrySelect, options.linkedinData.country, options.isAlphaCodeUse);
        countrySelect.val(countrySelectValue).trigger('change');
    }

    function fillLocationFormFields (options) {
        var isPrefillWithGeolocation = $('.country-filled').length > 0;
        if (!isPrefillWithGeolocation) {
            fillLocationCountryField(options);
            var region = getRegionAndCity(options.linkedinData.dataArray, 'region', options.linkedinData.country, options);
            if (region) {
                options.linkedinData.region = region;
                fillLocationRegionField(options);
            }
            var city = getRegionAndCity(options.linkedinData.dataArray, 'city', options.linkedinData.country, options);
            if (city) {
                options.linkedinData.city = city;
                fillLocationCityFiled(options);
            }
            var zipCode = options.linkedinData.zipCode;
            if (zipCode) {
                fillLocationZipCodeField(options);
            }
        }
    }

    function getRegionAndCity(array, field, country, options) {
        //options for autofill with linkedin
        //isAlphaCodeUse indicate autofill option
        if (options.isAlphaCodeUse) {
            return options.linkedinData[field];
        }
        if (country === 'United States' || country === 'Canada' || country === 'US') {
            if (field === 'region') {
                return array[array.length-2];
            }

            if (field === 'city') {
                return array[array.length-3];
            }
        }
        if (field === 'city') {
            //if array === 3 it means country has postal code, but it needs only for US and Canada
            if (array.length === 3) {
                return array[array.length-3];
            } else {
                return array[array.length-2];
            }
        }
    }

    function getLocationFieldsSelector (fieldName, isFindInput) {
        if (isFindInput) {
           return $('.location-fields-ui .' + fieldName +  '-field-ui input');
        }

        return $('.location-fields-ui .' + fieldName +  '-field-ui select');
    }

    return {
        fillLocationFormFields: fillLocationFormFields,
        fillLocationCountryField: fillLocationCountryField,
        fillLocationRegionField: fillLocationRegionField,
        fillLocationCityFiled: fillLocationCityFiled,
        fillCasualFormFields: fillCasualFormFields,
        fillLocationZipCodeField: fillLocationZipCodeField,
    };
});

// eslint-disable-next-line
function onProfileData(profileData) {
    'use strict';
    if (!JSON.parse(localStorage.getItem('isAppliedWithLinkedin'))) {
        N & DS.pushLinkedinApplyGtmEvent();
    }

    localStorage.setItem('isAppliedWithLinkedin', 'true');

    var summaryFiled = $('.linkedin-summary-ui');
    if (summaryFiled.length) {
        summaryFiled.removeClass('hidden');
    }

    require(['linkedInUtils'], function (linkedinUtils) {
        $(window).trigger('linkedin.data.received', [{linkedinData: profileData}]);

        var parseLinkedinData = (function () {
            var dataArr = profileData.location.locationName.split(', ');
            var result = {
                region: null,
                city: null,
                isAlphaCodeUse: false,
                firstName: profileData.firstName,
                lastName: profileData.lastName,
                emailAddress: profileData.emailAddress,
                publicProfileUrl: profileData.publicProfileUrl,
                country: dataArr[dataArr.length-1],
                dataArray: dataArr,
                phoneNumber: profileData.phoneNumber
            };
            return result;
        })();

        var options = {
            locationFieldsContainer: $('.location-fields-ui'),
            getCountryFieldValue: function () {
                return $('.country-field-ui .select2-selection__rendered').text();
            },
            linkedinData: parseLinkedinData,
        };

        linkedinUtils.fillCasualFormFields(options);
        linkedinUtils.fillLocationFormFields(options);
    });
}

define('linkedInSummaryParser', [], function () {
    'use strict';
    var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
      ? function(obj) {
          return typeof obj;
      }
      : function(obj) {
          return obj && typeof Symbol === 'function' && obj.constructor === Symbol
            ? 'symbol' : typeof obj;
      };

    var PROFILE_DATA = {
        headLine: 'headline',
        firstName: 'firstName',
        lastName: 'lastName',
        emailAddress: 'emailAddress',
        phoneNumber: 'phoneNumber',
        summary: 'summary',
        positions: 'positions',
        title: 'title',
        startDate: 'startDate',
        month: 'month',
        year: 'year',
        endDate: 'endDate',
        companyName: 'companyName',
        educations: 'educations',
        schoolName: 'schoolName',
        degree: 'degree',
        fieldOfStudy: 'fieldOfStudy',
        headline: 'headline',
        skills: 'skills',
        isCurrent: 'isCurrent',
    };

    var createFiled = function createFiled(field, value) {
        if (value) {
            return '\n  ' + field + ': ' + value;
        }
        return '';
    };

    function datesScheme(data) {
        if (data) {
            return data[PROFILE_DATA.month] + ' ' + data[PROFILE_DATA.year];
        }
        return '';
    }

    function positionsScheme(data) {
        var formatData =
          '\n  ' +
          createFiled('Position', data[PROFILE_DATA.title]) +
          '  ' +
          createFiled('Company', data[PROFILE_DATA.companyName]) +
          '  ' +
          createFiled('Dates', datesScheme(data[PROFILE_DATA.startDate]) + ' - ' + datesScheme(data[PROFILE_DATA.endDate])) +
          '  ' +
          createFiled('Description', data[PROFILE_DATA.summary]) +
          '  ';
        return formatData;
    }

    function educationScheme(data) {
        var result =
          '\n  ' +
          createFiled('University', data[PROFILE_DATA.schoolName]) +
          '  ' +
          createFiled('Degree', data[PROFILE_DATA.degree]) +
          '  ' +
          createFiled('Faculty', data[PROFILE_DATA.fieldOfStudy]) +
          '  ' +
          createFiled('Dates', datesScheme(data[PROFILE_DATA.startDate]) + ' - ' + datesScheme(data[PROFILE_DATA.endDate])) +
          '  ';
        return result;
    }

    function skillsScheme(data) {
        return data['name'];
    }

    function extractProfileSection(profileData, section, scheme, divider) {
        var profileSection = profileData[section];
        if (Array.isArray(profileSection)) {
            var array = [];
            for (var i = 0; i < profileSection.length; i++) {
                var _section = profileSection[i];
                var result = scheme(_section);
                array.push(result);
            }
            return array.join(divider);
        } else {
            var _result = null;
            if (scheme) {
                _result = scheme(profileData[section]);
            } else {
                _result = profileData[section];
            }
            return _result;
        }
    }

    function findActivePosition(profileData) {
        var positions = profileData[PROFILE_DATA.positions];
        var result = [];
        for (var i = 0; i < positions.length; i++) {
            var position = positions[i];
            if (position[PROFILE_DATA.isCurrent]) {
                result.push(position[PROFILE_DATA.title] + ' at ' + position[PROFILE_DATA.companyName]);
            }
        }
        return result.join(', ');
    }

    var validator = {
        get: function get(target, prop) {
            if (target[prop] === undefined || target[prop] === null) {
                return '';
            }

            if (
              _typeof(target[prop]) === 'object'
              && target[prop] !== null
              && prop === PROFILE_DATA.startDate
              || prop === PROFILE_DATA.endDate
            ) {
                return new Proxy(target[prop], validator);
            }

            if (Array.isArray(target[prop]) && target[prop] !== null) {
                for (var i = 0; i < target[prop].length; i++) {
                    target[prop][i] = new Proxy(target[prop][i], validator);
                }
            }

            if (prop in target) {
                return target[prop];
            }
            return '';
        },
    };

    function formattingLinkedinSummary(data) {
        var profileData = new Proxy(data, validator);

        var formattedString =
          '\n  ' +
          profileData[PROFILE_DATA.firstName] +
          ' ' +
          profileData[PROFILE_DATA.lastName] +
          '\n  ' +
          findActivePosition(data) +
          '\n  -------------------------------------\n  Summary: ' +
          extractProfileSection(profileData, PROFILE_DATA.summary) +
          '\n  --------------------------------------\n  Work history:  ' +
          extractProfileSection(profileData, PROFILE_DATA.positions, positionsScheme, '') +
          '\n  --------------------------------------\n  Education:  ' +
          extractProfileSection(profileData, PROFILE_DATA.educations, educationScheme, '') +
          '\n  --------------------------------------\n  Skills:\n  ' +
          extractProfileSection(profileData, PROFILE_DATA.skills, skillsScheme, ', ') +
          '\n  ';
        return formattedString;
    }

    return {
        formattingLinkedinSummary: formattingLinkedinSummary,
    };
});
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('form-control', ['form'], function (form) {
  'use strict';

  var classes = {
    errorTooltip: 'validation-tooltip',
    fieldError: 'validation-field',
    validationText: 'validation-text',
    focusTarget: 'validation-focus-target',
    epamContinuumStyle: 'epam-continuum-style',
    continuumLabel: 'form-component__continuum-label-title',
    label: 'form-component__label',
    fakePlaceholder: 'fake-placeholder',
  };

  function Component($el) {
    this.$el = $el;
    this.$form = this.$el.closest('form');
    this.$errorTooltip = this.$el.find('.' + classes.errorTooltip);
    this.$errorText = this.$errorTooltip.find('.' + classes.validationText);
    this.defaultValue = this.$el.data('defaultValue') || '';
    this.context = form.extractValidationContext(this.$el);
    this.isEpamContinuumStyle = this.$el.parents('.' + classes.epamContinuumStyle).length > 0;

    this.$label = this.$el.find('.' + classes.label);
    this.initialLabelText = this.$label.text();
  }

  Component.prototype.cleanField = function () {
    this.toggleError();
    this.$input.val(this.defaultValue);
    this.afterClean && this.afterClean();
  };

  Component.prototype.displayValue = function (event, value) {
    this.$input.val(value);
  };

  Component.prototype.toggleError = function (error) {
    var hasError = !!error;

    this.$el.toggleClass(classes.fieldError, hasError);
    this.$input.attr('aria-invalid', hasError);
    this.$errorTooltip.find('.is-a11y-only').toggleClass('hidden', !hasError);
    this.$errorText.text(error || '');

    if (this.$el.find('.' + classes.fakePlaceholder).length) {
        this.setFakePlaceholderHeight();
    }
  };

  Component.classes = classes;

  return Component;
});

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ColumnControl', [], function () {
  'use strict';

  var CLASSES = {
    COLUMN_CONTROL_COLUMN: 'colctrl__col',
    TEXT_UI: 'text-ui'
  };

  var Component = function () {
    function Component(el) {
      var _this = this;

      _classCallCheck(this, Component);

      this.el = el[0];
      var isList = this.el.getAttribute('data-is-list');
      isList && window.addEventListener('DOMContentLoaded', function () {
        _this.items = _this.getInteractiveItems();
        _this.items.length && _this.init();
      });
    }

    _createClass(Component, [{
      key: 'getInteractiveItems',
      value: function getInteractiveItems() {
        var _this2 = this;

        return Array.from(this.el.querySelectorAll('.' + CLASSES.COLUMN_CONTROL_COLUMN)).map(function (item) {
          var imagesAndTextBlocks = item.querySelectorAll('img, .' + CLASSES.TEXT_UI);

          if (imagesAndTextBlocks.length === 0) {
            return item;
          }

          if (imagesAndTextBlocks.length === 1) {
            return imagesAndTextBlocks[0];
          }

          return _this2.getClosestCommonParent(Array.from(imagesAndTextBlocks));
        });
      }
    }, {
      key: 'getClosestCommonParent',
      value: function getClosestCommonParent(arr) {
        var currentNode = arr[0];

        while (currentNode.parentNode) {
          currentNode = currentNode.parentNode;

          /*eslint no-loop-func: warn*/
          if (arr.every(function (node) {
            return currentNode.contains(node);
          })) {
            return currentNode;
          }
        }
      }
    }, {
      key: 'init',
      value: function init() {
        var _window$accessibility;

        if (!window.accessibility) {
          window.accessibility = {
            startIndexes: [],
            items: [],
            indexOfCurrentItem: -1
          };

          this.addEventListenerForNavigationOnPage();
          this.addEventListenerForNavigationInList();
          this.addEventListenerOnTabPress();
        }

        this.createRefresherForIndexOfCurrentItem();
        window.accessibility.startIndexes.push(window.accessibility.items.length);
        (_window$accessibility = window.accessibility.items).push.apply(_window$accessibility, _toConsumableArray(this.items));
      }
    }, {
      key: 'addEventListenerForNavigationOnPage',
      value: function addEventListenerForNavigationOnPage() {
        var _this3 = this;

        window.addEventListener('keydown', function (event) {
          if (event.key.toLowerCase() === 'l') {
            !event.shiftKey ? _this3.changeIndexOfCurrentItem(_this3.findNextStartIndex()) : _this3.changeIndexOfCurrentItem(_this3.findPreviousStartIndex());
          }
        });
      }
    }, {
      key: 'findNextStartIndex',
      value: function findNextStartIndex() {
        for (var i = 0; i < window.accessibility.startIndexes.length; i++) {
          if (window.accessibility.startIndexes[i] > window.accessibility.indexOfCurrentItem) {
            return window.accessibility.startIndexes[i];
          }
        }
        return -1;
      }
    }, {
      key: 'findPreviousStartIndex',
      value: function findPreviousStartIndex() {
        for (var i = window.accessibility.startIndexes.length - 1; i >= 0; i--) {
          if (window.accessibility.startIndexes[i] < window.accessibility.indexOfCurrentItem) {
            return window.accessibility.startIndexes[i];
          }
        }
        return -1;
      }
    }, {
      key: 'changeIndexOfCurrentItem',
      value: function changeIndexOfCurrentItem(newIndex) {
        if (newIndex >= 0 && newIndex <= window.accessibility.items.length - 1) {
          window.accessibility.indexOfCurrentItem = newIndex;
          this.setFocusToCurrentItem();
        }
      }
    }, {
      key: 'setFocusToCurrentItem',
      value: function setFocusToCurrentItem() {
        var currentItem = window.accessibility.items[window.accessibility.indexOfCurrentItem];
        var isTabindexExists = currentItem.getAttribute('tabindex') && currentItem.getAttribute('tabindex') !== '-1';

        if (!isTabindexExists) {
          currentItem.setAttribute('tabindex', 0);

          currentItem.addEventListener('focusout', function removeTabindex() {
            currentItem.setAttribute('tabindex', -1);
            currentItem.removeEventListener('focusout', removeTabindex);
          });
        }

        currentItem.focus();
      }
    }, {
      key: 'addEventListenerForNavigationInList',
      value: function addEventListenerForNavigationInList() {
        var _this4 = this;

        window.addEventListener('keydown', function (event) {
          if (event.key === 'ArrowRight' || !event.shiftKey && event.key.toLowerCase() === 'i') {
            _this4.changeIndexOfCurrentItem(window.accessibility.indexOfCurrentItem + 1);
          } else if (event.key === 'ArrowLeft' || event.shiftKey && event.key.toLowerCase() === 'i') {
            _this4.changeIndexOfCurrentItem(window.accessibility.indexOfCurrentItem - 1);
          }
        });
      }
    }, {
      key: 'addEventListenerOnTabPress',
      value: function addEventListenerOnTabPress() {
        window.addEventListener('keydown', function (event) {
          if (event.key === 'Tab') {
            setTimeout(function () {
              var indexAfterCurrentFocus = window.accessibility.items.findIndex(function (item) {
                return document.activeElement.compareDocumentPosition(item) !== Node.DOCUMENT_POSITION_PRECEDING;
              });

              window.accessibility.indexOfCurrentItem = indexAfterCurrentFocus === -1 ? window.accessibility.items.length - 1 : indexAfterCurrentFocus;
            }, 0);
          }
        });
      }
    }, {
      key: 'createRefresherForIndexOfCurrentItem',
      value: function createRefresherForIndexOfCurrentItem() {
        this.items.forEach(function (item) {
          item.addEventListener('focus', function () {
            window.accessibility.indexOfCurrentItem = window.accessibility.items.indexOf(item);
          });
        });
      }
    }]);

    return Component;
  }();

  Component.moduleName = 'Column Control';
  Component.selector = '.colctrl-ui';

  return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('PaddingComponent', ['utils'], function (utils) {
  'use strict';

  var CLASSES = {
    DATA_DESKTOP_HEIGHT: 'data-desktopHeight',
    DATA_RESPONSIVE_HEIGHT: 'data-responsiveHeight',
    DATA_RESPONSIVE_BREAKPOINTS: 'data-responsiveBreakpoints',
    TABLET: 'tablet',
    MOBILE: 'mobile'
  };

  var mediaQuery = {
    mobile: '(max-width: 767px)',
    tablet: '(min-width: 768px) and (max-width: 991px)'
  };

  var Component = function () {
    function Component($el) {
      _classCallCheck(this, Component);

      this._el = $el[0];
      this.desktopHeight = this._el.getAttribute(CLASSES.DATA_DESKTOP_HEIGHT);
      this.responsiveHeight = this._el.getAttribute(CLASSES.DATA_RESPONSIVE_HEIGHT) || this.desktopHeight;
      this.breakPoint = this._el.getAttribute(CLASSES.DATA_RESPONSIVE_BREAKPOINTS);
      this.isTabletBreakPoint = this.breakPoint === CLASSES.TABLET;
      this.isMobileBreakPoint = this.breakPoint === CLASSES.MOBILE;
      this.init();
    }

    _createClass(Component, [{
      key: 'init',
      value: function init() {
        this.resizeEventHandler();
        window.addEventListener('resize', utils.debounce(this.resizeEventHandler.bind(this), 300));
      }
    }, {
      key: 'resizeEventHandler',
      value: function resizeEventHandler() {
        var isTablet = window.matchMedia(mediaQuery.tablet).matches;
        var isMobile = window.matchMedia(mediaQuery.mobile).matches;

        if (this.isTabletBreakPoint && (isMobile || isTablet)) {
          this._el.style.height = this.responsiveHeight + 'px';
        } else if (this.isMobileBreakPoint && isMobile) {
          this._el.style.height = this.responsiveHeight + 'px';
        } else {
          this._el.style.height = this.desktopHeight + 'px';
        }
      }
    }]);

    return Component;
  }();

  Component.moduleName = 'Padding Component';
  Component.selector = '.padding-component-ui';

  return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('RolloverBlocks', [], function () {
  'use strict';

  var CLASSES = {
    BLOCK: 'rollover-blocks__block',
    FOCUSED_BLOCK: 'rollover-blocks__block--focused',
    BLOCK_CONTENT: 'rollover-blocks__content',
    ROLLOVER_BLOCK: 'rollover-blocks__description-rollover',
    LINK_A11Y: 'rollover-blocks__link-holder--a11y',
    LINK_LEARN_MORE: 'rollover-blocks__link',
    RTE_LINKS: 'rollover-blocks__text a'
  };

  var Component = function () {
    function Component($el) {
      _classCallCheck(this, Component);

      this.el = $el[0];
      this.blocks = this.el.querySelectorAll('.' + CLASSES.BLOCK);
      this.addEventListenersToBlocks();
    }

    _createClass(Component, [{
      key: 'addEventListenersToBlocks',
      value: function addEventListenersToBlocks() {
        var _this5 = this;

        this.blocks.forEach(function (block, index) {
          var blockContent = block.querySelector('.' + CLASSES.BLOCK_CONTENT);
          var linkA11y = block.querySelector('.' + CLASSES.LINK_A11Y);
          var rolloverBlock = block.querySelector('.' + CLASSES.ROLLOVER_BLOCK);
          var learnMoreLink = block.querySelector('.' + CLASSES.LINK_LEARN_MORE);
          var RTELinks = block.querySelectorAll('.' + CLASSES.RTE_LINKS);
          var links = [learnMoreLink].concat(_toConsumableArray(RTELinks));

          if (index === 0) {
            _this5.showForAccessibility(blockContent);
          }

          blockContent.addEventListener('click', function () {
            if (learnMoreLink) {
              learnMoreLink.click();
            } else if (RTELinks[0]) {
              RTELinks[0].click();
            }
          });

          _this5.hideForAccessibility.apply(_this5, _toConsumableArray(RTELinks));
          _this5.addEventListenerToRolloverBlock(block, rolloverBlock, links);

          linkA11y.addEventListener('click', function () {
            _this5.showForAccessibility.apply(_this5, [rolloverBlock].concat(_toConsumableArray(links)));
            rolloverBlock.focus({ preventScroll: true });
          });
        });
      }
    }, {
      key: 'addEventListenerToRolloverBlock',
      value: function addEventListenerToRolloverBlock(block, rolloverBlock, links) {
        var _this6 = this;

        rolloverBlock.addEventListener('focus', function () {
          setTimeout(function () {
            block.classList.add(CLASSES.FOCUSED_BLOCK);
            _this6.showForAccessibility.apply(_this6, [rolloverBlock].concat(_toConsumableArray(links)));
          }, 5);
        });

        rolloverBlock.addEventListener('blur', function () {
          block.classList.remove(CLASSES.FOCUSED_BLOCK);
          _this6.hideForAccessibility.apply(_this6, [rolloverBlock].concat(_toConsumableArray(links)));
        });

        links.forEach(function (link) {
          if (link) {
            link.addEventListener('focus', function () {
              block.classList.add(CLASSES.FOCUSED_BLOCK);
              _this6.showForAccessibility.apply(_this6, [rolloverBlock].concat(_toConsumableArray(links)));
            });

            link.addEventListener('blur', function () {
              block.classList.remove(CLASSES.FOCUSED_BLOCK);
              _this6.hideForAccessibility.apply(_this6, [rolloverBlock].concat(_toConsumableArray(links)));
            });
          }
        });
      }
    }, {
      key: 'showForAccessibility',
      value: function showForAccessibility() {
        for (var _len = arguments.length, arr = Array(_len), _key = 0; _key < _len; _key++) {
          arr[_key] = arguments[_key];
        }

        arr.forEach(function (el) {
          if (el) {
            el.setAttribute('tabindex', 0);
            el.removeAttribute('aria-hidden');
          }
        });
      }
    }, {
      key: 'hideForAccessibility',
      value: function hideForAccessibility() {
        for (var _len2 = arguments.length, arr = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          arr[_key2] = arguments[_key2];
        }

        arr.forEach(function (el) {
          if (el) {
            el.setAttribute('tabindex', -1);
            el.setAttribute('aria-hidden', true);
          }
        });
      }
    }]);

    return Component;
  }();

  Component.selector = '.rollover-blocks-ui';
  Component.moduleName = 'Rollover Blocks';

  return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('TileList', [], function () {
  'use strict';

  var CLASSES = {
    TILE: 'tile-list__item',
    TILE_ACTIVE: 'tile-list__item--active',
    TILE_LINK: 'tile-list__link',
    TILE_LINK_EXTERNAL: 'tile-list__external-link',
    LINK_A11Y: 'tile-list__link--a11y',
    LINK_A11Y_HOLDER: 'tile-list__link-holder--a11y',
    TILE_CONTENT: 'tile-list__content',
    TABS_UI: 'tabs-ui',
    TABS_ITEM: 'tabs__item'
  };

  var Component = function () {
    function Component($el) {
      _classCallCheck(this, Component);

      this.el = $el[0];
      this.tiles = this.el.querySelectorAll('.' + CLASSES.TILE);
      this.addEventListeners();
      this.disableTabsFocus();
    }

    _createClass(Component, [{
      key: 'addEventListeners',
      value: function addEventListeners() {
        var _this7 = this;

        this.tiles.forEach(function (tile, index) {
          var linkA11y = tile.querySelector('.' + CLASSES.LINK_A11Y);
          var linkA11yHolder = tile.querySelector('.' + CLASSES.LINK_A11Y_HOLDER);
          var tileLinkInternal = tile.querySelector('.' + CLASSES.TILE_LINK);
          var tileContent = tile.querySelector('.' + CLASSES.TILE_CONTENT);
          var tileLinkExternal = tile.querySelector('.' + CLASSES.TILE_LINK_EXTERNAL);
          var tileLinks = [tileLinkInternal, tileLinkExternal];

          if (index === 0) {
            _this7.showA11yForTile(tileContent, tile);
          }

          _this7.hideA11yForTile(tileContent);
          _this7.addEventListenersToTileContent(tile, tileContent, tileLinks);
          _this7.addEventListenersToA11yLink(tile, tileContent, linkA11y, linkA11yHolder, tileLinks);
          _this7.addEventListenerToTile(tile, linkA11yHolder, tileLinks);
          _this7.addEventListenersToLinks(tile, tileContent, tileLinks);
        });
      }
    }, {
      key: 'addEventListenersToLinks',
      value: function addEventListenersToLinks(tile, tileContent, tileLinks) {
        var _this8 = this;

        tileLinks.forEach(function (link) {
          if (link) {
            link.addEventListener('focus', function () {
              tile.classList.add(CLASSES.TILE_ACTIVE);
              _this8.showA11yForTile.apply(_this8, [tileContent].concat(_toConsumableArray(tileLinks)));
            });

            link.addEventListener('focusout', function () {
              tile.classList.remove(CLASSES.TILE_ACTIVE);
              _this8.hideA11yForTile.apply(_this8, [tileContent].concat(_toConsumableArray(tileLinks)));
            });
          }
        });
      }
    }, {
      key: 'addEventListenerToTile',
      value: function addEventListenerToTile(tile, linkA11yHolder, tileLinks) {
        var _this9 = this;

        tile.addEventListener('focus', function () {
          linkA11yHolder.setAttribute('aria-hidden', true);
        });

        tile.addEventListener('click', function () {
          _this9.simulateClickOnTileLinks(tileLinks);
        });
      }

      // eslint-disable-next-line max-params

    }, {
      key: 'addEventListenersToA11yLink',
      value: function addEventListenersToA11yLink(tile, tileContent, linkA11y, linkA11yHolder, tileLinks) {
        var _this10 = this;

        linkA11y.addEventListener('focus', function () {
          linkA11yHolder.setAttribute('aria-hidden', false);
        });

        linkA11y.addEventListener('click', function (e) {
          e.stopPropagation();
          tile.classList.add(CLASSES.TILE_ACTIVE);
          _this10.showA11yForTile.apply(_this10, [tileContent].concat(_toConsumableArray(tileLinks)));
          setTimeout(function () {
            tileContent.focus();
          }, 5);
        });
      }
    }, {
      key: 'addEventListenersToTileContent',
      value: function addEventListenersToTileContent(tile, tileContent, tileLinks) {
        var _this11 = this;

        tileContent.addEventListener('focus', function () {
          setTimeout(function () {
            tile.classList.add(CLASSES.TILE_ACTIVE);
            _this11.showA11yForTile.apply(_this11, [tileContent].concat(_toConsumableArray(tileLinks)));
          }, 5);
        });

        tileContent.addEventListener('focusout', function () {
          tile.classList.remove(CLASSES.TILE_ACTIVE);
          _this11.hideA11yForTile.apply(_this11, [tileContent].concat(_toConsumableArray(tileLinks)));
        });

        tileContent.addEventListener('click', function (e) {
          e.stopPropagation();
          _this11.simulateClickOnTileLinks(tileLinks);
        });
      }
    }, {
      key: 'simulateClickOnTileLinks',
      value: function simulateClickOnTileLinks(tileLinks) {
        tileLinks.forEach(function (link) {
          if (link) {
            link.click();
          }
        });
      }
    }, {
      key: 'showA11yForTile',
      value: function showA11yForTile() {
        for (var _len3 = arguments.length, arr = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          arr[_key3] = arguments[_key3];
        }

        // arr contains tile and tileConent or tileContent, internal and external links
        arr.forEach(function (el) {
          if (el) {
            el.setAttribute('tabindex', 0);
            el.removeAttribute('aria-hidden');
          }
        });
      }
    }, {
      key: 'hideA11yForTile',
      value: function hideA11yForTile() {
        for (var _len4 = arguments.length, arr = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          arr[_key4] = arguments[_key4];
        }

        // arr contains tile and tileConent or tileContent, internal and external links
        arr.forEach(function (el) {
          if (el) {
            el.setAttribute('tabindex', -1);
            el.setAttribute('aria-hidden', true);
          }
        });
      }

      /* disables 'disappearing' focus in-between tabs-ui component and tile-list component
      when navigating via tab key */

    }, {
      key: 'disableTabsFocus',
      value: function disableTabsFocus() {
        var tabsUI = this.el.closest('.' + CLASSES.TABS_UI);
        if (tabsUI) {
          tabsUI.querySelectorAll('.' + CLASSES.TABS_ITEM).forEach(function (tab) {
            tab.setAttribute('tabindex', -1);
          });
        }
      }
    }]);

    return Component;
  }();

  Component.moduleName = 'Tile List';
  Component.selector = '.tile-list-ui';

  return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ObserversAPI', [], function () {
  'use strict';

  var defaultProps = {
    root: null, // if null - viewPort is root element
    rootMargin: '0px', //px or %
    threshold: 1
  };
  /**
   *
   * @param callback apply two params: 1 - entries 2 - observer instance
   * @param options
   * @param observableHTMLElement
   */
  var intersectionObserverFunction = function intersectionObserverFunction(callback, observableHTMLElement) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var intersectionObserver = new IntersectionObserver(callback, Object.assign(defaultProps, options));
    intersectionObserver.observe(observableHTMLElement);
  };

  return {
    intersectionObserver: intersectionObserverFunction
  };
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('RequestAnimationFrame', [], function () {
  'use strict';

  /* eslint-disable no-extra-parens, no-unused-vars */

  var FPS = 60; //this is necessary for high refresh rate screens

  var callback = [];
  var startTime = 0;

  /**
   * 
   * @param {obj} function applies object as a param which contains two functions:
   *  func - execute Function and isEnd - condition, in order to stop animation and remove it from callback array
   * example
   * {
   *  @param {func}: function which run when component inside viewport,
   *  @param {isEnd}: function is order to check if animation is end, is 'true' remove from animation queue
   * }  
   */
  function increaseAnimationQueue(obj, fps) {
    obj.fps = fps ? fps : FPS;
    obj.then = Date.now();
    obj.fpsInterval = 1000 / obj.fps;
    callback.push(obj);
    isAnimationRunning();
  }

  function isAnimationRunning() {
    if (startTime !== 0) {
      return;
    }

    startAnimation();
  }

  function startAnimation() {
    startTime = Date.now();
    animate();
  }

  function animate() {
    if (callback.length === 0) {
      startTime = 0;
      return;
    }

    requestAnimationFrame(animate);

    var now = Date.now();
    for (var i = 0; i < callback.length; i++) {
      var elapsed = now - callback[i].then;

      if (elapsed > callback[i].fpsInterval) {
        callback[i].then = now - elapsed % callback[i].fpsInterval;

        callback[i].func();

        if (callback[i].isEnd()) {
          callback.splice(i, 1);
        }
      }
    }
  }

  return {
    increaseAnimationQueue: increaseAnimationQueue
  };
});
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define(['utils', 'RequestAnimationFrame'], function (utils, reqAnimationFrame) {
  'use strict';

  var VIEWPORT_HEIGHT = window.innerHeight / 100 * 80;
  var ANIMATION_DURATION = 2; // 2 second for default
  // this value was taken from animation-utils.es6.js FPS variable
  // 9 - means amount of function invocation for 1 sec (approximately value)
  var TRIGGER_PER_SECOND = 9 * ANIMATION_DURATION;
  var animatedCountFunctions = [];

  /**
   * start counting number when user position will be above 70% of the screen
   */
  var runCounter = function runCounter() {
    var elPos = this.el.getBoundingClientRect();
    if (elPos.top <= VIEWPORT_HEIGHT) {
      this.startValue += this.step;
      if (this.startValue === this.string || this.startValue > this.string) {
        this.el.innerHTML = this.originalString;
        this.finish = true;
        return;
      }
      this.el.innerHTML = addSign.call(this, this.startValue.toString());
    }
  };

  var stopCounter = function stopCounter() {
    if (this.finish) {
      return true;
    }
  };

  function addSign(value) {
    var result = this.signCount > 1 ? addSignToRawString.call(this, value) : addAppropriateSign.call(this, value);
    return this.sign === -1 ? Math.ceil(result) : result;
  }

  /**
   *
   * @param originNumber - number received from DOM
   * @param triggerPerSecond - constant value (see above)
   * @returns {number|number} - increase per tick
   */
  var defineStep = function defineStep(originNumber, triggerPerSecond) {
    var step = originNumber / triggerPerSecond;
    if (this.signCount > 1) {
      return Math.ceil(step);
    }
    if (step > 0.1) {
      return +parseFloat(step).toFixed(this.precise);
    }
    return +parseFloat(step).toFixed(2);
  };

  function defineSign() {
    if (this.originalString.indexOf(',') !== -1) {
      this.sign = ',';
    } else if (this.originalString.indexOf('.') !== -1) {
      this.sign = '.';
    }
  }

  function definePrecise() {
    var lastIdxPos = this.originalString.lastIndexOf(this.sign);
    if (lastIdxPos !== -1) {
      this.precise = this.originalString.length - 1 - lastIdxPos;
      return;
    }
    if (this.string < TRIGGER_PER_SECOND) {
      this.precise = 1;
    }
  }

  function replaceSign(str) {
    if (this.sign && this.sign === ',') {
      return str.replaceAll('.', ',');
    }
    return str;
  }

  function addAppropriateSign(str) {
    if (this.precise !== 0) {
      return replaceSign.call(this, parseFloat(str).toFixed(this.precise));
    } else {
      return replaceSign.call(this, str);
    }
  }

  /**
   * for cases when number has more than 1 sign (100.000.000)
   * in this case all the delimiters are removed, (100.000.000 -> 100000000)
   * but for correct display this function place delimiters on their original place
   * this.precise - depict how many numbers follow before next delimiter (.000.)
   * 50 - prevent function from infinite recursion
   */
  function addSignToRawString(str) {
    var result = str;
    var strLen = result.length;
    var signCount = Math.floor(strLen / this.precise);
    var firstIndex = strLen - this.precise * signCount;
    while (firstIndex <= strLen) {
      if (firstIndex === 0) {
        firstIndex += this.precise;
      } else {
        result = result.slice(0, firstIndex) + this.sign + result.slice(firstIndex);
        firstIndex += this.precise + 1;
      }
    }

    return result;
  }

  function defineSignCount(str) {
    var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    if (this.sign !== -1) {
      var index = str.indexOf(this.sign, idx);
      if (index !== -1) {
        this.signCount += 1;
        defineSignCount.call(this, str, index + 1);
      }
    }
  }

  var createCounterFunction = function createCounterFunction(nodeList) {
    Array.prototype.forEach.call(nodeList, function (element) {
      var funcContext = {
        signCount: 0,
        startValue: 0,
        finish: false,
        sign: -1,
        precise: 0
      };
      funcContext.originalString = element.innerHTML;
      defineSign.call(funcContext);
      defineSignCount.call(funcContext, funcContext.originalString);

      if (funcContext.signCount > 1) {
        funcContext.string = parseFloat(funcContext.originalString.replaceAll(funcContext.sign, ''));
      } else {
        funcContext.string = parseFloat(funcContext.originalString.replaceAll(',', '.'));
      }

      if (!isNaN(funcContext.string)) {
        definePrecise.call(funcContext);
        funcContext.step = defineStep.call(funcContext, funcContext.string, TRIGGER_PER_SECOND);
        funcContext.el = element;
        element.innerHTML = 0;
        animatedCountFunctions.push({
          func: runCounter.bind(funcContext),
          endFunc: stopCounter.bind(funcContext)
        });
      }
    });
  };

  document.addEventListener('DOMContentLoaded', function () {
    var animatedNumbers = document.querySelectorAll('.rte-number-animation');
    createCounterFunction(animatedNumbers);
    Array.prototype.forEach.call(animatedCountFunctions, function (element) {
      reqAnimationFrame.increaseAnimationQueue({
        func: element.func,
        isEnd: element.endFunc
      }, 10);
    });
  });
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('animation-tools', ['utils'], function (utils) {
  'use strict';

  var viewPort = window.innerHeight;
  var SCREEN_CENTER = viewPort / 2;
  var classes = {
    multipleBlock: 'multiple-topics-list__block-image-wrapper',
    multipleParallaxSection: 'multiple-topics-list__animation-placeholder-wrapper',
    parallaxSection: 'parallax-section',
    featureParallaxBlock: 'featured-content-card__parallax-block',
    featureSection: 'featured-content-card__image-wrapper'
  };
  //if you need to change this value, pay attention on css-props transform: scale(X)
  var DEFAULT_PARALLAX_SHIFT = 10; // value in %

  var getScroll = function getScroll() {
    return window.scrollY;
  };

  var getElRect = function getElRect(el) {
    var pos = el.getBoundingClientRect();
    return {
      top: pos.top + getScroll(),
      rawTop: pos.top,
      bottom: pos.bottom + getScroll(),
      rawBottom: pos.bottom,
      height: el.offsetHeight
    };
  };

  var applyTransform = function applyTransform(el, transitionPercent, translateDirection, percentage) {
    var elRect = getElRect(el);
    var distance = Math.ceil(elRect.height / 100 * percentage);
    var transition = distance / 100 * transitionPercent * translateDirection;
    el.style.transform = 'translateY(' + transition + 'px)';
  };

  var positionOnTheScreen = function positionOnTheScreen(el) {
    var pos = getElRect(el);
    var percent = 0;
    var translateDirection = 0;
    if (pos.rawTop < SCREEN_CENTER) {
      percent = 100 - pos.rawTop / SCREEN_CENTER * 100;
      translateDirection = 1;
    } else {
      percent = pos.rawTop / SCREEN_CENTER * 100 - 100;
      translateDirection = -1;
    }

    return {
      percent: percent,
      translateDirection: translateDirection
    };
  };

  function parallaxFunction(section) {
    if (utils.isElementInViewport(section)) {
      var _positionOnTheScreen = positionOnTheScreen(section),
          percent = _positionOnTheScreen.percent,
          translateDirection = _positionOnTheScreen.translateDirection;

      applyTransform(this, percent, translateDirection, DEFAULT_PARALLAX_SHIFT);
    }
  }

  var markParallaxSection = function markParallaxSection(imageWrapper) {
    var section = void 0;

    if (imageWrapper.classList.contains(classes.multipleBlock)) {
      section = imageWrapper.closest('.' + classes.multipleParallaxSection);
    } else if (imageWrapper.classList.contains(classes.featureParallaxBlock)) {
      section = imageWrapper.closest('.' + classes.featureSection);
    } else {
      section = imageWrapper.closest('.section');
    }

    section.classList.add(classes.parallaxSection);

    return section;
  };

  var Parallax = {
    applyParallax: function applyParallax(imageWrapper) {
      var section = markParallaxSection(imageWrapper);
      return parallaxFunction.bind(imageWrapper, section);
    },
    parallaxStopCondition: function parallaxStopCondition() {
      return false;
    }
  };

  return {
    Parallax: Parallax,
    getElRect: getElRect
  };
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define(['utils', 'RequestAnimationFrame'], function (utils, reqAnimationFrame) {
  'use strict';

  document.addEventListener('DOMContentLoaded', function () {
    var nodesToShow = document.querySelectorAll('.rte-text-animation');
    var elementsToShow = Array.prototype.slice.call(nodesToShow);

    function textImmersion() {
      for (var i = 0; i < elementsToShow.length; i++) {
        if (utils.isElementInViewport(elementsToShow[i])) {
          elementsToShow[i].classList.add('live-text');
          elementsToShow.splice(i, 1);
        }
      }
    }

    function textImmersionEnd() {
      return elementsToShow.length === 0;
    }

    if (elementsToShow.length !== 0) {
      reqAnimationFrame.increaseAnimationQueue({
        func: textImmersion,
        isEnd: textImmersionEnd
      });
    }
  });
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define(['RequestAnimationFrame', 'animation-tools', 'constants'], function (reqAnimationFrame, animationTools, constants) {
  'use strict';

  var appliedParallax = 'applied-parallax';

  var applyParallaxFeature = function applyParallaxFeature() {
    var parallaxItems = document.querySelectorAll('.parallax-wrapper:not(.' + appliedParallax + ')');

    parallaxItems.forEach(function (imageWrapper) {
      imageWrapper.classList.add(appliedParallax);
      reqAnimationFrame.increaseAnimationQueue({
        func: animationTools.Parallax.applyParallax(imageWrapper),
        isEnd: animationTools.Parallax.parallaxStopCondition
      });
    });
  };

  document.addEventListener(constants.Events.featureGridAddedNewItems, function () {
    applyParallaxFeature();
  });

  document.addEventListener('DOMContentLoaded', function () {
    applyParallaxFeature();
  });
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('SolutionsHubReferrer', [], function () {
  'use strict';

  var VARIABLES = {
    referrerKey: 'SolutionsHubReferrer',
    referrerField: '.hidden-field-ui[name="source"]'
  };

  var saveReferrer = function saveReferrer() {
    var savedValue = sessionStorage.getItem(VARIABLES.referrerKey);
    if (savedValue === null) {
      sessionStorage.setItem(VARIABLES.referrerKey, JSON.stringify({ 'referrer': document.referrer, 'isPaidTraffic': isPaidSource() }));
    }
  };

  var setReferrerHiddenField = function setReferrerHiddenField(form) {
    var referrerField = form.querySelector(VARIABLES.referrerField);
    if (referrerField) {
      referrerField.value = sessionStorage.getItem(VARIABLES.referrerKey);
    }
  };

  var isPaidSource = function isPaidSource() {
    var paidTrafficParamsRegex = /gclid|gclsrc|compaignSource|utm_source/gi;
    var searchParams = document.location.search;
    return paidTrafficParamsRegex.test(searchParams);
  };

  saveReferrer();

  return {
    setReferrerHiddenField: setReferrerHiddenField
  };
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('sticky-scroll', ['utils', 'media'], function (utils, media) {
  'use strict';

  var STICKY_CONTAINER_SELECTOR = '[data-sticky-scroll="true"]';
  var MAIN_ELEMENTS = '#main > div';
  var ALLOWED_POSITION_OFFSET = 10;
  var afterScrollTimeout = 10;
  var MAX_ITEMS = 4;
  var CLASS_PINNED_TO_TOP = 'pinned-filter--fixed';
  var INVISIBLE = 'invisible';

  var pinSpacerBoundaries = []; // {start, end, offsetTop}

  window.addEventListener('load', init);

  function init() {
    var stickyScrollElements = document.querySelectorAll(STICKY_CONTAINER_SELECTOR);
    var hasStickyScrollElements = stickyScrollElements.length > 0;
    if (!hasStickyScrollElements) {
      return;
    }

    addPinSpacerWrapper();
    setPinBoundaries();
    setBodyHeight();
    bindEvents();
    handleInitialScrollPosSafariWrapper();
    setTimeout(function () {
      anchorHandlerInit();
    }, 0);
  }

  /**
   * get scroll position works incorrectly inside safari.
   * So, in order to obtain the correct scroll position after a page reload, a small delay may need to be used.
   */
  function handleInitialScrollPosSafariWrapper() {
    var pos = document.body.scrollTop || document.documentElement.scrollTop;
    if (pos > 0) {
      return;
    }
    checkScrollPositionThreeTimes();
  }

  function checkScrollPositionThreeTimes() {
    var runCount = 0;
    var intervalId = setInterval(function () {
      runCount++;
      var scrollPosition = document.body.scrollTop || document.documentElement.scrollTop;

      if (scrollPosition > 0 || runCount === 3) {
        clearInterval(intervalId);
        handleInitialScrollPos();
      }
    }, 300);
  }

  function anchorHandlerInit() {
    if (!document.querySelectorAll('a[id]').length) {
      return;
    }

    if (window.location.hash) {
      scrollToAnchor(window.location.hash);
    }

    document.querySelectorAll('a[href^="#"]').forEach(function (anchor) {
      anchor.addEventListener('click', function (e) {
        e.preventDefault();
        togglePageVisibility(false);
        if (window.location.hash === anchor.getAttribute('href')) {
          scrollToAnchor(window.location.hash);
        } else {
          window.location.hash = anchor.getAttribute('href');
        }
      });
    });

    window.onhashchange = function (e) {
      e.preventDefault();
      var hash = window.location.hash;
      if (!hash) {
        handleScreenResize();
        return;
      }
      scrollToAnchor(hash);
    };
  }

  function togglePageVisibility(visible) {
    var $elements = $(MAIN_ELEMENTS);

    if (visible) {
      $elements.removeClass(INVISIBLE);
    } else {
      $elements.addClass(INVISIBLE);
    }
  }

  function isValidHash(hash) {
    var pattern = /^#[A-Za-z][A-Za-z0-9\-_:]*$/;
    return pattern.test(hash);
  }

  function scrollToAnchor(hash) {
    var isValid = isValidHash(hash);

    if (isValid) {
      scrollToElement(hash);
    }
  }

  function getStickyScrollElementsBeforeAnchor(id) {
    var sanitizedId = DOMPurify.sanitize(id);
    var anchorsAndStickyScrollElements = $(STICKY_CONTAINER_SELECTOR + ', ' + sanitizedId);
    var anchorIndex = anchorsAndStickyScrollElements.toArray().findIndex(function (element) {
      return element.id === sanitizedId.substring(1);
    });
    if (anchorIndex === 0) {
      return [];
    }
    return anchorsAndStickyScrollElements.slice(0, anchorIndex);
  }

  function scrollToElement(id) {
    var sanitizedId = DOMPurify.sanitize(id);
    var $anchorTarget = $('' + sanitizedId);
    if (!$anchorTarget.length) {
      return;
    }

    var $stickyScrollElementsBeforeAnchor = getStickyScrollElementsBeforeAnchor(sanitizedId);

    var totalStickyScrollElementsHeight = $stickyScrollElementsBeforeAnchor.length ? $stickyScrollElementsBeforeAnchor.toArray().reduce(function (totalStickyScrollElementsHeightAcc, currentElement) {
      var elementBoundaries = getElementPinBoundaries(currentElement);
      var currentElementHeight = elementBoundaries.end - elementBoundaries.start;
      return totalStickyScrollElementsHeightAcc + currentElementHeight;
    }, 0) : 0;

    var anchorTargetToTopDistance = $anchorTarget.offset().top || 0;
    var pinSpacerToTopDistance = $('.pin-spacer').offset().top || 0;
    var distanceToScroll = anchorTargetToTopDistance + totalStickyScrollElementsHeight + ALLOWED_POSITION_OFFSET;
    if ($(window).scrollTop() > pinSpacerBoundaries[0].start) {
      distanceToScroll -= pinSpacerToTopDistance;
    }

    $(window).scrollTop(distanceToScroll);
    // need to call resize handler immediately
    handleScreenResize();

    setTimeout(function () {
      togglePageVisibility(true);
    }, afterScrollTimeout);
  }

  function handleInitialScrollPos() {
    /**
     * case when side-menu is opened and scroll is hidden, to avoid page jumping when condition is true skip code below
     */
    var isScrollHidden = document.documentElement.classList.contains('noscroll');

    if (isScrollHidden) {
      return;
    }

    var scrollPos = document.body.scrollTop || document.documentElement.scrollTop;
    var pinBoundaries = pinSpacerBoundaries.find(function (_ref) {
      var start = _ref.start,
          end = _ref.end;
      return scrollPos >= start && scrollPos <= end;
    });

    if (pinBoundaries) {
      handleEnterPinBoundary(scrollPos, pinBoundaries);
    } else {
      handleExitPinBoundary(scrollPos);
    }
  }

  function addPinSpacerWrapper() {
    var pinSpacerWrapper = document.createElement('div');
    pinSpacerWrapper.classList.add('pin-spacer');
    pinSpacerWrapper.style.width = '100%';
    pinSpacerWrapper.style.position = 'relative';
    var body = document.querySelector('body');
    while (body.firstChild) {
      pinSpacerWrapper.appendChild(body.firstChild);
    }
    body.appendChild(pinSpacerWrapper);
  }

  function setPinSpacerFixed(val, offset, scrollPos) {
    var pinSpacer = document.querySelector('.pin-spacer');
    var styles = val ? {
      position: 'fixed',
      top: '-' + offset + 'px'
    } : {
      position: 'relative',
      top: offset + 'px'
    };

    Object.assign(pinSpacer.style, styles);

    Array.from(document.querySelectorAll(STICKY_CONTAINER_SELECTOR)).forEach(function (container) {
      var _getElementPinBoundar = getElementPinBoundaries(container),
          start = _getElementPinBoundar.start,
          end = _getElementPinBoundar.end;

      container.dataset.stickyScrollStarted = start <= scrollPos;
      container.dataset.stickyScrollEnded = end <= scrollPos;

      // scroll all prev elements till the end
      if (scrollPos > end) {
        scrollElement(container, end - start);
        return;
      }
      // and all next to the start
      if (scrollPos < start) {
        scrollElement(container, 0);
        return;
      }
      scrollElement(container, scrollPos - start);
    });
  }

  function bindEvents() {
    window.addEventListener('scroll', handleScroll);
    var pinSpacer = document.querySelector('.pin-spacer');

    if (window.ResizeObserver) {
      var pinSpacerResizeObserver = new ResizeObserver(function () {
        handleScreenResize();
      });

      pinSpacerResizeObserver.observe(pinSpacer);
    } else {
      handleScreenResize();
      var $pinSpacer = $(pinSpacer);
      var lastSizes = [$pinSpacer.width(), $pinSpacer.height()];
      $(window).bind('click resize', utils.debounceExtend(function () {
        var currentSizes = [$pinSpacer.width(), $pinSpacer.height()];
        var sizesChanged = lastSizes[0] !== currentSizes[0] || lastSizes[1] !== currentSizes[1];
        var isPinSpacerFixed = $pinSpacer.css('position') === 'fixed';
        if (sizesChanged && !isPinSpacerFixed) {
          lastSizes = currentSizes;
          handleScreenResize();
        }
      }, 300));
    }
  }

  function handleScreenResize() {
    setPinBoundaries();
    setBodyHeight();
    handleInitialScrollPos();
  }

  function getOffsetTop(el) {
    var offsetTop = 0;
    var currentElement = el;
    var pinSpacer = document.querySelector('.pin-spacer');
    while (currentElement.offsetParent) {
      if (currentElement !== pinSpacer && !isNaN(currentElement.offsetTop)) {
        offsetTop += currentElement.offsetTop;
      }
      currentElement = currentElement.offsetParent;
    }
    return offsetTop;
  }

  function isVerticalScrollElement(el) {
    var isVerticalMode = el.dataset.stickyScrollVertical === 'true';

    if (el.dataset.stickyScrollSize && el.dataset.stickyScrollSize < MAX_ITEMS && !isVerticalMode && media.currentMode().lessThan(media.modes.Tablet)) {
      isVerticalMode = true;
    }

    return isVerticalMode;
  }

  function getElementPinBoundaries(el) {
    var isVertical = isVerticalScrollElement(el);
    var offsetHeight = el.offsetHeight,
        scrollHeight = el.scrollHeight,
        offsetWidth = el.offsetWidth,
        scrollWidth = el.scrollWidth;

    var offsetTopToDoc = getOffsetTop(el);
    var bottom = offsetTopToDoc + offsetHeight;
    var clientHeight = document.documentElement.clientHeight;

    var topOffset = (clientHeight - offsetHeight) / 2;

    if (document.getElementsByClassName(CLASS_PINNED_TO_TOP).length) {
      var pinnedEl = document.getElementsByClassName(CLASS_PINNED_TO_TOP)[0];
      topOffset = (clientHeight - offsetHeight - pinnedEl.offsetHeight) / 2;
    }
    var additionalSpacing = isVertical ? 0 : -1 * topOffset;

    var prevSpacersHeight = pinSpacerBoundaries.filter(function (boundary) {
      return boundary.offsetTop + ALLOWED_POSITION_OFFSET < offsetTopToDoc;
    }).reduce(function (sum, _ref2) {
      var start = _ref2.start,
          end = _ref2.end;
      return sum + end - start;
    }, 0);
    var pinBoundaryStart = bottom - clientHeight - additionalSpacing < 0 ? prevSpacersHeight : bottom - clientHeight - additionalSpacing + prevSpacersHeight;
    var overflowedSize = isVertical ? scrollHeight - offsetHeight : scrollWidth - offsetWidth;
    var pinBoundaryEnd = pinBoundaryStart + overflowedSize;

    return {
      start: pinBoundaryStart,
      end: pinBoundaryEnd,
      offsetTop: offsetTopToDoc
    };
  }

  function setPinBoundaries() {
    pinSpacerBoundaries = [];
    document.querySelectorAll(STICKY_CONTAINER_SELECTOR).forEach(function (container) {
      pinSpacerBoundaries.push(getElementPinBoundaries(container));
    });
  }

  function setBodyHeight() {
    var body = document.querySelector('body');
    var pinSpacer = document.querySelector('.pin-spacer');
    // getting pin-spacer height instead of body height because html, body { height: 100% }
    // to fix this, need to set html height 100% and body min-height 100%;
    var height = pinSpacer.offsetHeight;
    var overflowedContentWidth = pinSpacerBoundaries.reduce(function (sum, _ref3) {
      var start = _ref3.start,
          end = _ref3.end;
      return sum + end - start;
    }, 0);
    var newHeight = height + overflowedContentWidth;
    body.style.height = newHeight + 'px';
  }

  function isScrollPosInPinBoundaries(boundaries, scrollPos) {
    var start = boundaries.start,
        end = boundaries.end;

    return scrollPos >= start && scrollPos <= end;
  }

  function handleScrollPosition(scrollPos) {
    Array.from(document.querySelectorAll(STICKY_CONTAINER_SELECTOR)).some(function (container) {
      var pinBoundaries = getElementPinBoundaries(container);
      if (!isScrollPosInPinBoundaries(pinBoundaries, scrollPos)) {
        // go to next element
        return null;
      }
      scrollElement(container, scrollPos - pinBoundaries.start);
      // set scroll and exit loop
      return true;
    });
  }

  function scrollElement(el, pos) {
    if (isVerticalScrollElement(el)) {
      el.style.transform = 'translate3d(0px, -' + pos + 'px, 0px)';
    } else {
      el.style.transform = 'translate3d(-' + pos + 'px, 0px, 0px)';
    }
  }

  function handleEnterPinBoundary(scrollPos, pinBoundaries) {
    var start = pinBoundaries.start;

    var offset = pinSpacerBoundaries.filter(function (boundary) {
      return boundary.start < start;
    }).reduce(function (acc, boundary) {
      return acc - boundary.end + boundary.start;
    }, start);
    setPinSpacerFixed(true, offset, scrollPos);
  }

  function handleExitPinBoundary(scrollPos) {
    var prevSpacersHeight = pinSpacerBoundaries.filter(function (_ref4) {
      var end = _ref4.end;
      return scrollPos > end;
    }).reduce(function (sum, _ref5) {
      var start = _ref5.start,
          end = _ref5.end;
      return sum + end - start;
    }, 0);
    setPinSpacerFixed(false, prevSpacersHeight, scrollPos);
  }

  function handleScroll() {
    var scrollPos = document.body.scrollTop || document.documentElement.scrollTop;
    var pinBoundaries = pinSpacerBoundaries.find(function (_ref6) {
      var start = _ref6.start,
          end = _ref6.end;
      return scrollPos >= start && scrollPos <= end;
    });
    var isPinSpacerFixed = document.querySelector('.pin-spacer').style.position === 'fixed';
    if (pinBoundaries && !isPinSpacerFixed) {
      handleEnterPinBoundary(scrollPos, pinBoundaries);
    }
    if (!pinBoundaries && isPinSpacerFixed) {
      handleExitPinBoundary(scrollPos);
    }

    if (isPinSpacerFixed) {
      handleScrollPosition(scrollPos);
    }
  }
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('SwipeCarousel', ['utils', 'utils-browser'], function (utils, browser) {
  'use strict';

  var classes = {
    HIDDEN: 'hidden',
    SIMPLE_SCROLL: 'simple-scroll',
    OWL_STAGE: '.owl-stage',
    OWL_STAGE_OUTER: '.owl-stage-outer'
  };

  var sliderStyles = {
    initialAnimation: 'initial',
    transitionAnimation: 'all 0.3s ease 0s'
  };

  function Component() {
    this.element = null;
    this.owl = null;
    this.owlStage = null;
    this.owlStageOuter = null;
    this.progressBar = null;
    this.slider = null;
    this.progressBar = null;
    this.scrollContainer = null;
    this.sliderThumbWidth = 0;
    this.maximalSliderTransformValue = 0;
    this.maximalCarouselTransformValue = 0;
    this.sliderLeft = 0;
    this.carouselSpeed = 300;
    this.isSliderActive = false;
  }

  Component.prototype.initCarousel = function (responsiveOptions) {
    var _this12 = this;

    var supportsTouch = browser.isTouchDevice();

    if (supportsTouch) {
      this.scrollContainer.classList.add(classes.SIMPLE_SCROLL);
      this.progressBar.classList.add(classes.HIDDEN);
    } else {
      $(document).ready(function () {
        $(_this12.owl).owlCarousel({
          autoWidth: true,
          freeDrag: false,
          smartSpeed: 300,
          fluidSpeed: 300,
          merge: true,
          mergeFit: false,
          dots: false,
          removeLastItemMargin: true,
          trackProgressEvent: true,
          animation: {
            watchBoundaries: true,
            onAnimationCallback: _this12.animationCallback.bind(_this12)
          },
          responsive: responsiveOptions || {
            0: {
              margin: 23.7
            },
            991: {
              margin: 49
            }
          }
        });
        _this12.owlStage = _this12.element.querySelector(classes.OWL_STAGE);
        _this12.owlStageOuter = _this12.element.querySelector(classes.OWL_STAGE_OUTER);
        _this12.initCarouselEvents();
      });
    }
  };

  Component.prototype.initCarouselEvents = function () {
    var _this13 = this;

    this.setMaximalCarouselTransformValue();
    this.initSlider();
    this.initSliderEvents();
    this.setSliderDisplay();

    window.addEventListener('resize', utils.debounceExtend(function () {
      _this13.updateCarousel();
      _this13.toCarouselStart();
    }, 300));

    $(this.owl).on('refreshed.owl.carousel', function () {
      _this13.updateCarousel();
      _this13.toCarouselStart();
    });
  };

  Component.prototype.updateCarousel = function () {
    this.setMaximalCarouselTransformValue();
    this.initSlider();
    this.setSliderDisplay();
  };

  Component.prototype.toCarouselStart = function () {
    this.setSliderPosition(0, false, true);
    $(this.owl).trigger('to.owl.carousel', [0, 300]);
  };

  Component.prototype.initSliderEvents = function () {
    var _this14 = this;

    this.slider.addEventListener('mousedown', function () {
      _this14.isSliderActive = true;
      _this14.slider.classList.add('active');
    });
    window.addEventListener('mouseup', function () {
      _this14.isSliderActive = false;
      _this14.slider.classList.remove('active');
    });
    window.addEventListener('mousemove', function (e) {
      if (!_this14.isSliderActive) {
        return;
      }
      e.preventDefault();
      _this14.setSliderPosition(_this14.getMouseRelativePosition(e.clientX), true);
    });

    this.progressBar.addEventListener('click', function (e) {
      _this14.isSliderActive = true;
      _this14.setSliderPosition(_this14.getMouseRelativePosition(e.clientX), true, true);
      _this14.isSliderActive = false;
    });
  };

  Component.prototype.initSlider = function () {
    this.setSliderThumbWidth();
    this.isSliderActive = false;
    this.sliderLeft = this.progressBar.getBoundingClientRect().left;
    this.maximalSliderTransformValue = this.owlStageOuter.clientWidth - this.sliderThumbWidth;
  };

  Component.prototype.setSliderDisplay = function () {
    if (this.maximalCarouselTransformValue >= 0) {
      this.progressBar.classList.add(classes.HIDDEN);
    } else {
      this.progressBar.classList.remove(classes.HIDDEN);
    }
  };

  Component.prototype.getMouseRelativePosition = function (mouseCoordinate) {
    var mouseRelativePosition = mouseCoordinate - this.sliderLeft - 0.5 * this.sliderThumbWidth;
    if (mouseRelativePosition <= 0) {
      return 0;
    }
    if (mouseRelativePosition >= this.maximalSliderTransformValue) {
      return this.maximalSliderTransformValue;
    }
    return mouseRelativePosition;
  };

  Component.prototype.setMaximalCarouselTransformValue = function () {
    var outerWidth = this.owlStageOuter.clientWidth;
    var stageWidth = this.owlStage.clientWidth;
    this.maximalCarouselTransformValue = outerWidth - stageWidth;
  };

  Component.prototype.setSliderThumbWidth = function () {
    var outerWidth = this.owlStageOuter.clientWidth;
    var stageWidth = this.owlStage.clientWidth;
    this.slider.style.width = Math.round(outerWidth * outerWidth / stageWidth) + 'px';
    this.sliderThumbWidth = this.slider.clientWidth;
  };

  Component.prototype.setSliderPosition = function (coordinates) {
    var triggerCarousel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var animated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (animated) {
      this.slider.style.transition = sliderStyles.transitionAnimation;
    } else {
      this.slider.style.transition = sliderStyles.initialAnimation;
    }
    this.slider.style.transform = 'translate3d(' + coordinates + 'px,9px,0px)';
    if (triggerCarousel) {
      var transformValue = coordinates === 0 ? 0 : this.maximalCarouselTransformValue * coordinates / this.maximalSliderTransformValue;
      this.owl.dispatchEvent(new CustomEvent('progress.owl.carousel', {
        detail: {
          transform: transformValue,
          speed: animated ? this.carouselSpeed : 0
        }
      }));
    }
  };

  Component.prototype.animationCallback = function (coordinates) {
    if (this.isSliderActive) {
      return;
    }
    var normalisedCoordinates = coordinates;
    if (coordinates >= 0) {
      normalisedCoordinates = 0;
    }
    if (coordinates <= this.maximalCarouselTransformValue) {
      normalisedCoordinates = this.maximalCarouselTransformValue;
    }
    var sliderCoordinates = Math.abs(normalisedCoordinates) * this.maximalSliderTransformValue / Math.abs(this.maximalCarouselTransformValue);
    this.setSliderPosition(sliderCoordinates);
  };

  return Component;
});
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
$(function () {
    var elem = document.querySelector(".display-section-block");

    function isEmpty(node) {
        return node.textContent.trim() === "";
    }

    if (elem && isEmpty(elem)) {
        elem.classList.add("hidden");
    }
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define(['media'], function(media) {
    'use strict';

    var classes = {
        meetEventContainer: 'event-details-page-23__meet-event-container',
        bookMeetingItem: 'book-meeting-ui-23',
        imageContainer: 'page-template__animation-renderer',
        hidden: 'hidden'
    };

    var $meetEventContainer = $('.' + classes.meetEventContainer);
    var $bookMeetingItem = $('.' + classes.bookMeetingItem);
    var $imageContainer = $('.' + classes.imageContainer);
    var isDesktop = media.currentMode().greaterThan(media.modes.Tablet);

    if ($bookMeetingItem.length && !$bookMeetingItem.html().trim().length) {
        if ($meetEventContainer.length) {
            $meetEventContainer.addClass(classes.hidden);
        }
        if (!isDesktop && $imageContainer.length) {
            $imageContainer.css('top', '70%');
        }
    }
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define('Detail Page Module', [], function () {
    'use strict';
    var eliminationParsysClassesList = [
        '.article__wide-layout',
        '.article__container',
        '.article__related',
    ];
    var topSection = document.querySelector('.detail-page23__section--top');

    if (topSection !== null) {
        if (
            document.querySelectorAll('.detail-page23__header .responsive-image-ui-23').length === 0 &&
            document.querySelectorAll('.detail-page23__header .responsive-image-full-width-ui-23').length === 0
        ) {
            topSection.classList.add('no-image');
        }

        if (document.querySelectorAll('.detail-page23__header .detail-page23-download__button').length === 0) {
            topSection.classList.add('no-link');
        }
    }

    for (var i = 0; i < eliminationParsysClassesList.length; i++) {
        var node = document.querySelector('.detail-page23__container ' + eliminationParsysClassesList[i]);
        if (node && !node.innerHTML.trim()) {
            node.parentNode.removeChild(node);
        }
    }
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define(['media'], function(media) {
    'use strict';

    var continuum = document.body.classList.contains('ec-mode');
    var imageContainer = document.querySelector('.page-template__animation-renderer');
    var isDesktop = media.currentMode().greaterThan(media.modes.Tablet);
    var file = isDesktop ? 'Main_Blur_Style3_Desktop' : 'Main_Blur_Style3_Mobile';

    if (continuum) {
        file = isDesktop ? 'Main_EC_Blur_v1_Desktop' : 'Main_EC_Blur_v2_Mobile';
    }

    if (imageContainer) {
        bodymovin.loadAnimation({
            container: imageContainer,
            renderer: 'canvas',
            loop: true,
            path: '/etc/designs/epam-com/json-animations/metamorphosis/' + file + '.js',
            rendererSettings: {
                className: 'animation__object',
                viewBoxOnly: true,
            }
        });
    }
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define([], function() {
  'use strict';

  var $el = $('.case-study-page23__container');

  var $imageSection = $el.find('.section-image');
  if ($imageSection.length && !$imageSection.html().trim()) {
      $imageSection.addClass('empty');
      $el.addClass('no-image');
  }
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('VideoShowcaseA11y23', [], function () {
    'use strict';

    var CONSTANTS = {
        container: 'a11y-container',
        navigationPanel: 'a11y-navigation-panel',
    };

    /**
     *
     * @type {{
     *     'list-item': 'class witch match iterable item inside navigation panel',
     *     'move-forward-callback': 'additional action after active focus element was changed',
     *     'move-downward-callback': 'additional action after active focus element was changed',
     *     'enter-action': 'additional controls use Enter and Space keys',
     *     'space-action': 'additional controls use Enter and Space keys'

     * }}
     */
    var defaultActiveItemIndex = 0;

    function init(options) {
        this.$optionsA11 = options;
        this.$elA11 = $(this.$el).find('.' + CONSTANTS.container);
        this.$navigationPanelA11 = this.$elA11.find('.' + CONSTANTS.navigationPanel);
        this.$navigationItemsA11 = this.$navigationPanelA11.find('.' + this.$optionsA11['list-item']);
        this.$navigationItemsLengthA11 = this.$navigationItemsA11.length;
        setSpecialAttribute.call(this);
        setKeyHandlers.call(this);
    }

    function setSpecialAttribute (activeItemIndex) {
        this.$navigationPanelA11.attr('role', 'tablist');
        var activeIndex = activeItemIndex ? activeItemIndex : defaultActiveItemIndex;
        $.each(this.$navigationItemsA11, function (index, item) {
            if (index === activeIndex) {
                $(item).attr('aria-selected', 'true').attr('role', 'tab').attr('tabindex', '0');
                return;
            }
            $(item).attr('aria-selected', 'false').attr('role', 'tab').attr('tabindex', '-1');
        });
    }

    function disableAllItems () {
        $.each(getActiveItem.call(this), function (index, item) {
            $(item).attr('aria-selected', 'false').attr('tabindex', '-1');
        });
    }

    function getActiveItem () {
        return this.$navigationPanelA11.find('[aria-selected="true"]');
    }

    function getNextItem () {
        var next = getActiveItem.call(this).next('.' + this.$optionsA11['list-item']);
        return next.length !== 0? next : $(this.$navigationItemsA11[0]);
    }

    function getPrevItem () {
        var prev = getActiveItem.call(this).prev('.' + this.$optionsA11['list-item']);
        return prev.length !== 0? prev : $(this.$navigationItemsA11[this.$navigationItemsLengthA11 - 1]);
    }

    function activeElement (f) {
        var next = f();
        disableAllItems.call(this);
        next.attr('aria-selected', 'true').attr('tabindex', '0').focus();
    }

    function moveRightOrDown () {
        activeElement.call(this, getNextItem.bind(this));
    }

    function moveLeftOrTop () {
        activeElement.call(this, getPrevItem.bind(this));
    }

    function keyDownHandler (e) {
        var keyCode = e.keyCode;

        if (keyCode === 39 || keyCode === 40) {
            moveRightOrDown.call(this);
            this.$optionsA11['move-forward-callback'] && this.$optionsA11['move-forward-callback'].call(this);
        }

        if (keyCode === 37 || keyCode === 38) {
            moveLeftOrTop.call(this);
            this.$optionsA11['move-downward-callback'] && this.$optionsA11['move-downward-callback'].call(this);
        }

        if (keyCode === 35 || keyCode === 36) {
            //here code to handle 'Home' and 'End' keys
        }

        if (keyCode === 13 || keyCode === 32) {
            this.$optionsA11['enter-action'] && this.$optionsA11['enter-action'].call(null, e.target);
        }
    }

    function setKeyHandlers () {
        this.$navigationPanelA11.on('keydown', keyDownHandler.bind(this));
    }

    return {
        init: init,
        setSpecialAttribute: setSpecialAttribute,
    };
});
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Video23', ['VideoUtils'], function(videoUtils) {
    'use strict';

    var $window = $(window);
    var popupConfig = null;
    var COOKIE_GROUP = 'C0002';
    var ONE_TRUST_BANNER_COOKIE = 'OptanonAlertBoxClosed';

    /**
     * Video component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;

        var shouldOpenPopup = this.$el.data('isPopup');

        if (shouldOpenPopup) {
            this.$playButton = this.$el.find('.' + this.classes.button);
            this.initPopup();
        } else {
            this.$player = this.$el.find('.' + this.classes.player);
            this.$parent = this.$el.parent().parent();
            this.$wrap = this.$el.find('.video__wrap');
            this.width = parseInt(this.$wrap.data('width'));
            this.height = parseInt(this.$wrap.data('height'));
            this.aspectRatio = this.height / this.width;
            $window.on('resize', this.resizeVideo.bind(this));
            this.resizeVideo();

            if (this.$el.parents('.tabs-ui').length) {
                $window.on('tab.changed', this.resizeVideo.bind(this));
            }
        }
        this.checkOneTrustGroups();
    }

    /**
     * Initialize popup for video
     */
    Component.prototype.initPopup = function() {
        popupConfig = {
            type: 'iframe',
            disableOn: 240,
            preloader: true,
            fixedContentPos: true,
            iframe: {
                patterns: {
                    youtube: {
                        index: 'youtube.com/',
                        id: 'v=',
                        src: ''
                    }
                },
                markup: videoUtils.getPopupMarkup(null)
            }
        };

        this.$playButton.magnificPopup(popupConfig);
    };

    Component.prototype.checkAdditionalGDPRConsent = function(value) {
        if (value === true) {
            this.updateVideoSrc();
        } else {
            this.handleYoutubeVideoFlow();
        }
    };

    Component.prototype.handleYoutubeVideoFlow = function() {
        var result = videoUtils.checkVideoSrcOrigin(this.getVideoSrc());
        if (result) { //video from youtube
            this.addGDPRVideoCover();
            this.registerOneTrustConsentEvent();
        } else {
            this.updateVideoSrc();
        }
    };

    Component.prototype.addGDPRVideoCover = function() {
        var shouldOpenPopup = this.$el.data('isPopup');
        if (!shouldOpenPopup) {
            this.$wrap.append(videoUtils.createGDPRMarkup(this.handleGDPRConsent.bind(this)));
        } else {
            this.addGDPRVideoCoverForPopup();
        }
    };

    Component.prototype.addGDPRVideoCoverForPopup = function() {
        var self = this;
        popupConfig.iframe.markup = videoUtils.getPopupMarkup(videoUtils.createGDPRMarkup(null).outerHTML);
        popupConfig.callbacks = {
            open: function() {
                var gdprBth = document.querySelector('.gdpr-button');
                gdprBth && gdprBth.addEventListener('click', self.handleGDPRConsent.bind(self));
            }
        };
        this.$playButton.magnificPopup(popupConfig);
    };

    Component.prototype.removeGDPRConsent = function() {
        var shouldOpenPopup = this.$el.data('isPopup');
        if (shouldOpenPopup) {
            this.removeGDPRVideoCoverForPopup();
        } else {
            this.removeGDPRVideoCover();
        }
        this.updateVideoSrc();
    };

    Component.prototype.removeGDPRVideoCoverForPopup = function() {
        popupConfig.iframe.markup = videoUtils.getPopupMarkup(null);
        popupConfig.callbacks = { open: null };
        $.magnificPopup.close();
    };

    Component.prototype.removeGDPRVideoCover = function() {
        var gdprCover = this.$wrap.find('.gdpr-video-cover');
        if (gdprCover.length) {
            gdprCover.remove();
        }
    };

    Component.prototype.checkOneTrustGroups = function() {
        var handleConsentCheck = function() {
            var result = window.OnetrustActiveGroups && window.OnetrustActiveGroups.includes(COOKIE_GROUP) || false;
            this.checkAdditionalGDPRConsent(result);
        }.bind(this);

        if (!window.OnetrustActiveGroups) {
            videoUtils.waitForCookieBanner(
                function() {
                    return window.OnetrustActiveGroups;
                },
                handleConsentCheck,
                100,
                5000
            );
        } else {
            handleConsentCheck();
        }
    };

    Component.prototype.oneTrustGroupsUpdatedHandler = function(event) {
        if (event.detail && event.detail.includes(COOKIE_GROUP)) {
            this.removeGDPRConsent();
            this.updateVideoSrc();
            if (this.bindOneTrustGroupsUpdatedHandler) {
                window.removeEventListener('OneTrustGroupsUpdated', this.bindOneTrustGroupsUpdatedHandler);
                this.bindOneTrustGroupsUpdatedHandler = null;
            }
        } else {
            console.warn('OneTrust ' + COOKIE_GROUP + ' group is not active');
        }
    };

    Component.prototype.registerOneTrustConsentEvent = function() {
        this.bindOneTrustGroupsUpdatedHandler = this.oneTrustGroupsUpdatedHandler.bind(this);
        window.addEventListener('OneTrustGroupsUpdated', this.bindOneTrustGroupsUpdatedHandler);
    };

    Component.prototype.updateVideoSrc = function() {
        var shouldOpenPopup = this.$el.data('isPopup');
        var videoSrc = this.getVideoSrc();
       if (shouldOpenPopup) {
            this.updatePopupVideoSrc(videoSrc);
        } else {
            this.updateInlineVideoSrc(videoSrc);
        }
    };

    Component.prototype.updatePopupVideoSrc = function(videoSrc) {
        popupConfig.iframe.patterns.youtube.src = videoSrc;
        this.$playButton.magnificPopup(popupConfig);
    };

    Component.prototype.updateInlineVideoSrc = function(videoSrc) {
        if (typeof videoSrc === 'string' && videoSrc.trim() !== '') {
            this.$player.attr('src', videoSrc);
        } else {
            console.error('Invalid video source:', videoSrc);
        }
    };

    Component.prototype.getVideoSrc = function() {
        var shouldOpenPopup = this.$el.data('isPopup');
        return shouldOpenPopup ? this.$playButton.data('mfp-src') : this.$wrap.data('src');
    };

    /**
     * Recalculate video size, when its width is greater than parent
     */
    Component.prototype.resizeVideo = function() {
        this.$wrap.css('padding-bottom', this.aspectRatio * 100 + '%');
    };

    Component.prototype.showCookieBanner = function() {
        var cookieBannerElement = document.getElementById('onetrust-banner-sdk');
        if (cookieBannerElement) {
            cookieBannerElement.style.display = 'block';
            cookieBannerElement.style.opacity = 1;
            cookieBannerElement.style.visibility = 'visible';
        }
        videoUtils.removeCookie(ONE_TRUST_BANNER_COOKIE, videoUtils.extractRootDomain(window.location.href));
        this.removeGDPRConsent();
    };

    Component.prototype.removeGDPRConsentHandler = function() {
        this.removeGDPRConsent();
    };

    Component.prototype.handleGDPRConsent = function() {
        var cookieBannerExists = videoUtils.getCookie(ONE_TRUST_BANNER_COOKIE);
        var callbackFunction = null;
        if (cookieBannerExists) {
            callbackFunction = this.removeGDPRConsentHandler.bind(this);
        } else {
            callbackFunction = this.showCookieBanner.bind(this);
        }

        this.updateGDPRConsent(callbackFunction);
    };

    Component.prototype.updateGDPRConsent = function(callback) {
        OneTrust.UpdateConsent('Category', COOKIE_GROUP + ':1')
            .then(callback)
            .catch(function(error) {
                console.error('Error updating consent for category:', error);
            });
    };

    Component.prototype.classes = {
        player: 'video__player',
        button: 'video__button'
    };

    Component.moduleName = 'Video 23';
    Component.selector = '.video-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('VideoUtils', [], function() {
    'use strict';

    function checkVideoSrcOrigin(src) {
        if (typeof src !== 'string') {
            return false;
        }
        var youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)/i;
        return youtubeRegex.test(src);
    }

    function removeCookie(cookieName, domain) {
        if (typeof cookieName !== 'string' || !/^[a-zA-Z0-9_-]+$/.test(cookieName)) {
            console.error('Invalid cookie name.');
            return;
        }

        var cookieExists = document.cookie.split(';').filter(function(item) {
            return item.trim().indexOf(cookieName + '=') === 0;
        }).length > 0;

        if (cookieExists) {
            var domainAttribute = '';
            if (domain && domain.length > 0) {
                domainAttribute = 'domain=' + domain + '; ';
            }

            document.cookie = cookieName + '=; path=/; expires=Thu, 01 Jan 1970 00:00:00 UTC;'; // to support dev and stage environments
            document.cookie = cookieName + '=; ' + domainAttribute + 'path=/; expires=Thu, 01 Jan 1970 00:00:00 UTC;';
        } else {
            console.warn('Cookie "' + cookieName + '" does not exist or is inaccessible.');
        }
    }

    function extractRootDomain(url) {
        try {
            if (typeof url !== 'string' || url.trim() === '') {
                console.error('Invalid input: URL must be a non-empty string.');
                return null;
            }

            var sanitizedUrl = DOMPurify.sanitize(url);

            var parsedUrl = new URL(sanitizedUrl);
            var hostname = parsedUrl.hostname;

            if (!hostname.startsWith('.')) {
                hostname = '.' + hostname;
            }

            return hostname;
        } catch (error) {
            console.error('Invalid URL or unsafe input:', error.message);
            return null;
        }
    }

    function getCookie(cookieName) {
        const cookies = document.cookie;
        const cookiesArray = cookies.split(';');

        for (const cookie of cookiesArray) {
            const [name, value] = cookie.split('=').map((c) => c.trim());
            if (name === cookieName) {
                return value;
            }
        }
        return null;
    }

    function createGDPRMarkup(GDPRButtonClickHandler) {
        var wrapperDiv = document.createElement('div');
        wrapperDiv.className = 'gdpr-video-cover';

        var titleDiv = document.createElement('div');
        titleDiv.className = 'gdpr-consent-text';
        titleDiv.innerHTML =
            'This content is hosted by a third party (youtube-nocookie.com). By showing the external content you accept the ' +
            '<a href="https://www.youtube.com/t/terms" target="_blank">terms and conditions</a>' +
            ' of youtube-nocookie.com.';

        var buttonDiv = document.createElement('div');
        buttonDiv.addEventListener('click', GDPRButtonClickHandler);
        buttonDiv.className = 'gdpr-button';
        buttonDiv.textContent = 'Show external content';

        var noteDiv = document.createElement('div');
        noteDiv.className = 'gdpr-note';
        noteDiv.textContent = '*Your choice will be saved in a cookie managed by us.';

        wrapperDiv.appendChild(titleDiv);
        wrapperDiv.appendChild(buttonDiv);
        wrapperDiv.appendChild(noteDiv);
        return wrapperDiv;
    }

    function getPopupMarkup(gdprConsentMarkup) {
        if (gdprConsentMarkup) {
            return '<div class="mfp-iframe-scaler">' +
                gdprConsentMarkup +
                '</div>';
        }

        return '<div class="mfp-iframe-scaler">' +
            '<div class="mfp-close"></div>' +
            '<iframe class="mfp-iframe" frameborder="0" border="0" scroll="no" allowfullscreen scrolling="no"></iframe>' +
            '</div>';
    }


    function waitForCookieBanner(apiCheckFn, callback, interval, timeout) {
        var startTime = Date.now();
        function checkAPI() {
            if (apiCheckFn()) {
                callback();
                return;
            }
            if (Date.now() - startTime > timeout) {
                console.error('Cookie Banner API did not load within the timeout period.');
                return;
            }
            setTimeout(checkAPI, interval);
        }
        checkAPI();
    }

    return {
        checkVideoSrcOrigin: checkVideoSrcOrigin,
        removeCookie: removeCookie,
        createGDPRMarkup: createGDPRMarkup,
        getPopupMarkup: getPopupMarkup,
        waitForCookieBanner: waitForCookieBanner,
        getCookie: getCookie,
        extractRootDomain: extractRootDomain
    };
});
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define('TwoLevelTabs23', ['jquery-plugins'], function () {
    'use strict';

    var classes = {
        firstLevelTabsWrapper: 'two-level-tabs__first-level-tabs-wrapper',
        firstLevelTabLink: 'two-level-tabs__first-level-tabs-link',
        secondLevelTabLink: 'two-level-tabs__second-level-tabs-link',
        firstLevelTabsList: 'two-level-tabs__first-level-tabs-list',
        secondLevelTabs: 'two-level-tabs__second-level-tabs',
        firstLevelTab: 'two-level-tabs__first-level-tabs-item',
        secondLevelTab: 'two-level-tabs__second-level-tabs-item',
        content: 'two-level-tabs__content-container',
        jstabs: 'js-second-tabs',
        active: 'active',
        open: 'open',
    };

    var events = {
        tabChange: 'tab.change',
    };

    var activatedComponents = [];

    /**
     * Two-Level Tabs
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$firstLevelTab = this.$el.find('.' + classes.firstLevelTab);
        this.$secondLevelTab = this.$el.find('.' + classes.secondLevelTab);
        this.$firstLevelTabsList = this.$el.find('.' + classes.firstLevelTabsList);
        this.$firstLevelTabsWrapper = this.$el.find('.' + classes.firstLevelTabsWrapper);
        this.$items = this.$el.find('.' + classes.jstabs);
        this.isInitialized = false;
        this.init();
        this.setEventListeners();
        activatedComponents.push(this);
    }

    Component.prototype.init = function () {
        var hash = window.location.hash;

        if (window.location.hash) {
            if (hash.indexOf('-') > -1) {
                var anchorCountry = hash.split('-').shift().substring(1);
                var anchorLanguage = hash.substring(1);
                this.selectFirstLevelInitialTab(anchorCountry);
                this.selectSecondLevelInitialTab(anchorLanguage);
            } else {
                var anchor = hash.substring(1);
                this.selectFirstLevelInitialTab(anchor);
            }
        }

        this.isInitialized = true;
    };

    Component.prototype.setEventListeners = function () {
        var self = this;

        this.$el.find('[data-target-id]').on('click', function () {
            var id = $(this).data('target-id');

            if ($(this).hasClass(classes.firstLevelTabLink)) {
                self.selectActiveTab(classes.firstLevelTabLink, id);
                self.showSecondLevelTabs(id);

                if (self.getDeviceType() !== 'desktop') {
                    // scroll to
                    if (self.$firstLevelTabsWrapper.hasClass(classes.open)) {
                        self.scrollToElement(self.$el);
                    }
                    // toggle open dropdown
                    self.$firstLevelTabsWrapper.toggleClass(classes.open);
                }
            }
            else if ($(this).hasClass(classes.secondLevelTabLink)) {
                self.selectActiveTab(classes.secondLevelTabLink, id);
                self.showContent(id);
            }
        });

        this.$el.on(events.tabChange, this.onTabChange.bind(this));
    };

    Component.prototype.selectActiveTab = function (tab, id) {
        this.$el.find('.' + tab + '[data-target-id=' + id + ']').parent().addClass(classes.active).siblings('li').removeClass(this.classes.active);
    };

    Component.prototype.selectFirstLevelInitialTab = function (anchor) {
        this.selectInitialTabByAnchor(this.$firstLevelTab, anchor, this.showSecondLevelTabs);
    };

    Component.prototype.selectSecondLevelInitialTab = function (anchor) {
        this.selectInitialTabByAnchor(this.$secondLevelTab, anchor, this.showContent);
    };

    Component.prototype.selectInitialTabByAnchor = function (tabs, anchor, callback) {
        var active = tabs.find('a[href="#' + anchor + '"]');
        var id = active.data('target-id');
        active.parent().addClass(classes.active).siblings().removeClass(classes.active);
        callback.call(this, id);
    };

    Component.prototype.showSecondLevelTabs = function (id) {
        this.$el.find('.' + classes.secondLevelTabs).removeClass(classes.active);
        var $secondLevelTabToShow = this.$el.find('.' + classes.secondLevelTabs + '[data-content-id=' + id + ']');
        $secondLevelTabToShow.addClass(classes.active);

        if ($secondLevelTabToShow && !this.isInitialized) {
            this.scrollToElement($secondLevelTabToShow);
        }
    };

    Component.prototype.showContent = function (id) {
        this.$el.find('.' + classes.content + '[data-content-id=' + id + ']').addClass(classes.active).siblings(':not(ul)').removeClass(classes.active);
    };

    Component.prototype.scrollToElement = function (elem) {
        const headerHeight = 150;

        $('html, body').animate({
            scrollTop: elem.offset().top - headerHeight
        }, 500);
    };

    Component.prototype.getDeviceType = function () {
        const viewportWidth = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);

        if (viewportWidth < 768) {
            return 'mobile';
        }

        return 'desktop';
    };

    Component.prototype.onTabChange = function (event, data) {
        var tabIndex = data.tab;
        var $currentTab = this.$items.eq(tabIndex);
        var currentTabId = $currentTab.data('content-id');
        this.$firstLevelTab.removeClass(classes.active).eq(tabIndex).addClass(classes.active);
        this.$firstLevelTab.find('.' + classes.secondLevelTabs).removeClass(classes.active);
        this.$firstLevelTab.find('.' + classes.secondLevelTabs + '[data-content-id=' + currentTabId + ']').addClass(classes.active);
        this.$items.removeClass(classes.active);
        $currentTab.addClass(classes.active);
        return false;
    };

    Component.prototype.classes = classes;
    Component.moduleName = 'TwoLevelTabs23';
    Component.activatedComponents = activatedComponents;
    Component.events = events;
    Component.selector = '.two-level-tabs-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
// eslint-disable-next-line max-params
define('TimelineSlider23', ['TabsUtil', 'utils-a11y', 'constants', 'utils-env', 'gradients'], function (TabsUtil, utilsA11y, constants, env, gradients) {
    'use strict';

    var $document = $(document),
        $html = $('html'),
        $window = $(window),
        $body = $('body');

    var classes = {
        item: '.timeline-slider-ui-23__slide',
        historyImage: '.timeline-slider-ui-23__view-more',
        historyImageContainer: '.timeline-slider-ui-23__image-container',
        historyGallery: '.timeline-slider-ui-23__popup',
        active: 'timeline-slider-ui-23--active',
        close: 'timeline-slider-ui-23--close',
        popup: '.timeline-slider-ui-23__popup',
        closePopupButton: '.timeline-slider-ui-23__popup-close',
        carouselItem: '.timeline-slider-ui-23__carousel-item',
        switcherCarousel: '.timeline-slider-ui-23__switcher-carousel',
        switcherButton: '.timeline-slider-ui-23__switcher-button',
        preloader: '.timeline-slider-ui-23__preloader',
        allyActive: 'ally-active',
        popupPrint: 'popup-print',
        printImage: 'print-image',
        tabPrev: '.timeline-slider-ui-23__button-prev.js-tabs-prev',
        tabNext: '.timeline-slider-ui-23__button-next.js-tabs-next',
        title: '.timeline-slider-ui-23__slide-title',
        slideDate: '.timeline-slider-ui-23__slide-date',
        transparent: 'transparent',
        breadcrumbs: '.breadcrumbs-ui',
        rteTextGradient: '.rte-text-gradient',
    };

    function Component($el) {
        this.$el = $el;

        this.$historyImage = this.$el.find(classes.historyImage);
        this.$imageContainer = this.$el.find(classes.historyImageContainer);
        this.$historyGallery = this.$el.find(classes.historyGallery);
        this.$closePopupButton = this.$el.find(classes.closePopupButton);
        this.$switcherCarousel = this.$el.find(classes.switcherCarousel);
        this.$switcherButtons = this.$el.find(classes.switcherButton);
        this.$preloader = this.$el.find(classes.preloader);
        this.$tabNext = this.$el.find(classes.tabNext);
        this.$tabPrev = this.$el.find(classes.tabPrev);
        this.$switcherNav = this.$el.find('.owl-nav');
        this.$historyImage.on('click', this.onButtonClick.bind(this));
        this.$closePopupButton.on('click', this.closePopup.bind(this));

        $window.on('tab.changed', this.onTabChanged.bind(this));
        $window.on('beforeprint', this.beforeprintHandler.bind(this));
        $document.on('keyup', this.keyupHandler.bind(this));
        this.$switcherCarousel.on('changed.owl.carousel', function (event) {
            this.onSwitcherItemChanged(event);
        }.bind(this));
        this.$historyGallery.on('load.owl.lazy', this.showPreloader.bind(this));
        this.$historyGallery.on('loaded.owl.lazy', this.hidePreloader.bind(this));
        this.$switcherCarousel.owlCarousel(this.switcherDefaultConfig);
        this.$switcherCarousel.trigger('refresh.owl.carousel');
        this.isLoaded = false;

        window.addEventListener('load', this.onLoad.bind(this));

        TabsUtil.call(this, $el, {
            items: $el.find(classes.item),
            verticalNavigation: true,
            scrollToTopOnTabChange: true,
            scrollToReservedSpace: function () {
                var breadcrumbs = document.querySelector(classes.breadcrumbs),
                    isBreadcrumbsPresent = breadcrumbs && !!breadcrumbs.clientHeight,
                    isBreadcrumbsHidden = !!document.querySelector(classes.breadcrumbs + '.hidden');
                // hidden breadcrumbs will be shown after scroll
                return isBreadcrumbsPresent || isBreadcrumbsHidden ? 150 : 100;
            },
        });

        this.$el.on('tab.loaded tab.change', function () {
            this.$items.eq(this.activeItem).addClass(classes.allyActive);
        }.bind(this));

        this.$items.on(constants.Events.transitionEnd, function () {
            this.$items.not('.' + this.classes.active).removeClass(classes.allyActive);
        }.bind(this));
    }

    Component.prototype = Object.create(TabsUtil.prototype);

    Component.prototype.onLoad = function() {
        // for some reason it's being called twice. Probably owl script change something after initial load
        if (this.isLoaded) { return; }
        this.prepareTitles.bind(this)();
        // gradient color ratios
        var N & DS_RIGHT_RATIO = 0.5;
        var N & DS_MIDDLE_RATIO = 1.4;
        var nodes = this.$el[0].querySelectorAll(classes.slideDate + ', ' + classes.rteTextGradient);
        var gradientText = new gradients.GradientText();
        gradientText.init(nodes, {rightRatio: N & DS_RIGHT_RATIO, middleRatio: N & DS_MIDDLE_RATIO});
        this.isLoaded = true;
    };

    Component.prototype.wcmModeChange = function (wcmMode) {
        wcmMode === 'preview' && this.setColorClass();
    };

    Component.prototype.onButtonClick = function (event) {
        event.preventDefault();
        var element = this.$imageContainer;
        var elementRect = element.get(0).getBoundingClientRect();
        var elementHeight = element.height();
        var absoluteElementTop = elementRect.top + window.scrollY;
        var middle = absoluteElementTop - window.innerHeight / 2 + elementHeight / 2;

        if (!this.$el.hasClass(classes.active)) {
            $('html, body').animate({ scrollTop: middle }, 1000);
        }

        this.openPopup(event);
    };

    Component.prototype.keyupHandler = function (event) {
        if (event.key === constants.Keys.esc) {
            this.closePopup();
        }
    };

    Component.prototype.openPopup = function (event) {        
        var $currentPopup = $(event.currentTarget).parent().next(classes.popup),
            $closePopupButton = $currentPopup.find(classes.closePopupButton);

        this.$currentHistoryImage = $currentPopup.find(classes.historyImage);
        this.$currentGallery = $currentPopup.find(classes.historyGallery);

        this.$el.addClass(classes.active);
        $body.addClass(classes.popupPrint);
        $body.addClass(constants.Classes.pinnedFilter);
        $html.addClass(constants.Classes.noscroll);
        this.$historyImage.attr('tabindex', -1);

        this.carouselItemLength = $currentPopup.find(classes.carouselItem).length;
        $closePopupButton.focus();

        this.initGallery();
        utilsA11y.handlePopupFocus($currentPopup);
    };

    Component.prototype.closePopup = function () {
        if (!this.$el.hasClass(classes.active)) {
            return;
        }

        this.$el.removeClass(classes.active).addClass(classes.close);
        this.$historyImage.removeAttr('tabindex');

        setTimeout(function () {
            $body.removeClass(classes.popupPrint);
            $body.removeClass(constants.Classes.pinnedFilter);
            $html.removeClass(constants.Classes.noscroll);

            !this.$el.hasClass(classes.active) && this.$el.scrollToSelector({
                duration: 300,
                reservedSpace: 156
            });

            this.refreshGallery();

            this.$el.removeClass(classes.close);
            this.$currentHistoryImage.focus();
        }.bind(this), 100);
    };

    Component.prototype.initGallery = function () {
        var config = this.carouselItemLength > 1 ? this.mainDefaultConfig : $.extend({}, this.mainDefaultConfig, {
            mouseDrag: false,
            touchDrag: false,
            nav: false,
            dots: false
        });

        if (this.$currentGallery.hasClass('owl-loaded')) {
            this.$currentGallery.trigger('refresh.owl.carousel');
        } else {
            this.$currentGallery.owlCarousel(config);
            this.enableTopSwitcher();
        }

    };

    Component.prototype.refreshGallery = function () {
        this.$currentGallery.trigger('to.owl.carousel', [0, 20]);
    };

    Component.prototype.onTabChanged = function () {
        if (env.isEditMode()) {
            return;
        }

        var activeNumber = this.$switcherButtons.filter('.' + this.classes.active).data('item');

        this.$switcherCarousel.trigger('to.owl.carousel', [activeNumber, 20]);
        this.activeBgColor = this.getBgColorClass(this.$items.eq(this.activeItem));

        this.setColorClass();
        this.enableTopSwitcher();
    };

    Component.prototype.onSwitcherItemChanged = function (event) {
        var activeNumber = event.item.index;
        this.$el.trigger('tab.change', { tab: activeNumber, skipFocus: true });

        this.$tabPrev.removeAttr('disabled');
        this.$tabNext.removeAttr('disabled');

        if (activeNumber + 1 >= event.item.count) {
            this.$tabNext.attr('disabled', 'disabled');
        } else {
            this.$tabNext.removeAttr('disabled');
        }

        if (activeNumber === 0) {
            this.$tabPrev.attr('disabled', 'disabled');
        } else {
            this.$tabPrev.removeAttr('disabled');
        }

        this.enableTopSwitcher();
    };

    Component.prototype.setColorClass = function () {
        var backgroundClass = this.getBgColorClass(this.$el);

        this.$el.removeClass(backgroundClass).addClass(this.activeBgColor);
    };

    Component.prototype.getBgColorClass = function ($element) {
        if (!$element) {
            return;
        }

        var classesArray = $element.attr('class').match(/bg-color[\w-]*\b/);

        return classesArray && classesArray.join(' ');
    };

    Component.prototype.showPreloader = function () {
        this.$preloader.removeClass(constants.Classes.hidden);
    };

    Component.prototype.hidePreloader = function () {
        this.$preloader.addClass(constants.Classes.hidden);
    };

    Component.prototype.beforeprintHandler = function() {
        if (!this.$el.hasClass(classes.active)) {
            this.$currentGallery.owlCarousel('destroy');
        }

        if (this.$el.hasClass(classes.active)) {
            this.addPrintImage();
        }
    };

    Component.prototype.addPrintImage = function() {
        var $printImage = $('.' + classes.printImage),
            src = this.$items.eq(this.activeItem).find('.owl-item.active .timeline-slider__carousel-image--desktop').attr('src');

        if (!$printImage.length) {
            $printImage = $('<img class="' + classes.printImage + '" />').attr('src', src);
            $body.append($printImage);

            return;
        }

        $printImage.attr('src', src);
    };

    Component.prototype.enableTopSwitcher = function() {
        var arrow = '<svg>\n' +
            '        <use xlink:href="/etc/designs/epam-core/images/sprites/sprite-redesign_27.svg#link-arrow-in-circle"></use>\n' +
            '    </svg>';
        var timeline = this.$el[0].querySelector('.owl-item.active .timeline-slider-ui-23__switcher-carousel-item p');
        this.$switcherNav = this.$el.find('.owl-nav');

        if (timeline && this.$switcherNav) {
            $(this.$switcherNav).css('width', timeline.clientWidth);

            var btnPrev = $(this.$switcherNav).find('.owl-prev');
            var btnNext = $(this.$switcherNav).find('.owl-next');

            btnPrev[0].innerHTML = btnNext[0].innerHTML = arrow;
        }
    };

    Component.prototype.prepareTitles = function() {
        var titles = this.$el.find(classes.title);

        titles.each(function(i, title) {
            $(title).css('max-width', $(title).prev().width());
        });
    };

    Component.prototype.mainDefaultConfig = {
        nav: true,
        center: true,
        items: 1,
        lazyLoad: true,
        lazyLoadEager: 0,
        rewind: false
    };

    Component.prototype.switcherDefaultConfig = {
        nav: true,
        center: true,
        items: 1,
        dots: false,
        rewind: false,
        touchDrag: false,
        mouseDrag: false
    };

    Component.moduleName = 'Timeline Slider 23';
    Component.selector = '.timeline-slider-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Timeline23', ['gradients'], function (gradients) {
    'use strict';

    /**
     * Timeline component
     * @param { jQuery } $el
     * @constructor
     */

    var classes = {
        year: '.timeline-ui-23__year',
    };

    function Component($el) {
        this.$el = $el;
        var N & DS_RIGHT_RATIO = 0.5;
        var N & DS_MIDDLE_RATIO = 1.4;
        var nodes = this.$el[0].querySelectorAll(classes.year);
        var gradientText = new gradients.GradientText();
        gradientText.init(nodes, {rightRatio: N & DS_RIGHT_RATIO, middleRatio: N & DS_MIDDLE_RATIO});
    }

    Component.moduleName = 'Timeline23';
    Component.selector = '.timeline-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Text23', ['utils', 'gradients'], function (utils, gradients) {
    'use strict';

    /**
     * Text component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        var gradientsConfig = {
            allNodesSelector: '.' + gradients.classes.RTE_TEXT_GRADIENT,
            overridenNodesSelector: '.' + this.classes.ecModeOverride + ' .' + gradients.classes.RTE_TEXT_GRADIENT,
            alwaysDarkNodesSelector: '.' + this.classes.mediaContent + ' .' + gradients.classes.RTE_TEXT_GRADIENT,
            alwaysDarkGradientText: new gradients.GradientText(),
            alwaysLightGradientText: new gradients.GradientText(),
            gradientText: new gradients.GradientText(),
            ecModeGradientText: new gradients.GradientText(),
            darkMode: gradients.modes.DARK,
            lightMode: gradients.modes.LIGHT,
            ecMode: gradients.modes.EC,
          };

        this.$el = $el;
        this.$el.find('table').wrap('<div class="' + this.classes.tableWrapper + '"></div>');
        utils.insertArrowPictureForLinks(this.$el);
        utils.applyTextGradients.call(this, gradientsConfig);
    }

    Component.prototype.classes = {
        tableWrapper: 'text__table-wrapper',
        ecModeOverride: 'ec-mode-override',
        mediaContent: 'media-content',
    };

    Component.moduleName = 'Text23';
    Component.selector = '.text-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

// eslint-disable-next-line max-params
define('Slider23', ['utils-env', 'ResponsiveImage23', 'utils', 'media', 'SliderUtils23', 'SliderClasses23', 'constants', 'gradients'], function(env, responsiveImage, utils, media, sliderUtils23, classes, constants, gradients) {
    'use strict';

    var configurationModes = {
        singleFullWidth: 'single-full-width',
        twoColumns: 'text-in-two-columns',
        textImage: 'text-and-image-in-two-columns',
    };

    var events = {
        video: {
            end: 'ended',
        },
        slider: {
            drag: 'drag.owl.carousel',
            translate: 'translate.owl.carousel',
            stopAutoplay: 'stop.owl.autoplay',
            destroy: 'destroy.owl.carousel',
            playAutoplay: 'play.owl.autoplay',
            next: 'next.owl.carousel',
            prev: 'prev.owl.carousel',
            resized: 'resized.owl.carousel',
            initialized: 'initialized.owl.carousel'
        },
    };

    var readySliderEvent = new CustomEvent(constants.Events.sliderReady);
    var resizedEvent = new CustomEvent(constants.Events.sliderResized);

    var threshold = 0.5;
    var gradientsConfig = {
        allNodesSelector: classes.clonedSlideSelector + ' .' + gradients.classes.RTE_TEXT_GRADIENT,
        overridenNodesSelector: classes.ecModeOverride + gradients.classes.RTE_TEXT_GRADIENT,
        alwaysDarkNodesSelector: classes.mediaContent + ' ' + classes.clonedSlideSelector + ' .' + gradients.classes.RTE_TEXT_GRADIENT,
        alwaysDarkGradientText: new gradients.GradientText(),
        alwaysLightGradientText: new gradients.GradientText(),
        gradientText: new gradients.GradientText(),
        ecModeGradientText: new gradients.GradientText(),
        darkMode: gradients.modes.DARK,
        lightMode: gradients.modes.LIGHT,
        ecMode: gradients.modes.EC,
    };

    function Component($parentNode) {
        this.timerId = null;
        this.$parentNode = $parentNode;
        this.$el = $parentNode.find('.' + classes.owlRoot);
        this.isEditMode = env.isEditMode();
        this.itemCount = this.$el.children().length;
        this.$sliderSlide = this.$el.find('.' + classes.sliderSlide);
        this.singleSlideContentContainer = this.$el.find('.' + classes.singleSlideContentContainer);
        this.playspeed = this._setPlaySpeed();
        this.currentCount = 1;
        this.slidesCount = this.$parentNode.data('slides-count');
        this.slidesCountDesktop = Math.ceil(this.slidesCount / 2);
        this.dotsColor = this.$parentNode.data('dots-color');
        this.dotActiveColor = this.$parentNode.data('dot-active-color');
        this.contentWidth = $parentNode.data('content-width');
        this.configuration = $parentNode.data('configuration');
        this.autorotationByVideo = $parentNode.data('autorotation');
        this.isDragging = false;
        this.isMobile = media.currentMode().lessThan(media.modes.Desktop);
        this.activeSlide = this.$el.find('.owl-item.active');
        this.endVideoHandler = this.endVideoCallback.bind(this);
        this.endVideoHandlerMobile = this.endVideoCallbackMobile.bind(this);
        this.$stopAutoRotate = false;
        this._timer = null;
        this._isSliderMoving = false; //stop some process if video is playing
        this._playedVideo = null; //indicate if video was activated and played;
        this.userAction = false; //indicate if user interacted with slider
        this.isHasVideo = this.$el.find(' > .slider__slide video');
        this.$observerCallback = this.getObserverCallback();
        this.$observerSecondCallback = this.autorotationByVideo ? this.freeze.bind(this) : this.freezeSlider.bind(this);
        this.revealCurrentCarousel(); // this is used for Slider 2 style (desktop/mobile have different slides)
        this.adjustContentWidth(); // this is used for Slider 1 style (content width setup)
        sliderUtils23.setDotsHiddenText.call(this);
        this.setEcModeForDots = sliderUtils23.setEcModeForSlider.call(this).bind(this);
        this.$handlers = {
            mouseleave: [],
            mouseenter: [],
            run: function(arr) {
                arr.forEach(function(func) {
                    func.call(this);
                }.bind(this));
            }.bind(this),
        };
        this.init();
        utils.applyShadowOnImage(this.$el, this.$el.find('.single-slide__image--mobile'));
        this.adjustSliderContainersHeight = sliderUtils23.adjustSliderContainersHeight.bind(this);
        this.$hasCTALink = this.$el.find(classes.ctaLink).length > 0;
        this.windowWidth = window.innerWidth;
    }

    Component.prototype.init = function() {
        sliderUtils23.markNewActiveVideoTypeRegardingTheme.call(this);
        this.stopSliderWhenMouseOver();
        this.initEvents();
        this.initNavigationEvents();
    };

    Component.prototype._setPlaySpeed = function() {
        var speed = this.$parentNode.data('playSpeed') >= 0 ? this.$parentNode.data('playSpeed') : 5;
        return speed * 1000;
    };

    Component.prototype._clearTimer = function() {
        if (this._timer) {
            clearTimeout(this._timer);
        }
    };

    Component.prototype.observerHandler = function(entries) {
        entries.forEach(function(entry) {
            if (entry.intersectionRatio >= threshold) {
                this.$observerCallback();
            } else {
                this.$observerSecondCallback();
            }
        }.bind(this));
    };

    Component.prototype.getSliderConfig = function() {
        return $.extend({}, this.defaultConfig, this._sliderConfig(), {
            dotsData: true,
            onChanged: this.setCurrentSlide.bind(this),
            dotClass: classes.dot + ' ' + this.dotsColor,
            navContainerClass: classes.navigationContainer + ' ' + this.dotsColor,
        });
    };

    Component.prototype._sliderConfig = function() {
        /*
        has fixed speed
         */
        if (this.playspeed && !this.autorotationByVideo) {
            var config = {
                autoplay: true,
                autoplayTimeout: this.playspeed,
                autoplayHoverPause: true,
                onInitialized: this.onInitializedHandler.bind(this),
                onTranslate: this.onTranslateHandler.bind(this),
            };

            if (media.currentMode().lessThan(media.modes.Desktop)) {
                return $.extend(config, {
                    onDrag: this.onDragHandler.bind(this),
                    onTranslated: this.onTranslatedMobile.bind(this),
                });
            }

            return $.extend(config, {
                onTranslated: this.onTranslated.bind(this),
                onDrag: this.navigationArrowsClickHandler.bind(this),
            });
        }

        /*
        running autoplay manually; track when video is finished
         */
        if (this.playspeed && this.autorotationByVideo) {
            var config2 = {
                autoplay: false,
                autoplayHoverPause: false,
                onTranslate: this.onTranslateHandlerV2.bind(this),
                onInitialized: this.onInitializedHandler.bind(this),
                onDrag: function() {
                    this._clearTimer();
                }.bind(this),
            };

            if (media.currentMode().lessThan(media.modes.Desktop)) {
                return $.extend(config2, {
                    onDrag: function() {
                        this._clearTimer();
                        this.onDragHandler();
                    }.bind(this),
                    onTranslated: this.onTranslatedV2Mobile.bind(this),
                });
            }

            return $.extend(config2, {
                onTranslated: this.onTranslatedV2.bind(this),
                onDrag: function() {
                    this._clearTimer();
                    this.navigationArrowsClickHandler();
                }.bind(this),
            });
        }

        /*
        case when speed = 0
         */
        return {
            autoplay: false,
            onInitialized: this.onInitializedHandler.bind(this),
            onTranslate: this.onTranslateHandler.bind(this),
            onTranslated: this.onTranslated.bind(this),
        };
    };

    Component.prototype.getObserverCallback = function() {
        if (this.playspeed === 0) {
            return this.releaseSliderZeroSpeed.bind(this);
        }

        return this.autorotationByVideo ? this.autoRotationByVideo.bind(this) : this.releaseSlider.bind(this);
    };

    Component.prototype.onDragHandler = function() {
                this.userAction = true;
    };

    Component.prototype.onTranslateHandler = function() {
        this._isSliderMoving = true;
        if (this.isHasVideo) {
            this.pauseAllVideos();
        }
    };

    Component.prototype.onTranslateHandlerV2 = function() {
        this._isSliderMoving = true;
        if (this.isHasVideo) {
            this._clearTimer();
            this.pauseAllVideos();
        }
    };

    Component.prototype.onTranslated = function() {
        this._isSliderMoving = false;
        this.playActiveVideo();
    };

    Component.prototype.onTranslatedMobile = function() {
        this._isSliderMoving = false;
        this.playActiveVideo();

        if (this.userAction) {
            this.$el.trigger(events.slider.stopAutoplay);
        }
    };

    Component.prototype.onTranslatedV2 = function() {
        this._isSliderMoving = false;
        this.autoRotationByVideo();
        this.prepareVideoToPlayAgain();
    };

    Component.prototype.onTranslatedV2Mobile = function() {
        this._isSliderMoving = false;

        if (this.userAction) {
            this.autoRotationByVideoMobile();
        } else {
            this.autoRotationByVideo();
            this.prepareVideoToPlayAgain();
        }
    };

    Component.prototype.onInitializedHandler = function() {
        this.initSliderButtons();
        sliderUtils23.setDotsPosition.call(this);
        sliderUtils23.updatePagination.call(this);

        if (this.$el.parents('.tabs-ui-23').length) {
            requestAnimationFrame(function() {
                this.$el.trigger('refresh.owl.carousel');
            }.bind(this));
        }

        this.playActiveVideo();
        utils.applyTextGradients.call(this, gradientsConfig);
    };

    Component.prototype.syncClonedVideo = function(_activeVideo) {
        if (_activeVideo) {
            var src = _activeVideo.getAttribute('src');
            var _clonedVideo = sliderUtils23.getClonedVideoByUrl.call(this, src, _activeVideo);
            if (_clonedVideo) {
                _clonedVideo.currentTime = _activeVideo.duration === _activeVideo.currentTime ? 0 : _activeVideo.currentTime;
                _clonedVideo.play();
            }
        }
    };

    /*
    check if video reached end, set position from last frame to first one
     */
    Component.prototype.prepareVideoToPlayAgain = function() {
        if (this._playedVideo === null) {
            return;
        }
        var clonedVideo = sliderUtils23.getClonedVideoByUrl.call(this, this._playedVideo.getAttribute('src'), this._playedVideo);
        if (clonedVideo) {
            if (this._playedVideo.duration === this._playedVideo.currentTime) {
                this._playedVideo.currentTime = clonedVideo.currentTime = 0;
                this._playedVideo = null;
            }
        }
    };

    Component.prototype.revealCurrentCarousel = function() {
        if (this.configuration !== configurationModes.twoColumns) {
            this.$el = this.$parentNode.find('.' + classes.owlRoot);
            this.itemCount = this.$el.children().length;
            return;
        }

        if (media.currentMode().lessThan(media.modes.Desktop)) {
            this.$el = this.$parentNode.find('.' + classes.owlRoot + classes.mobileMod);
            this.$parentNode.find('.' + classes.owlRoot + classes.desktopMod).hide();
        } else {
            this.$el = this.$parentNode.find('.' + classes.owlRoot + classes.desktopMod);
            this.$parentNode.find('.' + classes.owlRoot + classes.mobileMod).hide();
        }
        this.$el.show();
        this.itemCount = this.$el.children().length;
    };

    Component.prototype.onLoadHandler = function() {
        this.initSliding(env.isEditMode()); // init sliding after all videos loaded

        if (this.$el[0] !== undefined) {
            // TODO right now slider is used to display single slide in that case slider itself doesn't init so some logic may be broken
            this._observer = new IntersectionObserver(this.observerHandler.bind(this), {
                threshold: threshold,
                rootMargin: '-100px 0px 0px 0px',
            });
            this._observer.observe(this.$el[0]);
        }

        if (
          !this.autorotationByVideo && this.configuration === configurationModes.singleFullWidth ||
          this.configuration === configurationModes.singleFullWidth && this.playspeed === 0
        ) {
            this.setInfiniteLoopForAllVideos();
        }
    };

    Component.prototype.onResizeHandler = function(forceUpdate) {
        // check if window width has changed
        if (forceUpdate || window.innerWidth !== this.windowWidth) {
            // Update the window width
            this.windowWidth = window.innerWidth;
            // run script
            sliderUtils23.changeContentHeightToAuto.call(this);
            sliderUtils23.setDotsPosition.call(this);
            this.adjustContentWidth();

            if (this.isMobile !== media.currentMode().lessThan(media.modes.Desktop)) {
                this.isMobile = media.currentMode().lessThan(media.modes.Desktop);
                this.onChangeMediaQuery();  // is used for Slider 2nd Style to re-initialize carousel with new slides. Only works when change desktop<=>mobile
            }

            if (this.$hasCTALink) {
                sliderUtils23.hideCTALinks.call(this);
                if (this.timerId) {
                    clearTimeout(this.timerId);
                }
                this.timerId = setTimeout(function() {
                    this.adjustSliderContainersHeight();
                    sliderUtils23.showCTALinks.call(this);
                }.bind(this), 150);
            }
        }
    };

    Component.prototype.tabChangedCallback = function() {
        var $tabItem = this.$parentNode.closest('.tabs-23__item');

        if (!$tabItem.hasClass('active')) {
            return;
        }

        this.onResizeHandler(true);

        var rootWidth = this.$el.width();
        var tolerance = 2;
        var broken = this.$el.find('.owl-item').filter(function() {
            var width = this.offsetWidth;
            return width === 0 || Math.abs(rootWidth - width) > tolerance;
        }).length > 0;

        if (broken) {
            requestAnimationFrame(function() {
                this.$el.trigger('refresh.owl.carousel');
            }.bind(this));
        }
    };

    Component.prototype.initEvents = function() {
        window.addEventListener('load', this.onLoadHandler.bind(this));
        window.addEventListener('resize', utils.debounceExtend(this.onResizeHandler.bind(this), 300));

        $(window).on(constants.Events.sliderResize, function (event, slider) {
            if (slider === this.$el.parent('.slider-ui-23')[0]) {
                this.onResizeHandler(true);
            }
        }.bind(this));

        this.$el.on('refreshed.owl.carousel', function () {
            if (this.$hasCTALink) {
                sliderUtils23.hideCTALinks.call(this);
                if (this.timerId) {
                    clearTimeout(this.timerId);
                }
                this.timerId = setTimeout(function() {
                    this.adjustSliderContainersHeight();
                    sliderUtils23.showCTALinks.call(this);
                }.bind(this), 150);
            }
        }.bind(this));

        $(document.body).on(constants.Events.themeSwitch, this.themeSwitchEventHandler.bind(this));

        if (this.$el.parents('.tabs-ui-23').length > 0) {
            $(window).on(constants.Events.tabChanged, this.tabChangedCallback.bind(this));
        }

        if (this.$handlers.mouseenter.length === 0) {
            return;
        }

        this.$parentNode.on('mouseenter ', function() {
            this.$handlers.mouseenter.forEach(function(func) {
                func.call(this);
            }.bind(this));
        }.bind(this));

        this.$parentNode.on('mouseleave', function() {
            this.$handlers.mouseleave.forEach(function(func) {
                func.call(this);
            }.bind(this));
        }.bind(this));

        this.$el.on(events.slider.resized, function () {
            document.dispatchEvent(resizedEvent);
        });

        this.$el.on(events.slider.initialized, function () {
            document.dispatchEvent(readySliderEvent);
        });
    };

    Component.prototype.themeSwitchEventHandler = function() {
        sliderUtils23.markNewActiveVideoTypeRegardingTheme.call(this);
        this.updateVideoEventsAfterSwitchMode();
        this.setVideoClasses();
        this.setOwlItemsMode();
    };

    /*
    stop slider when cursor over slider, but only when video is presented
     */
    Component.prototype.additionalEvents = function() {
        this.$parentNode.on('mouseenter ', function() {
            this.$stopAutoRotate = true;
        }.bind(this));
        this.$parentNode.on('mouseleave', function() {
            this.$stopAutoRotate = false;
            if (!this._isSliderMoving) {
                this.autoRotationByVideo();
            }
        }.bind(this));
    };

    Component.prototype.stopSliderWhenMouseOver = function() {
        if (this.autorotationByVideo && this.playspeed > 0) {
            this.$handlers.mouseenter.push(function() {
                this.$stopAutoRotate = true;
            });

            this.$handlers.mouseleave.push(function() {
                this.$stopAutoRotate = false;
                if (!this._isSliderMoving) {
                    this.autoRotationByVideo();
                }
            });
        } else if (this.playspeed > 0) {
            this.$handlers.mouseenter.push(function() {
                this.$el.trigger(events.slider.stopAutoplay);
            });

            this.$handlers.mouseleave.push(function() {
                this.$el.trigger(events.slider.playAutoplay);
            });
        }
    };

    Component.prototype.onChangeMediaQuery = function() {
        if (this.configuration === configurationModes.twoColumns) {
            this.switchOwl();
        }

        if (this.configuration === configurationModes.singleFullWidth && this.isMobile) {
            sliderUtils23.changeContentWidthToAuto.call(this);
        }
    };

    Component.prototype.switchOwl = function() {
        var rootHeight = this.$el.height();
        // this crazy jquery height tricks help us switch two owl carousels as smoothly as possible.
        // Css media queries does not switch simultanuosly, that lead to blinks on resize.
        this.$parentNode.find('.' + classes.owlRoot + classes.mobileMod).height(rootHeight);
        this.$parentNode.find('.' + classes.owlRoot + classes.desktopMod).height(rootHeight);
        this.$el.trigger(events.slider.destroy).removeClass('owl-carousel owl-loaded');
        this.$el.find('.owl-stage-outer').children().unwrap();
        this.revealCurrentCarousel();
        this.$el.removeAttr('style');
        sliderUtils23.setDotsHiddenText.call(this);
        this.initSliding(env.isEditMode());
    };

    Component.prototype.adjustContentWidth = function() {
        if (this.configuration === configurationModes.singleFullWidth && !this.isEditMode) {
            if (this.isMobile) {
                this.contentWidth = 100;
            }
            this.singleSlideContentContainer.width(this.contentWidth + '%');
        }
    };

    Component.prototype.setCurrentSlide = function(event) {
        if (event.page.index === -1) {
            this.currentCount = 1;
        } else {
            this.currentCount = event.page.index + 1;
        }
        var formatted = (this.currentCount < 10 ? '0' : '') + this.currentCount;
        this.$el.parents('.' + classes.sliderContainer).find('.' + classes.currentPage).text(formatted);
    };

    Component.prototype.toggleActiveDotClass = function($el, state) {
        $el.toggleClass(this.dotsColor, !state).toggleClass(this.dotActiveColor, state);
    };

    Component.prototype.initSliding = function(isEditMode) {
        var shouldRunSlider = !isEditMode && this.itemCount > 1;
        if (!shouldRunSlider) {
            return;
        }

        this.$el.owlCarousel(this.getSliderConfig());
        this.carouselData = this.$el.data('owl.carousel');
        this.dots = this.$el.find('.' + classes.dot);
        if (this.playspeed) {
            this.$el.find('.' + classes.dot).on('click', this.pauseAllVideos.bind(this));
        }
        this.reloadClonedImages();
        sliderUtils23.initDotsColors.call(this);

        this.setVideoClasses();
        this.setEcModeForDots(0);

        this.$el.on(events.slider.translate, function(event) {
            this.setVideoClasses();
            this.setEcModeForDots(event.page.index);
        }.bind(this));

        this.$el.on(events.slider.next + ' ' + events.slider.prev + ' ' + events.slider.drag, function() {
            gradientsConfig.alwaysDarkGradientText.stop();
            gradientsConfig.alwaysLightGradientText.stop();
            gradientsConfig.gradientText.stop();
            gradientsConfig.ecModeGradientText.stop();
            utils.applyTextGradients.call(this, gradientsConfig);
        }.bind(this));

        this.setOwlItemsMode();
    };

    Component.prototype.initNavigationEvents = function() {
        var rootContainer = this.$el.parents('.' + classes.sliderContainer);
        var leftArrowSelector = rootContainer.find(classes.leftArrowSelector);
        var rightArrowSelector = rootContainer.find(classes.rightArrowSelector);
        this.$navigationArrousContainer = this.$parentNode.find('.' + classes.navigationContainer);

        leftArrowSelector.click(function() {
            this.$el.trigger(events.slider.prev);
        }.bind(this));
        rightArrowSelector.click(function() {
            this.$el.trigger(events.slider.next);
        }.bind(this));

        this.$navigationArrousContainer.on('click', '.slider-navigation-arrow', function() {
            this.navigationArrowsClickHandler();
        }.bind(this));
    };

    Component.prototype.navigationArrowsClickHandler = function () {
        this._observer && this._observer.disconnect();
        this.$handlers.run(this.$handlers.mouseenter);
        this.$parentNode.off('mouseenter');
        this.$parentNode.off('mouseleave');
        this.$navigationArrousContainer.off('click');
    };

    Component.prototype.setOwlItemsMode = function() {
        setTimeout(function() {
            var owlItems = this.$el.find('.owl-item');

            owlItems.each(function() {
                var video = $(this).find(classes.videoContainer);

                var isDarkMode = $(document.body).hasClass(classes.darkMode);
                var isLightMode = $(document.body).hasClass(classes.lightMode);
                var darkClass = classes.darkOwlItem + ' ' + classes.darkVideo;
                var lightClass = classes.lightOwlItem + ' ' + classes.lightVideo;

                if (video.length !== 0) {
                    var darkVideoSrc = $(video).attr('data-src-dark-video');
                    var lightVideoSrc = $(video).attr('data-src-light-video');

                    if (darkVideoSrc && lightVideoSrc) {
                        $(this).toggleClass(darkClass, isDarkMode);
                        $(this).toggleClass(lightClass, isLightMode);
                    } else if (darkVideoSrc) {
                        $(this).addClass(darkClass).removeClass(lightClass);
                    } else if (lightVideoSrc) {
                        $(this).addClass(lightClass).removeClass(darkClass);
                    }
                }
            });
        }.bind(this), 0);
    };

    Component.prototype.setVideoClasses = function() {
        var loadVideo = function(video, mode, isActiveSlide) {
            var darkVideoSrc = $(video).attr('data-src-dark-video');
            var lightVideoSrc = $(video).attr('data-src-light-video');
            var videoSrc = $(video).attr('src');
            var isVideoSrcChanged = false;
            var $navigation = this.$el.next('.slider__navigation');
            var $progressbar = this.$el.find('.slider__progress-bar');

            var applyVideo = function (isDarkMode) {
                var currentVideoSrc = isDarkMode ? darkVideoSrc : lightVideoSrc;
                if (videoSrc !== currentVideoSrc) {
                    $(video).attr('src', currentVideoSrc);
                    isVideoSrcChanged = true;
                }
                $navigation.toggleClass(classes.darkVideo, isDarkMode).toggleClass(classes.lightVideo, !isDarkMode);
                $progressbar.toggleClass(classes.darkVideo, isDarkMode).toggleClass(classes.lightVideo, !isDarkMode);
            };

            if (darkVideoSrc && lightVideoSrc) {
                applyVideo(mode === 'dark');
            } else if (darkVideoSrc) {
                applyVideo(true);
            } else if (lightVideoSrc) {
                applyVideo(false);
            }

            if (isVideoSrcChanged) {
                video.load();
            }

            if (isActiveSlide) {
                video.play();
            }
        }.bind(this);

        var loadDarkOrLightVideo = function(jQueryVideoElements, isActiveSlide) {
            var darkVideo = jQueryVideoElements[0];
            var lightVideo = jQueryVideoElements[1];
            var isDarkMode = $(document.body).hasClass(classes.darkMode);
            var isLightMode = $(document.body).hasClass(classes.lightMode);

            if (isDarkMode) {
                loadVideo(darkVideo, 'dark', isActiveSlide);
            } else if (isLightMode) {
                loadVideo(lightVideo, 'light', isActiveSlide);
            }
        };

        setTimeout(function() {
            var activeSlide = this.$el.find('.owl-item.active');
            var navigation = this.$el.next('.slider__navigation');
            var progressbar = this.$el.find('.slider__progress-bar');
            var nextSlide = activeSlide.next();

            var activeSlideVideos = activeSlide.find(classes.videoContainer);
            var nextSlideVideos = nextSlide.find(classes.videoContainer);

            if (activeSlideVideos.length) {
                loadDarkOrLightVideo(activeSlideVideos, true);
            } else {
                navigation.removeClass(classes.darkVideo + ' ' + classes.lightVideo);
                progressbar.removeClass(classes.darkVideo + ' ' + classes.lightVideo);                
            }

            if (nextSlideVideos.length) {
                this.$el.one(events.slider.translate, function() {
                    loadDarkOrLightVideo(nextSlideVideos, false);
                });
            }
        }.bind(this), 0);
    };

    Component.prototype.initSliderButtons = function() {
        this.$el.find('.' + classes.rightArrow).click(this.$observerSecondCallback.bind(this));
        this.$el.find('.' + classes.leftArrow).click(this.$observerSecondCallback.bind(this));
    };

    Component.prototype.wcmModeChange = function(wcmMode) {
        if (this.carouselData) {
            this.carouselData.destroy();
        }
        this.initSliding(wcmMode === 'edit');
    };

    Component.prototype.setInfiniteLoopForAllVideos = function() {
        var allVideos = this.$el.find(classes.videoContainer);
        for (var i = 0; i < allVideos.length; i++) {
            allVideos[i].loop = true;
        }
    };

    /*
    stop video play and slide rotation
     */
    Component.prototype.freeze = function() {
        this._clearTimer();
        this.pauseAllVideos();
    };

    Component.prototype.freezeSlider = function() {
        this.$el.trigger(events.slider.stopAutoplay);
        this.pauseAllVideos();
    };

    Component.prototype.pauseAllVideos = function() {
        var videos = this.$el.find(classes.videoContainer);
        for (var i = 0; i < videos.length; i++) {
            videos[i].pause();
        }
    };

    Component.prototype.playActiveVideo = function(video) {
        var activeVideo = video || this.getActiveVideo();
        if (activeVideo) {
            this.syncClonedVideo(activeVideo);
            activeVideo.play();
        }
    };

    Component.prototype.releaseSlider = function() {
        this.playActiveVideo();
        this.$el.trigger(events.slider.playAutoplay, [this.playspeed]);
    };

    Component.prototype.releaseSliderZeroSpeed = function() {
        this.playActiveVideo();
    };

    Component.prototype.reloadClonedImages = function() {
        var clonedImg = this.$el.find('.cloned .responsive-image-ui-23');
        if (clonedImg.length === 1) {
            new responsiveImage(clonedImg);
        }
    };

    Component.prototype.getActiveVideo = function() {
        var video = this.$el.find(classes.activeVideo);

        if (video.length > 0) {
            return video[0];
        }
        return null;
    };

    Component.prototype.endVideoCallback = function() {
        var activeVideo = this.getActiveVideo();
        if (!this.$stopAutoRotate) {
            this._playedVideo = activeVideo;
            this.$el.trigger(events.slider.next);
        } else {
            this.playActiveVideo(activeVideo);
            this.autoRotationByVideo();
        }
    };

    Component.prototype.endVideoCallbackMobile = function() {
        this.autoRotationByVideoMobile();
    };

    Component.prototype.updateVideoEventsAfterSwitchMode = function() {
        var activeVideo = this.getActiveVideo();
        if (activeVideo) {
            var allVideoUnderActiveSlide = this.$el.find(classes.videoTags);
            for (var i = 0; i < allVideoUnderActiveSlide.length; i++) {
                allVideoUnderActiveSlide[i].removeEventListener(events.video.end, this.endVideoHandler);
            }
            activeVideo.addEventListener(events.video.end, this.endVideoHandler, { once: true });
        }
    };

    // only if autorotation By Video is On
    Component.prototype.autoRotationByVideo = function() {
        var activeVideo = this.getActiveVideo();
        /*
        if active item is video waiting for video end
         */
        if (activeVideo) {
            activeVideo.removeEventListener(events.video.end, this.endVideoHandler);
            activeVideo.addEventListener(events.video.end, this.endVideoHandler, { once: true });
            this.playActiveVideo(activeVideo);
        } else {
            /*
            if active slide not a video run timer after that slide will be switched
             */
            this._clearTimer();
            this._timer = setTimeout(function() {
                if (!this.$stopAutoRotate) {
                    this.$el.trigger(events.slider.next);
                }
            }.bind(this), this.playspeed);
        }
    };

    Component.prototype.autoRotationByVideoMobile = function() {
        if (this.userAction) {
            var activeVideo = this.getActiveVideo();
            if (activeVideo) {
                activeVideo.removeEventListener(events.video.end, this.endVideoHandlerMobile);
                activeVideo.addEventListener(events.video.end, this.endVideoHandlerMobile, { once: true });
                this.playActiveVideo(activeVideo);
            }
        } else {
            this.autoRotationByVideo();
        }
    };

    Component.prototype.defaultConfig = {
        loop: true,
        center: false,
        autoplay: false,
        playspeed: 0,
        items: 1,
        loadedClass: classes.sliderLoaded,
        dragClass: classes.sliderDrag,
        dotClass: classes.dot,
        dotsClass: classes.progressBar,
        responsiveRefreshRate: 0,
        lazyLoad: true,
        lazyLoadEager: 3,
        nav: false,
        responsive: {
            0:{
                smartSpeed: 500,
            },
            992: {
                smartSpeed: 750,
            }
        }
    };

    Component.selector = '.slider-ui-23';
    Component.moduleName = 'Slider23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
// eslint-disable-next-line max-params
define('SliderUtils23',
    ['SliderClasses23'],
    function (classes) {
        'use strict';

        var configurationModes = {
            singleFullWidth: 'single-full-width',
            twoColumns: 'text-in-two-columns',
            textImage: 'text-and-image-in-two-columns',
        };

        var MENU_HEIGHT = 52; // from css file of Header Component
        function changeContentHeightToAuto() {
            this.$el.find('.' + classes.singleSlideContentContainer).each(function () {
                $(this).css('height', '');
            });
        }

        function showCTALinks() {
            if (!this.isEditMode) {
                var links = this.$el.find(classes.ctaLink);
                for (var i = 0; i < links.length; i++) {
                    $(links[i]).removeClass(classes.invisible);
                }
            }
        }

        function hideCTALinks() {
            var links = this.$el.find(classes.ctaLink);
            for (var i = 0; i < links.length; i++) {
                $(links[i]).addClass(classes.invisible);
            }
        }

        function adjustSliderContainersHeight() {
            var realContainers = this.$el.find(classes.singleSlideContentSelector);
            if (realContainers.length > 0) {
                var maxContainerHeight = 0;
                for (var i = 0; i < realContainers.length; i++) {
                    var itemHeight = realContainers[i].clientHeight;
                    if (maxContainerHeight < itemHeight) {
                        maxContainerHeight = itemHeight;
                    }
                }

                var allContainers = this.$el.find('.' + classes.singleSlideContentContainer);
                requestAnimationFrame(function () {
                    for (i = 0; i < allContainers.length; i++) {
                        $(allContainers[i]).css('height', maxContainerHeight + 'px');
                    }
                });
            }
        }

        function changeContentWidthToAuto() {
            requestAnimationFrame(function () {
                this.$el.find('.' + classes.singleSlideContentContainer).each(function () {
                    $(this).css('width', '');
                });
            }.bind(this));
        }

        /**
         * add text for slider dots
         * @data-dot: owl-carousel internal prop. (see official docs for more info)
         */
        function setDotsHiddenText() {
            for (var i = 0; i < this.$sliderSlide.length; i++) {
                var slideNumber = i + 1;
                var singleCellSlideText = this.$sliderSlide[i].querySelector('.layout-box__wrapper');
                var singleSlideWithPlainText = this.$sliderSlide[i].querySelector('.text-ui');
                var twoCellSlideText = this.$sliderSlide[i].querySelector(classes.twoCellsSlideContent);
                var slideButtons = this.$sliderSlide[i].querySelector('.button');
                var a11yTextForSlideWithButtons = '';

                if (slideButtons) {
                    var mobileButtonTitle = slideButtons.querySelector('.button__content--mobile');
                    a11yTextForSlideWithButtons = this.$sliderSlide[i].textContent.replace(mobileButtonTitle.textContent, '');
                }

                var text = '';
                if (singleCellSlideText && slideButtons || twoCellSlideText && slideButtons) {
                    text = '<span class="rs-only"> Slide ' + slideNumber + ': ' + a11yTextForSlideWithButtons + '</span>';
                    $(this.$sliderSlide[i]).attr('data-dot', text);
                } else if (singleCellSlideText) {
                    text = '<span class="rs-only"> Slide ' + slideNumber + ': ' + singleCellSlideText.textContent + '</span>';
                    $(this.$sliderSlide[i]).attr('data-dot', text);
                } else if (twoCellSlideText) {
                    text = '<span class="rs-only"> Slide ' + slideNumber + ': ' + twoCellSlideText.textContent + '</span>';
                    $(this.$sliderSlide[i]).attr('data-dot', text);
                } else if (singleSlideWithPlainText) {
                    text = '<span class="rs-only"> Slide ' + slideNumber + ': ' + singleSlideWithPlainText.textContent + '</span>';
                    $(this.$sliderSlide[i]).attr('data-dot', text);
                }
            }
        }

        function setDotsPosition() {
            requestAnimationFrame(function () {
                if (this.$el.hasClass(classes.singleSlider) && this.$el.hasClass(classes.sliderPositionContentSide)) {
                    setContentSide.call(this, classes.singleSlideContentContainer, 0);
                }

                if (this.$el.hasClass(classes.sliderPositionContentSide)) {
                    if (this.$el.find(classes.twoCellsSlideUi).hasClass(classes.twoCellsSlideContentLeft)) {
                        setContentSide.call(this, classes.twoCellsSlideContent, 0, '.two-cells-slide__content-left');
                    }

                    if (this.$el.find(classes.twoCellsSlideUi).hasClass(classes.twoCellsSlideContentRight)) {
                        setContentSide.call(this, classes.twoCellsSlideContent, 0, '.two-cells-slide__content-right');
                    }
                }
            }.bind(this));
        }

        function initDotsColors() {
            if (this.dotsColor === this.dotActiveColor) {
                return;
            }
            this.toggleActiveDotClass(this.dots.filter(classes.active), true);

            this.$el.on('translated.owl.carousel', function () {
                setTimeout(function () {
                    if (!this.isDragging) {
                        this.setDotsPosition();
                        setDotsPosition.call(this);
                    }
                }.bind(this), 50);
            }.bind(this));
            this.$el.on('drag.owl.carousel', function () {
                this.isDragging = true;
            }.bind(this));
            this.$el.on('dragged.owl.carousel', function () {
                this.isDragging = false;
            }.bind(this));
            this.$el.on('changed.owl.carousel', function () {
                this.toggleActiveDotClass(this.dots, false);
                this.toggleActiveDotClass(this.dots.filter(classes.active), true);
            }.bind(this));
        }

        // check if user can see slider on screen
        function isOnScreen() {
            var windowTop = $(window).scrollTop(),
                windowBottom = windowTop + $(window).height(),
                elTop = this.$el.offset().top,
                elMiddle = elTop + this.$el.outerHeight() / 2;
            return !(windowTop + MENU_HEIGHT > elMiddle || elMiddle > windowBottom);
        }

        function setContentSide(sliderType, leftPosition, contentSide) {
            var activeContentItem = this.$el.find('.owl-item.active ' + (contentSide ? contentSide : '') + ' ' + sliderType)[0];

            if (activeContentItem) {
                var $nav = this.$el.find('.' + classes.progressBar);
                $nav.css({ left: '' });
                var navOffset = $nav.offset().left;
                var activeContentElement = activeContentItem.firstElementChild ? activeContentItem.firstElementChild : activeContentItem;
                var contentPosition = activeContentElement.getBoundingClientRect().left;
                var contentLeftPadding = parseInt(window.getComputedStyle(activeContentElement, null).getPropertyValue('padding-left'));
                $nav.css({ left: contentPosition + leftPosition + contentLeftPadding - navOffset + 'px' });
            }
        }

        function updatePagination() {
            if (this.isEditMode) {
                return;
            }

            var overalSlidesCount = this.slidesCount;

            if (this.configuration === configurationModes.twoColumns) {
                overalSlidesCount = this.isMobile ? this.slidesCount : this.slidesCountDesktop;
            }

            var totalCount = overalSlidesCount.toString().padStart(2, '0');
            this.$el.parents('.' + classes.sliderContainer).find('.' + classes.sumPage).text('/ ' + totalCount);
        }

        function getClonedVideoByUrl(path, activeVideo) {
            var _cloneVideo = this.$el.find('.owl-item .background-video[src="' + path + '"]');
            if (_cloneVideo.length) {
                for (var i = 0; i < _cloneVideo.length; i++) {
                    if (!_cloneVideo[i].isSameNode(activeVideo)) {
                        return _cloneVideo[i];
                    }
                }
            }
            return null;
        }

        function setEcModeForSlider() {
            var notClonedItem = this.$el.find('.single-slide-ui');
            var parent = this.$el.parent('.slider-ui-23');
            var removeEcMode = function () {
                var ecModeItem = parent.find('.slider-ui-23__owl-root.ec-mode-override');
                ecModeItem.removeClass('ec-mode-override');
            };
            return function (idx) {
                removeEcMode.call(this);
                var item = notClonedItem[idx];
                var isHasEcMode = $(item).hasClass('ec-mode-override');
                if (isHasEcMode) {
                    this.$el.addClass('ec-mode-override');
                }
            };
        }

      /*
      light/dark mode in some cases has separate video
       */
      function markNewActiveVideoTypeRegardingTheme() {
          var activeVideos = this.$el.find('.' + classes.allActiveVideos);
          if (activeVideos.length === 0) {
              return;
          }

          setTimeout(function() {
            activeVideos.removeClass(classes.allActiveVideos);
            var isDarkMode = $(document.body).hasClass('dark-mode');
            if (isDarkMode) {
                $('.dark-background-video').addClass(classes.allActiveVideos);
            } else {
                $('.light-background-video').addClass(classes.allActiveVideos);
            }
          }, 300);
      }

        return {
            changeContentHeightToAuto: changeContentHeightToAuto,
            changeContentWidthToAuto: changeContentWidthToAuto,
            setDotsHiddenText: setDotsHiddenText,
            setDotsPosition: setDotsPosition,
            initDotsColors: initDotsColors,
            isOnScreen: isOnScreen,
            updatePagination: updatePagination,
            getClonedVideoByUrl: getClonedVideoByUrl,
            setEcModeForSlider: setEcModeForSlider,
            adjustSliderContainersHeight: adjustSliderContainersHeight,
            showCTALinks: showCTALinks,
            hideCTALinks: hideCTALinks,
            markNewActiveVideoTypeRegardingTheme: markNewActiveVideoTypeRegardingTheme,
        };
    });

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

// eslint-disable-next-line max-params
define('SliderClasses23', [], function() {
    'use strict';

    return {
        sliderContainer: 'slider-ui-23',
        progressBar: 'slider__progress-bar',
        owlRoot: 'slider-ui-23__owl-root',
        desktopMod: '--desktop',
        mobileMod: '--mobile',
        navigationContainer: 'slider__navigation',
        pagination: 'slider__pagination',
        sumPage: 'slider__pagination--sum-page',
        currentPage: 'slider__pagination--current-page',
        leftArrow: 'slider__left-arrow slider-navigation-arrow',
        rightArrow: 'slider__right-arrow slider-navigation-arrow',
        leftArrowSelector: '.slider__left-arrow',
        rightArrowSelector: '.slider__right-arrow',
        dot: 'slider__dot',
        sliderSlide: 'slider__slide',
        active: '.active',
        sliderDrag: 'slider--drag',
        sliderLoaded: 'slider--loaded',
        expanded: 'slider--expanded',
        twoCellsSlideUi: '.two-cells-slide-ui',
        singleSlideUi: 'single-slide-ui',
        singleSlider: 'slider--single',
        singleSlideContent: 'single-slide__content',
        singleSlideContentContainer: 'single-slide__content-container',
        singleSlideContentSelector: '.owl-item:not(.cloned) .single-slide__content-container',
        clonedSlideSelector: '.owl-item.cloned',
        twoCellsSlideContent: '.two-cells-slide__content',
        sliderPositionContentSide: 'slider-position-content-side',
        twoCellsSlideContentLeft: 'two-cells-slide__content-left',
        twoCellsSlideContentRight: 'two-cells-slide__content-right',
        videoContainer: '.background-video',
        activeVideo: '.owl-item.active .background-video.active-video',
        videoTags: '.owl-item.active .background-video',
        tabsComponentActiveTab: '.tabs-23__item.active',
        allActiveVideos: 'active-video',
        ecModeOverride: '.owl-item.cloned .ec-mode-override .',
        mediaContent: '.media-content',
        ctaLink: '.slider-cta-link',
        invisible: 'invisible',
        darkMode: 'dark-mode',
        lightMode: 'light-mode',
        darkOwlItem: 'dark-owl-item',
        lightOwlItem: 'light-owl-item',
        darkVideo: 'dark-video',
        lightVideo: 'light-video',
    };
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ShareToSocialConstants', ['jquery-plugins'], function () {
    'use strict';

    var classes = {
        common: {
            print: '.js-print',
            email: '.js-email-share',
            copy: '.js-copy-link',
            preference: '.js-preference-link',
        },
        menu: {
            link: '.share-menu__link',
            notice: '.share-menu__notice',
        },
        popup: {
            container: '.share-popup__container',
            button: '.share-popup__share-button',
            link: '.share-popup__link',
            title: '.share-popup__item-title',
            notice: '.share-popup__notice',
        },
    };

    var text = {
        copyText: CQ.I18n.getMessage('component.share-to-social.copy-link'),
        copiedText: CQ.I18n.getMessage('component.share-to-social.link-copied')
    };

    var mobileDevice = 991;
    var headerPlaceholder = 72;
    var shortUrl = location.href.match(/[^http(s)?://www.].+[\.$]/gi)[0];
    var noticeVisibilityDelay = 2000;

    var SOCIAL_ICONS = {
        fb: 'facebook',
        tw: 'twitter',
        li: 'linkedin',
    };

    return {
        classes: classes,
        text: text,
        mobileDevice: mobileDevice,
        headerPlaceholder: headerPlaceholder,
        shortUrl: shortUrl,
        noticeVisibilityDelay: noticeVisibilityDelay,
        SOCIAL_ICONS: SOCIAL_ICONS,
    };
});

define('ShareToSocialUtils', ['utils-share'], function (share) {
    'use strict';

    var shareToSocial = function (event) {
        event.preventDefault();
        share.go($(this).data());
    };

    var emailSharingLink = function (btn) {
        var subject = encodeURIComponent(btn.data('subject')),
            body = encodeURIComponent(location.href);

        return 'mailto:?subject=' + subject + '&body=' + body;
    };

    var copyToClipboard = function (newClip) {
        navigator.clipboard.writeText(newClip);
    };

    return {
        shareToSocial: shareToSocial,
        emailSharingLink: emailSharingLink,
        copyToClipboard: copyToClipboard,
    };
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('SharePopup23', ['ShareToSocialConstants', 'ShareToSocialUtils', 'utils-share'], function (constants, shareToSocialUtils, share) {
    'use strict';
    /**
     * Share To Social popup
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$container = this.$el.find(constants.classes.popup.container);
        this.$links = this.$el.find(constants.classes.popup.link);
        this.$button = this.$el.find(constants.classes.popup.button);
        this.$menu = this.$el.find(constants.classes.popup.container);
        this.toggleMenu();
        this.setSocialLinks();
        this.setPrintButton();
        this.setEmailButton();
        this.setCopyLinkButton();
    }

    Component.prototype.toggleMenu = function () {
        var self = this;
        var toggled = false;
        this.$button
            .off()
            .on('click', function () {
                var currentSectionOffsetTop = self.$el.offset().top - constants.headerPlaceholder;
                var isMobile = window.innerWidth <= constants.mobileDevice;
                if (isMobile) {
                    toggled = !toggled;
                    self.$menu.stop().slideToggle();
                    $(this).attr('aria-expanded', toggled);

                    if (toggled) {
                        $('html, body').animate({ scrollTop: currentSectionOffsetTop }, 300);
                    }
                }
            });
    };

    Component.prototype.setSocialLinks = function () {
        var $socialLinks = this.$links
            .not(constants.classes.common.print)
            .not(constants.classes.common.email)
            .not(constants.classes.common.copy)
            .not(constants.classes.common.preference);
        $socialLinks.on('click', shareToSocialUtils.shareToSocial);
        $socialLinks.each(function () {
            var iconType = $(this).attr('data-type');
            var ariaLabel = constants.SOCIAL_ICONS[iconType];
            ariaLabel && $(this).attr('aria-label', ariaLabel);
            $(this).find(constants.classes.popup.title).text(ariaLabel);
            var href = share.getLink($(this).data());
            href && $(this).attr('href', href);
        });
    };

    Component.prototype.setPrintButton = function () {
        var $printButton = this.$links.filter(constants.classes.common.print);
        $printButton.on('click', function () {
            window.print();
        });
    };

    Component.prototype.setEmailButton = function () {
        var $emailButton = this.$links.filter(constants.classes.common.email);
        $emailButton.click(function () {
            $('<a />')
                .attr('href', shareToSocialUtils.emailSharingLink($emailButton))
                .get(0)
                .click();
        });
    };

    Component.prototype.setCopyLinkButton = function () {
        var $copyButton = this.$links.filter(constants.classes.common.copy);
        var $notice = this.$el.find(constants.classes.popup.notice);
        $copyButton.on('click', function () {
            shareToSocialUtils.copyToClipboard(location.href);
            var isMobile = window.innerWidth <= constants.mobileDevice;
            var $title = $(this).find(constants.classes.popup.title);

            if (isMobile) {
                $title.text(constants.text.copiedText);
                setTimeout(function() {
                    $title.text(constants.text.copyText);
                }, constants.noticeVisibilityDelay);
            } else {
                $notice.fadeIn();
                setTimeout(function() {
                    $notice.fadeOut();
                }, constants.noticeVisibilityDelay);
            }
        });
    };

    Component.moduleName = 'Share To Social 23';
    Component.selector = '.share-popup-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ShareMenu23', ['ShareToSocialConstants', 'ShareToSocialUtils', 'utils-share'], function (constants, utils, share) {
    'use strict';
    /**
     * Share To Social list
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$links = this.$el.find(constants.classes.menu.link);
        this.setSocialLinks(this);
        this.setPrintButton(this);
        this.setEmailButton(this);
        this.setCopyLinkButton(this);
    }

    Component.prototype.setSocialLinks = function () {
        var $socialLinks = this.$links
            .not(constants.classes.common.print)
            .not(constants.classes.common.email)
            .not(constants.classes.common.copy)
            .not(constants.classes.common.preference);
        $socialLinks.on('click', utils.shareToSocial);
        $socialLinks.each(function () {
            var iconType = $(this).attr('data-type');
            var ariaLabel = constants.SOCIAL_ICONS[iconType];
            ariaLabel && $(this).attr('aria-label', ariaLabel);
            var href = share.getLink($(this).data());
            href && $(this).attr('href', href);
        });
    };

    Component.prototype.setPrintButton = function () {
        var $printButton = this.$links.filter(constants.classes.common.print);
        $printButton.on('click', function () {
            window.print();
        });
    };

    Component.prototype.setEmailButton = function () {
        var $emailButton = this.$links.filter(constants.classes.common.email);
        $emailButton.click(function () {
            $('<a />')
                .attr('href', utils.emailSharingLink($emailButton))
                .get(0)
                .click();
        });
    };

    Component.prototype.setCopyLinkButton = function () {
        var $copyButton = this.$links.filter(constants.classes.common.copy);
        var $notice = this.$el.find(constants.classes.menu.notice);
        $copyButton.off().on('click', function () {
            utils.copyToClipboard(location.href);
            $notice.fadeIn();
            setTimeout(function() {
                $notice.fadeOut();
            }, constants.noticeVisibilityDelay);
        });
    };

    Component.moduleName = 'Share To Social 23';
    Component.selector = '.share-menu-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Section', ['utils', 'media'], function (utils, media) {
    'use strict';

    var CLASSES = {
        SECTION_IMAGE: '.section__image',
        PARALLAX_WRAPPER: '.section-ui__parallax-wrapper.parallax-wrapper',
        ANIMATION_RENDERER: '.section-ui__animation-renderer',
        EC_MODE: 'ec-mode',
    };

    function Component($el) {
        this.$el = $el;
        this.$body = $('body');
        this.$imageContainer = this.$el[0].querySelector(CLASSES.ANIMATION_RENDERER);
        this.imageName = $el.attr('data-animation-name');
        this.hideOnMobile = $el.attr('data-hide-on-mobile');
        this.isEditMode = $el.is('[is-edit-mode]');
        this.isDesktop = media.currentMode().greaterThan(media.modes.Tablet);
        this.continuum = this.$body.hasClass(CLASSES.EC_MODE);
        this.init();
    }

    Component.prototype.init = function () {
        utils.applyShadowOnImage(this.$el, this.$el.find(CLASSES.SECTION_IMAGE), this.$el.find(CLASSES.PARALLAX_WRAPPER).length);
        this.applyAnimation();
    };

    Component.prototype.setImage = function(desktop, mobile) {
        var image = '';

        if (this.isDesktop) {
            image = desktop;
        } else if (!this.hideOnMobile) {
            image = mobile;
        }

        return image || '';
    };

    Component.prototype.getFileName = function () {
        switch (this.imageName) {
            case 'style1':
                return this.setImage('Circle_Blur_Style2_Desktop', 'Circle_Blur_Style5_Mobile');
            case 'style2':
                return this.setImage('Circle_Blur_Style5_Desktop', 'Circle_Blur_Style5_Mobile');
            case 'style3':
                return this.setImage('Circle_Blur_Style5_Desktop');
            case 'style4':
                return this.setImage('Circle_Blur_Style2_Desktop', 'Circle_Blur_Style2_Mobile');
            case 'style5':
                return this.setImage('Circle_Blur_Style5_Desktop', 'Circle_Blur_Style5_Mobile');
            case 'style6':
                return this.setImage(this.continuum ? 'Main_Blur_Style1_EC_Desktop' : 'Main_Blur_Style1_Desktop', this.continuum ? 'Main_Blur_Style1_EC_Mobile' : 'Main_Blur_Style1_Mobile');
            case 'style7':
                return this.setImage('Main_Blur_Style2_V1_Desktop', 'Main_Blur_Style2_V1_Mobile');
            case 'style8':
            case 'style9':
                return this.setImage('Main_Blur_Style2_V1_LM_Desktop', 'Main_Blur_Style2_V1_LM_Desktop');
            case 'style10':
                return this.setImage('Main_Blur_Style2_V2_Desktop', 'Main_Blur_Style2_V2_Mobile');
            case 'style11-1':
                return this.setImage('Main_Blur_Style3_Desktop', 'Main_Blur_Style3_Mobile');
            case 'style11-2':
                return this.setImage('Main_Blur_Style3_Desktop', 'Main_Blur_Style1_Mobile');
            case 'style12':
                return this.setImage('Circle_Blur_Style4_Desktop', 'Circle_Blur_Style1_Mobile');
            case 'style13':
                return this.setImage('Circle_Blur_Style1_Desktop', 'Circle_Blur_Style4_Mobile');
            case 'style14':
                return this.setImage('Main_Blur_Style2_V2_Desktop');
            case 'style15':
                return this.setImage('Main_Blur_Style2_V2_Desktop', 'Main_Blur_Style3_Mobile');
            case 'style16':
                return this.setImage('Main_Blur_Style2_V1_Desktop');
            default:
                return '';
        }
    };

    Component.prototype.applyAnimation = function() {
        var file = this.getFileName();

        if (this.imageName && file.length && !this.isEditMode) {
            bodymovin.loadAnimation({
                container: this.$imageContainer,
                renderer: 'canvas',
                loop: true,
                path: '/etc/designs/epam-com/json-animations/metamorphosis/' + file + '.js',
                rendererSettings: {
                    className: 'animation__object',
                    viewBoxOnly: true,
                }
            });
        }
    };

    Component.moduleName = 'Section';
    Component.selector = '.section-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Search23', ['utils', 'utils-dust', 'utils-env', 'constants'], function (utils, dust, env, constants) {
    'use strict';

    var $window = $(window);

    var classes = {
        form: '.search-results__panel',
        field: '.search__field',
        container: '.search-results__items',
        more: '.search-results__view-more',
        exception: '.search-results__exception-message',
        error: '.search-results--error',
        emptyResult: '.search-results--empty-result',
        counter: '.search-results__counter',
        input: '.frequent-searches__input',
        searchInput: '.search__input',
        searchWithoutResultsInput: '.search-without-result__input',
        titleLink: '.search-results__title-link',
        autoCorrectMessage: '.search-results__auto-correct-message',
        autoCorrectTotal: '.search-results__auto-correct-total',
        autoCorrectTerm: '.search-results__auto-correct-term',
        opened: 'opened',
    };

    /**
     * Search Results component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$form = $el.find(classes.form);
        this.$field = $el.find(classes.field);
        this.$searchInput = this.$field.find(classes.searchWithoutResultsInput);
        this.$query = $el.find(classes.searchInput);
        this.$input = this.$form.find(classes.input);
        this.defaultPlaceholder = this.$input.attr('placeholder');
        this.$container = $el.find(classes.container);
        this.$counter = $el.find(classes.counter);
        this.$preloader = $el.find('.' + constants.Classes.preloader);
        this.$viewMore = $el.find(classes.more);
        this.$exceptionMessages = $el.find(classes.exception);
        this.$autoCorrectMessage = $el.find(classes.autoCorrectMessage);
        this.$autoCorrectTerm = this.$autoCorrectMessage.find(classes.autoCorrectTerm);
        this.$autoCorrectTotal = this.$autoCorrectMessage.find(classes.autoCorrectTotal);
        this.$errorMessage = this.$exceptionMessages.filter(classes.error);
        this.$emptyResultMessage = this.$exceptionMessages.filter(classes.emptyResult);
        this.isAuthor = env.isAuthor();
        this.configPath = $el.data('config-path');
        this.openEl = this.openEl.bind(this);
        this.closeEl = this.closeEl.bind(this);
        this.$form.on('submit', this.submit.bind(this));
        this.$viewMore.on('click', this.loadMoreResults.bind(this));
        $window.on('scroll', this.loadResultsOnScroll.bind(this));
        $window.on('popstate', this.refreshResult.bind(this));

        this.init();
    }

    Component.prototype.refreshResult = function () {
        var searchParameter = this.getParameters().q;
        var urlParameter = utils.getQueryParameters(location.href.replace(location.hash, '')).q;

        if (searchParameter !== urlParameter) {
            this.cleanResult();
            this.init();
        }
    };

    Component.prototype.init = function () {
        this.$input.on('focus', this.openEl).on('keyup', this.openEl);
        this.$searchInput.on('focus', this.openEl).on('keyup', this.openEl);
        this.updateForm();
        this.loadResults(this.getParameters());
    };

    Component.prototype.toggleEl = function () {
        var inputValue = $(document).find('.frequent-searches-23--hidden');
        this.$form.toggleClass(classes.opened, !inputValue.length);
        this.$field.toggleClass(classes.opened, !inputValue.length);
    };

    Component.prototype.openEl = function () {
        this.toggleEl();
        $window.on('click', this.closeEl);
    };

    Component.prototype.closeEl = function (event) {
        if (event && this.$input.is(event.target)) {
            return;
        }

        if (event && this.$searchInput.is(event.target)) {
            return;
        }

        this.toggleEl();
        $window.off('click', this.closeEl);

    };

    Component.prototype.updateElState = function (state) {
        if (!state) {
            this.$searchInput.off('keydown');
            this.$input.off('keydown');
            return;
        }

        this.clearElState();
    };

    Component.prototype.clearElState = function () {
        this.$searchInput.off('keydown');
        this.$searchInput.attr('placeholder', this.defaultPlaceholder);
        this.$input.off('keydown');
        this.$input.attr('placeholder', this.defaultPlaceholder);
    };

    Component.prototype.getParameters = function (offset) {
        return {
            q: this.$query.val().trim(),
            offset: offset || 0,
            config: this.configPath,
            bf: ['events', 'news']
        };
    };

    Component.prototype.updateForm = function () {
        var location = window.location,
            query = utils.getQueryParameters(location.href.replace(location.hash, '')).q || '';
        this.$query.val(query);
    };

    Component.prototype.loadResults = function (parameters) {
        if (!parameters.q){
            this.$query.val('');
            return;
        }
        $.ajax({
            url: this.config.searchUrl,
            data: parameters,
            beforeSend: this.toggleLoadingState.bind(this, true),
            complete: this.toggleLoadingState.bind(this, false),
            success: this.updateSearchResults.bind(this, parameters),
            error: this.showErrorMessage.bind(this)
        });
    };

    Component.prototype.loadMoreResults = function (event) {
        event && event.preventDefault();

        var offset = this.$container.children().length,
            parameters = this.getParameters(offset);

        if (event) {
            parameters.shouldFocusOnResult = true;
        }
        this.loadResults(parameters);
    };

    Component.prototype.loadResultsOnScroll = function () {
        if (this.loading || !this.shouldLoadOnScroll) {
            return;
        }

        var windowHeight = $window.height(),
            windowOffset = $window.scrollTop(),
            lastResultOffset = this.$container.children().last().offset().top;

        if (windowHeight + windowOffset > lastResultOffset) {
            this.loadMoreResults();
        }
    };

    Component.prototype.toggleLoadingState = function (loading) {
        loading && this.$viewMore.addClass(constants.Classes.hidden);
        this.$preloader.toggleClass(constants.Classes.hidden, !loading);
        this.loading = loading;
    };

    Component.prototype.showErrorMessage = function () {
        this.$errorMessage.removeClass(constants.Classes.hidden);
    };

    Component.prototype.showAutoCorrectMessage = function (response) {
        this.$autoCorrectMessage.removeClass(constants.Classes.hidden);
        this.$autoCorrectTotal.text(response.suggestedResultTotal);
        this.$autoCorrectTerm.text(response.suggestedQuery);
        this.$autoCorrectTerm.attr('href', this.getLink(response.suggestedQuery));
    };

    Component.prototype.updateSearchResults = function (parameters, response) {
        var total = response.total,
            result = response.result.length && response.result || response.suggestedResult,
            isFirstLoad = parameters.offset === 0,
            hasMoreResults = total > parameters.offset + this.config.limit;

        this.shouldLoadOnScroll = isFirstLoad && hasMoreResults;

        isFirstLoad && this.showResultMessage(parameters.q, total);
        response.suggestedResultTotal && this.showAutoCorrectMessage(response);
        dust.append('search-results', {
            items: result,
            isAuthor: this.isAuthor
        }, this.$container);

        this.$viewMore.toggleClass(constants.Classes.hidden, isFirstLoad || !hasMoreResults);
        parameters.shouldFocusOnResult && this.$container.find(classes.titleLink).eq(parameters.offset).focus();
    };

    Component.prototype.showResultMessage = function (query, total) {
        this.$counter.text(total ? this.getResultMessage(query, total) : '');
        if (total){
            this.$counter.removeClass(constants.Classes.hidden).focus();
            return;
        }
        this.$emptyResultMessage.removeClass(constants.Classes.hidden);
    };

    Component.prototype.getResultMessage = function (query, total) {
        var key = total === 1 ? 'component.search-results.found-single-result' : 'component.search-results.found-multiple-results';
        return CQ.I18n.getMessage(key, [query, total]);
    };

    Component.prototype.submit = function (e) {
        e.preventDefault();

        this.cleanResult();
        var parameters = this.getParameters();

        this.updateUrl(parameters);
        this.loadResults(parameters);
    };

    Component.prototype.cleanResult = function () {
        this.$counter.addClass(constants.Classes.hidden);
        this.$container.empty();
        this.$exceptionMessages.addClass(constants.Classes.hidden);
        this.$autoCorrectMessage.addClass(constants.Classes.hidden);
        this.$viewMore.addClass(constants.Classes.hidden);
    };

    Component.prototype.updateUrl = function (parameters) {
        if (parameters.q !== utils.getQueryParameters(window.location.href).q){
            window.history.pushState({}, '', this.getLink(parameters.q));
        }
    };

    Component.prototype.getLink = function (parameter) {
        return window.location.pathname + '?q=' + encodeURIComponent(parameter);
    };

    Component.prototype.config = {
        searchUrl: '/services/search/global',
        limit: 10
    };

    Component.moduleName = 'Search 23';
    Component.selector = '.search-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ResponsiveImage23', ['require', 'media', 'utils', 'imager'], function (require, media) {
    'use strict';

    var $window = $(window);

    /**
     * Responsive Image component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$placeholder = this.$el.find('.' + this.classes.placeholder);
        this.data = $.extend({}, this.$placeholder.data(), this.$el.data());
        this.hideOnMobile = this.$el.hasClass(this.classes.hideOnMobile);
        this.zoomOnHover = this.$el.hasClass(this.classes.zoomOnHover);
        this.isDownloaded = false;
        this.$el.on('renderImage', function () {
            this.render();
        }.bind(this));

        if (this.shouldBeShown()) {
            this.render();
        }

        $window.on('resize', require('utils').debounce(this.render.bind(this), 100));
    }

    /**
     * Checks is responsive image shown or hidden in current window
     * @returns {boolean}
     */
    Component.prototype.shouldBeShown = function () {
        if (require('utils-env').isEditMode()) {
            return true;
        }

        return this.data.width !== 0 &&
            (media.currentMode().greaterThan(media.modes.WideMobile) || !this.hideOnMobile);
    };

    /**
     * Set max width, if it is defined
     * @param {{ width: number, widthUnits: string }} data
     */
    Component.prototype.setMaxWidth = function (data) {
        data.width ? this.$img.css({maxWidth: data.width + data.widthUnits}) : this.initContainerStyles();
    };

    /**
     * Render image on the page
     */
    Component.prototype.render = function () {
        var shouldNotRender = this.isDownloaded || !this.shouldBeShown() || !this.$placeholder.is(':visible');

        if (shouldNotRender) {
            $window.one('tab.changed', this.render.bind(this));
            return;
        }

        var options = {};
        if (this.zoomOnHover) {
            options = {
                beforeImagesReplaced: this.initContainerStyles.bind(this),
                onImagesReplaced: this.setContainerStyles.bind(this),
            }; 
        }

        require('imager').create(this.$placeholder, options);
        this.isDownloaded = true;
        this.$img = this.$el.find('.' + this.classes.img);
        this.$img.attr('title', this.data.title);
        this.setMaxWidth(this.data);
    };

    Component.prototype.setContainerStyles = function () {
        this.$img.css({width: 'fit-content'});
    };

    Component.prototype.initContainerStyles = function () {
        this.$img.css({width: '100%'});
    };

    Component.prototype.classes = {
        placeholder: 'responsive-image__placeholder',
        img: 'image-container',
        hideOnMobile: 'responsive-image--hide-on-mobile',
        zoomOnHover: 'zoom-on-hover'
    };

    Component.selector = '.responsive-image-ui-23';
    Component.moduleName = 'Responsive Image 23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define('RelatedVacancies23', ['animations'], function (animations) {
    'use strict';

    /**
     * Related Vacancies component
     * @constructor
     */
    function Component($el) {
        this.element = $el[0];
        this.vacanciesItems = this.element.querySelectorAll('.' + this.classes.vacanciesItem);

        window.addEventListener('pageshow', function () {
            if (this.vacanciesItems.length) {
                animations.addAppearanceAnimation(this.vacanciesItems, this.classes.animated);
                animations.disableAnimationInEditMode(this.vacanciesItems, this.classes.animated);
            }
        }.bind(this));
    }

    Component.prototype.classes = {
        vacanciesItem: 'related-vacancies__item',
        animated: 'animated',
    };

    Component.moduleName = 'Related Vacancies 2023';
    Component.selector = '.related-vacancies-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('RecruitingSearch23', ['constants', 'geolocation', 'utils-env', 'utils'], function (constants, geolocation, env, utils) {
    'use strict';

    var $body = $('body'),
        viewTypes = {
            formOnly: 'searchForm',
            formWithResults: 'searchFormAndResults'
        };
    var searchQuery = '';
    var collator = new Intl.Collator();

    var classes = {
        form: '.recruiting-search__form',
        autocomplete: '.recruiting-search__input-23.js-autocomplete',
        fakeAutoComplete: '.recruiting-search__fake-input.js-autocomplete',
        select: '.recruiting-search__select',
        selectOption: 'select2-results__option',
        selectOptions: 'select2-results__options',
        selectOptionGroup: 'select2-results__option[role="list"]',
        selectGroup: 'select2-results__group',
        selectRendered: 'select2-selection__rendered',
        selectBoxContainer: '.select2-container',
        formComponentField: 'form-component__field',
        location: '.recruiting-search__location',
        searchFilter: '.recruiting-search__filter',
        checkbox: '.recruiting-search__checkbox',
        resultList: '.search-result__list',
        resultContainer: '.search-result',
        resultHeader: '.search-result__heading-23',
        sortingMenu: '.search-result__sorting-menu',
        sortingItem: '.search-result__sorting-item-23',
        sortingRadio: '.search-result__sorting-radio-23',
        hiddenDividerItem: 'search-result__sorting-item--no-divider',
        itemName: '.search-result__item-name-23',
        itemApply: '.search-result__item-apply-23',
        viewMore: '.search-result__view-more-23',
        errorMessage: '.search-result__error-message-23',
        searchInput: '.select2-search__field',
    };

    function matchStart(params, data) {
        if ($.trim(params.term) === '') {
            return data;
        }

        if (typeof data.children === 'undefined') {
            return null;
        }

        var term = searchQuery = params.term.toUpperCase();
        var termExp = '(^|.*\\s)(' + term + ')';

        if (data.text.trim().toUpperCase().match(termExp) !== null) {
            return data;
        }

        var filteredChildren = [];
        $.each(data.children, function (idx, child) {
            if (idx > 0) {
                if (child.text.trim().toUpperCase().match(termExp) !== null) {
                    filteredChildren.push(child);
                }
            }
        });

        if (filteredChildren.length) {
            var modifiedData = $.extend({}, data, {
                text: '',
                hasChild: true,
            }, true);
            modifiedData.children = filteredChildren;
            return modifiedData;
        }

        return null;
    }

    function sortFunction(data) {
        function alphabeticalSort(a, b) {
            return collator.compare(a.text, b.text);
        }

        function upChildLevel(input, output) {
            $.each(input.children, function (index, child) {
                output.push(child);
            });
        }

        function retrieveChildWhichMatchQuery(input, output) {
            if (input.children.length !== 0) {
                $.each(input.children, function (i, ch) {
                    if (
                        i > 0 &&
                        ch.text.trim().toUpperCase().indexOf(searchQuery) === 0 &&
                        ch.text.trim().toUpperCase().indexOf(input.text.trim().toUpperCase()) !== 0
                    ) {
                        output.push(ch);
                    }
                });
            }
        }

        function closeInnerDropdown() {
            var openedDropdown = this.$el.find('.dropdown-cities');
            var openedChild = openedDropdown.find('.select2-results__options--nested');
            if (openedDropdown.length !== 0 && openedChild.length !== 0) {
                openedDropdown.removeClass('dropdown-cities');
                openedChild.removeClass('open');
            }
        }

        if (this.$el.find('.select2-search__field').val().trim().length !== 0) {
            var joinData = [];
            $.each(data, function (idx, value) {
                if (value.hasChild) {
                    upChildLevel(value, joinData);
                } else {
                    retrieveChildWhichMatchQuery(value, joinData);
                    joinData.push(value);
                }
            });

            if (joinData.length > 1) {
                setTimeout(closeInnerDropdown.bind(this), 0);
            }

            return joinData.sort(alphabeticalSort);
        }
        return data;
    }

    /**
     * Parent component for Job Search and Training Search
     * @param {jQuery} $el - Root element of the component
     * @constructor
     * @exports Search
     */
    function Component($el) {
        this.$el = $el;
        this.$form = $el.find(classes.form);
        this.$autocomplete = this.$form.find(classes.autocomplete);
        this.$fakeAutoComplete = $('.job-search-ui-23').find(classes.fakeAutoComplete);
        this.$select = this.$form.find(classes.select);
        this.$location = this.$form.find(classes.location);
        this.$results = this.$el.find(classes.resultList);

        this.isAuthor = env.isAuthor();
        this.viewType = this.$el.data('view');
        this.resultsUrl = this.$el.data('resultsUrl');
        this.recruitingUrl = this.$el.data('recruitingUrl');

        this.updateUrlAndLoadResultsDebounced = utils.debounceExtend(this.updateUrlAndLoadResults.bind(this), 300);

        this.defaultSearchParameters = {
            locale: CQ.I18n.getLocale(),
            limit: 20,
            recruitingUrl: this.recruitingUrl
        };

        this.overlayScrollbarInstance = null;

        this.init && this.init();
        this.initAutocomplete();
        this.initSelect();

        this.$el.data('useGeolocation') && geolocation.onGeolocationUpdate(this.fillWithGeolocation.bind(this));
        this.$form.on('submit', this.submit.bind(this));

        var searchParams = window.location.search;
        var urlParams = new URLSearchParams(searchParams);
        var departments = urlParams.getAll('department');

        if (!this.isFormOnly() && !departments.length) {
            this.initSearchResult();
        }
    }

    /**
     * If component needs to init something before initialization of plugins,
     * use this method
     * @abstract
     * @type {null|function}
     */
    Component.prototype.init = null;

    /**
     * Initialize autocomplete plugin on first field
     */
    Component.prototype.initAutocomplete = function () {
        this.$fakeAutoComplete.autocomplete($.extend({}, this.getAutocompleteConfig(), {
            appendTo: this.$fakeAutoComplete.parent(),
            onSelect: function (event) {
                event && event.preventDefault && event.preventDefault();
                this.$form.trigger(constants.Events.autocompleteSelected, [{ initialInput: 'fake' }]);
            }.bind(this)
        })).on('keyup', this.onEnter.bind(this));

        this.$autocomplete.autocomplete($.extend({}, this.getAutocompleteConfig(), {
            onSelect: function (event) {
                event && event.preventDefault && event.preventDefault();
                this.$form.trigger(constants.Events.autocompleteSelected, [{ initialInput: 'real' }]);
            }.bind(this)
        }));
    };

    /**
     * Handler for the Enter press in the autocomplete field
     * @param event
     */
    Component.prototype.onEnter = function (event) {
        event.key === constants.Keys.enter && this.submit();
    };

    /**
     * Getter for autocomplete plugin config object
     * @return {
     *  {
     * serviceUrl: string,
     * triggerSelectOnValidInput: boolean,
     * deferRequestBy: number,
     * appendTo,
     * params: {locale: *},
     * transformResult: transformResult,
     * onSelect: (function(this:Component)),
     * width: string,
     * zIndex: number
     *   }
     * }
     */
    Component.prototype.getAutocompleteConfig = function () {
        return {
            serviceUrl: this.config.autocompletePath,
            triggerSelectOnValidInput: false,
            deferRequestBy: 1000,
            appendTo: this.$autocomplete.parent(),
            params: { locale: this.defaultSearchParameters.locale },
            transformResult: function (response) {
                return { suggestions: JSON.parse(response) };
            },
            width: '343%',
            zIndex: 10
        };
    };

    /**
     * Custom submit handler
     * @param {?Event} event - Submit event.
     * Optional, submit method could be called directly
     */
    Component.prototype.submit = function (event, initialInput) {
        event && event.preventDefault && event.preventDefault();
        this.$form.trigger(constants.Events.autocompleteSelected, [{ initialInput: initialInput }]);

        if (!this.isFormOnly()) {
            this.updateUrlAndLoadResults();
            return;
        }

        window.location = this.toUrl(this.resultsUrl, this.getSubmitContext(), this.isAuthor);
    };

    /**
     * Getter for search results dust context
     * @abstract
     * @param result
     */
    Component.prototype.getSubmitContext = null;


    /*
    two options: 1) old page 2) new page with dark/light mode
     */
    Component.prototype.isNewPage = function () {
        return $body.hasClass('dark-mode') || $body.hasClass('light-mode');
    };

    /**
     * Initialize dropdown plugin on second field
     */
    Component.prototype.initSelect = function () {
        this.$select.selectWoo(this.getSelectConfig());
        this.$selectBoxContainer = this.$el.find(classes.selectBoxContainer);
        this.$selectBoxContainer.addClass(classes.formComponentField);
        this.$location.on('click', this.openSelection.bind(this))
            .on('click', '.' + classes.selectOption, this.toggleSelectItem.bind(this))
            .on('click', '.' + classes.selectOptionGroup, this.toggleCities.bind(this));
        if (this.isNewPage()) {
            this.$location.on('mouseleave', '.select2-results__option[role="list"]', this.locationMouseleaveHandler.bind(this));
        }

        this.setOverlayScrollbar();
    };

    /**
     * OverlayScrollbar functionality
     */
    Component.prototype.setOverlayScrollbar = function () {
        var isRedesign23 = $body.hasClass('dark-mode') || $body.hasClass('light-mode');

        if (isRedesign23) {
            this.$select.on('select2:open', this.openDropdownScrollbar.bind(this));
            this.$select.on('select2:closing', this.destroyDropdownScrollbar.bind(this));
            $(document).on('input', this.$select.parent().find(classes.searchInput), this.customizeDropdownScrollbar.bind(this));
        }
    };

    Component.prototype.openDropdownScrollbar = function () {
        this.destroyDropdownScrollbar();

        setTimeout(function () {
            var $list = this.$el.find('.select2-results > ul');
            var $inputField = this.$select.parent().find(classes.searchInput);

            $list.unbind('mousewheel');
            this.overlayScrollbarInstance = OverlayScrollbars($list, { className: 'os-theme-dark'});
            this.destroyDropdownScrollbar();
            $inputField.trigger('input');
        }.bind(this), 10);
    };

    Component.prototype.customizeDropdownScrollbar = function () {
        this.destroyDropdownScrollbar();

        setTimeout(function () {
            var $list = this.$el.find('.select2-results > ul');
            var $inputField = this.$select.parent().find(classes.searchInput);

            $list.unbind('mousewheel');
            this.overlayScrollbarInstance = OverlayScrollbars($list, { className: 'os-theme-dark'});
            $inputField.trigger('focus');
        }.bind(this), 10);
    };

    Component.prototype.destroyDropdownScrollbar = function () {
        if (this.overlayScrollbarInstance instanceof OverlayScrollbars) {
            this.overlayScrollbarInstance.destroy();
        }
    };

    /*
    change aria-selected attr. after mouse leave city option inside location DDL
     */
    Component.prototype.locationMouseleaveHandler = function (event) {
        var highlightedOption = $(event.currentTarget).find('.select2-results__option--highlighted');
        if (highlightedOption.length > 0) {
            highlightedOption.attr('aria-selected', 'false');
        }
    };

    /**
     * Handler for dropdown opening
     * @param {Event|null} event - Click event or null. Null, if called directly
     * @param {?jQuery} $element - Target element to open inside dropdown
     */
    Component.prototype.openSelection = function (event, $element) {
        this.$form.find(classes.searchInput).focus();

        var $group,
            $selection;

        if ($element) {
            $group = $element.parents('.' + classes.selectOptionGroup);
        } else {
            $selection = this.$location.find('[aria-selected="true"]');
        }

        if ($selection && $selection.length) {
            $group = $selection.parents('.' + classes.selectOptionGroup);
            $selection.parents('.' + classes.selectOptions).addClass('open');
        }

        if ($group && $group.hasClass('dropdown-cities')) {
            var self = this;

            setTimeout(function () {
                self.overlayScrollbarInstance.scroll({ el: $group, block: 'begin' }, 100);
            }, 10);
        }
    };

    /**
     * Handler for dropdown embedded dropdowns
     * @param {Event} event - Click event
     */
    Component.prototype.toggleSelectItem = function (event) {
        var $target = $(event.target),
            isOptgroup = $target.hasClass(classes.selectGroup),
            $nestedOptions = isOptgroup ?
                $target.siblings('.' + classes.selectOptions) :
                $target.children('.' + classes.selectOptions);

        if (!$nestedOptions.length) {
            return;
        }

        $nestedOptions.toggleClass('open');
    };

    /**
     * Handler for cities list open
     * @param {Event} event - Click event
     * @return {boolean} - Preventing default behavior
     */
    Component.prototype.toggleCities = function (event) {
        var $target = $(event.target);

        if ($target.hasClass(classes.selectRendered)) {
            return;
        }

        if ($target.hasClass(classes.selectGroup)) {
            $target.parent().toggleClass('dropdown-cities');
        } else {
            $target.toggleClass('dropdown-cities');
        }

        this.openSelection(null, $target);

        return false;
    };

    /**
     * Getter for dropdown plugin config
     * @return {{dropdownParent: *, placeholderOption: string, width: string}}
     */
    Component.prototype.getSelectConfig = function () {
        return {
            dropdownParent: this.$location,
            placeholderOption: 'first',
            matcher: matchStart,
            width: 'off',
            sorter: sortFunction.bind(this),
        };
    };

    /**
     * Handler for filling location field with data after geolocation update
     * @param {{ country: string, city: string}} location - geolocation data
     */
    Component.prototype.fillWithGeolocation = function (location) {
        var country = { name: location.country },
            city = { name: location.city };

        if (!country.name) {
            return;
        }

        country.$item = this.$select.find('[data-geolocation-name="' + country.name + '"]');
        country.value = country.$item.length && 'all_' + country.$item.data('name');

        if (city.name) {
            city.$item = country.$item.find('[data-geolocation-name="' + city.name + '"]');
            city.value = city.$item.val();
        }

        if (country.value || city.value) {
            this.$select.val(city.value || country.value).trigger('change');
        }
    };

    /**
     * Checks, is form without results or not
     * @return {boolean} - true if results are disabled
     */
    Component.prototype.isFormOnly = function () {
        return this.viewType === viewTypes.formOnly;
    };

    /**
     * Initialization method for search results behavior
     */
    Component.prototype.initSearchResult = function () {
        this.$resultContainer = this.$el.find(classes.resultContainer);
        this.$resultHeader = this.$resultContainer.find(classes.resultHeader);
        this.$sortingMenu = this.$resultContainer.find(classes.sortingMenu);
        this.$sortingItem = this.$resultContainer.find(classes.sortingItem);
        this.$sortingRadio = this.$resultContainer.find(classes.sortingRadio);
        this.$preloader = this.$resultContainer.find('.' + constants.Classes.preloader).toggle(false);
        this.$viewMore = this.$resultContainer.find(classes.viewMore);

        this.$errorMessage = this.$resultContainer.find(classes.errorMessage).toggle(false);

        this.$sortingRadio.on('change', this.updateUrlAndLoadResultsDebounced);
        this.$viewMore.on('click', this.loadMoreResults.bind(this));
        this.beforeLoadResults && this.beforeLoadResults();

        this.loadResults(this.collectSearchParameters(0, true));
    };

    /**
     * If component needs to init something before loading results,
     * use this method
     * @abstract
     * @type {null|function}
     */
    Component.prototype.beforeLoadResults = null;

    /**
     * Load additional results
     * Method could be called directly
     * @param {?Event} event - Click event
     */
    Component.prototype.loadMoreResults = function (event) {
        var offset = this.$results.children().length,
            searchParams = this.collectSearchParameters(offset);

        this.loadResults(searchParams);

        event && event.preventDefault();
    };

    /**
     * Collects parameters from the search form into single object
     * @param {number} offset - number of results to skip from load
     * @return {{ locale: string, limit: number, query: string, country: string, city: string, sort: string, offset: number }}
     */
    Component.prototype.collectSearchParameters = function (offset, buildSchemaOrgMarkup) {
        var searchParameters = {
            query: this.$autocomplete.val(),
            country: this.getCountry(),
            city: this.getCity(),
            sort: this.getSorting(),
            offset: offset || 0,
            buildSchemaOrgMarkup: buildSchemaOrgMarkup
        };

        return $.extend({}, this.defaultSearchParameters, searchParameters);
    };

    /**
     * Getter for country name
     * return {string}
     */
    Component.prototype.getCountry = function () {
        return this.$select.find(':selected').parent().data('name');
    };

    /**
     * Getter for city name
     * return {string|undefined}
     */
    Component.prototype.getCity = function () {
        if (!this.$select.find(':selected').is(':first-child')) {
            return this.$select.val();
        }
    };

    /**
     * Getter for sorting type
     * return {string}
     */
    Component.prototype.getSorting = function () {
        return this.$sortingMenu ? this.$sortingMenu.find(':checked').val() : null;
    };

    /**
     * Handler for multiple actions
     * Updates URL with search parameters and loads results
     * @param {Event?} event
     */
    Component.prototype.updateUrlAndLoadResults = function (event) {
        event && event.stopPropagation();
        var searchParameters = this.collectSearchParameters(),
            urlUpdated = this.updateUrl(searchParameters);

        var scrollable = true;

        this.loadResults(searchParameters, urlUpdated, scrollable);
    };

    /**
     * Updates URL with current parameters and writes new history entry
     * @param {{ locale: string, limit: number, query: string, country: string, city: string, sort: string, offset: number }} parameters
     * @return {boolean} - true, if URL was updated
     */
    Component.prototype.updateUrl = function (parameters) {
        var params = $.extend({}, parameters, {
                locale: null,
                limit: null,
                offset: null
            }),
            url = window.location.href,
            newUrl = this.toUrl(window.location.pathname, params),
            position = url.length - newUrl.length;

        if (position < 0 || url.indexOf(newUrl, position) !== position) {
            window.history.pushState({}, '', newUrl);
            if (window.initWechat) {
                var currentUrl = window.location.href.split('#')[0];
                initWechat(currentUrl);
            }
            return true;
        }

        return false;
    };

    /**
     * Maps parameters to URL string
     * @param {string} path - current URL
     * @param {{ locale: string, limit: number, query: string, country: string, city: string, sort: string, offset: number }} parameters
     * @param {boolean} extension - Marks, should .html extension be added to the URL
     * @return {string} - Completed URL string with parameters
     */
    Component.prototype.toUrl = function (path, parameters, extension) {
        var url = path + (extension ? '.html' : ''),
            params = {};

        Object.keys(parameters).forEach(function (key) {
            var value = parameters[key],
                isValuePresent = value && (!$.isArray(value) || value.length);

            if (isValuePresent) {
                params[key] = value;
            }
        });

        return Object.keys(params).length ? url + '?' + $.param(params) : url;
    };

    /**
     * Load new search results
     * @param {{ locale: string, limit: number, query: string, country: string, city: string, sort: string, offset: number }} parameters
     * @param {boolean} urlUpdated - true, when URL was updated before calling this method
     */
    Component.prototype.loadResults = function (parameters, urlUpdated, scrollable) {
        var featureToggleValue = $('.recruiting-search-ui.job-search-ui-23.multi-select-filter-wrapper').attr('data-feature-toggle');

        // search results should not be displayed, but instead of them messages should be displayed
        // eslint-disable-next-line no-extra-parens
        if ((parameters.locale === 'en' || parameters.locale === 'de_DE') && (parameters.country === 'Ukraine' || (parameters.country === 'Belarus' && featureToggleValue))) {
            this.showRedirectMessage(parameters.country);
            return;
        }

        $.ajax({
            url: this.config.searchUrl,
            data: parameters,
            cache: false,
            beforeSend: this.toggleLoadingState.bind(this, true),
            complete: this.onRequestCompleteHandler.bind(this, scrollable),
            success: this.updateSearchResults.bind(this, parameters),
            error: this.showErrorMessage.bind(this, urlUpdated)
        });
    };

    /**
     * Loading results complete handler
     */
    Component.prototype.onRequestCompleteHandler = function (scrollable) {
        this.toggleLoadingState(false);

        if (scrollable) {
            this.scrollToTop();
        }
    };

    /**
     * Show `View Career Opportunities` message
     */
    Component.prototype.showRedirectMessage = function (country) {
        this.$results.empty();
        this.$resultHeader.toggle(false);
        this.$sortingMenu.toggleClass(constants.Classes.hidden, true);
        var context = $.extend({ country: country }, {});
        require('utils-dust').append('recruiting-search-no-result', context, this.$results);
    };

    /**
     * Appends loaded results to the markup
     * @param {{ locale: string, limit: number, query: string, country: string, city: string, sort: string, offset: number }} parameters
     * @param {{ result: *, total: number}} response
     */
    Component.prototype.updateSearchResults = function (parameters, response) {
        var result = response.result,
            schemaOrgMarkup = response.schemaOrgMarkup,
            total = response.total,
            context = this.getResultsContext(result),
            limit = parameters.limit,
            offset = parameters.offset,
            emptyResult = !result.length,
            firstLoad = offset === 0,
            hasMoreResults = total > offset + limit,
            buildSchemaOrgMarkup = !!parameters.buildSchemaOrgMarkup;

        if (emptyResult || firstLoad) {
            this.$results.empty();
        }

        require('utils-dust').append('recruiting-search-23-result', context, this.$results);

        this.showResultMessage(parameters.query, total);
        this.showApplyButtonText();
        this.$sortingMenu.toggleClass(constants.Classes.hidden, emptyResult);
        this.$resultHeader.toggle(!emptyResult);
        this.$errorMessage.toggle(emptyResult);
        this.$viewMore.toggle(hasMoreResults);
        !firstLoad && this.$results.find(classes.itemName).eq(offset).focus();
        utils.checkDividers(this.$sortingItem, classes.hiddenDividerItem);

        buildSchemaOrgMarkup && !!schemaOrgMarkup && this.addSchemaOrgMarkup(schemaOrgMarkup);
    };

    Component.prototype.addSchemaOrgMarkup = function (schemaOrgMarkup) {
        this.$el.prepend('<script type="application/ld+json">' + JSON.stringify(schemaOrgMarkup) + '</script>');
    };

    /**
     * Getter for search results dust context
     * @abstract
     * @param result
     */
    Component.prototype.getResultsContext = null;

    /**
     * Shows error message when loading results failed
     * @param {boolean} urlUpdated - Was URL updated before calling this method
     */
    Component.prototype.showErrorMessage = function (urlUpdated) {
        var errorMessage = CQ.I18n.getMessage('component.general.ajax-error-message') + ' ' +
            CQ.I18n.getMessage('component.general.ajax-error-try-again');

        this.$errorMessage.text(errorMessage).show();
        this.$sortingMenu.addClass(constants.Classes.hidden);
        if (urlUpdated) {
            this.$results.empty();
            this.$resultHeader.hide();
            this.$viewMore.hide();
        } else if (this.$results.children().length >= this.defaultSearchParameters.limit) {
            this.$viewMore.show();
        }
    };

    /**
     * Show/hide preloader
     * @param {boolean} loading
     */
    Component.prototype.toggleLoadingState = function (loading) {
        this.$preloader.toggle(loading);
    };

    /**
     * Shows message with total count of the results
     * @param {?string} query
     * @param {number} total
     */
    Component.prototype.showResultMessage = function (query, total) {
        if (!total) {
            this.$errorMessage.text(CQ.I18n.getMessage('component.general.search-empty-result-for-combination'));
            return;
        }

        var message = query ? this.getResultMessageWithQuery(query, total) : this.getResultMessage(total);
        var modifyMessage = message.replace(total, '<span class="heading-1-color">' + total + '</span>');

        this.$resultHeader[0].innerHTML = modifyMessage;
    };

    /**
     * Shows apply button text
     */
    Component.prototype.showApplyButtonText = function () {
        var applyText = this.getApplyButtonText();
        var applyButtons = this.$el.find(classes.itemApply);

        for (var i = 0; i < applyButtons.length; i++) {
            applyButtons[i].innerHTML = applyText;
        }
    };

    /**
     * Getter for search results message with query string
     * @abstract
     * @param {string} query
     * @param {number} total
     */
    Component.prototype.getResultMessageWithQuery = null;

    /**
     * Getter for search results message with total count only
     * @abstract
     * @param {number} total
     */
    Component.prototype.getResultMessage = null;

    Component.prototype.classes = classes;

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('PinnedButton23', ['utils', 'constants'], function(utils, constants) {
    'use strict';

    var classes = {
        hide: 'pinned-link-hide',
        tabs: 'tabs-ui-23',
        slider: '.slider-ui-23',
        section: 'section-ui',
        pinnedLink: '.pinned-button-ui-23',
        alwaysPinned: 'always-pinned',
        linkInsideActiveTab: '.tabs-23__item.js-tabs-item.active .pinned-button-ui-23 .link-text',
        pinned: 'pinned',
        header: '.header-ui-23',
        linkText: '.link-text',
        pinnedLinkInActiveTab: '.tabs-23__item.js-tabs-item.active .pinned-button',
        breadcrumbs: '.breadcrumbs-ui-23',
        hideBreadcrumbs: 'hide-breadcrumbs',
        tabItem: 'js-tabs-item',
        pinnedButtonText: 'pinned-button-text',
        dataItemAttr: 'data-item',
        pinnedBody: '.button-body',
        smartHover: 'smart-hover',
        fakeSliderButtons: '.owl-item.cloned .pinned-button-ui-23'
    };

    var BLACK_COLOR = '#000';
    var VIEW_PORT_SHRINK = -65;
    var MOBILE_MAX_POINT = 768;
    var DEFAULT_TRANSFORM = 'transform 0.3s linear';
    var TRANSLATE_0 = 'translateY(0)';
    var TRANSLATE_17 = 'translateY(17%)';
    var events = {
        tabChange: 'tab.change' //from tabs-utils module
    };

    var intersectionObserverOptions = {
        root: null,
        rootMargin: VIEW_PORT_SHRINK + 'px 0px 0px 0px',
        threshold: 0.95
    };

    var intersectionObserverSliderOptions = {
        root: null,
        rootMargin: '0px',
        threshold: 0
    };

    var mutationObserverConfig = {
        attributes: true,
        attributeFilter: ['class']
    };

    var observableItems = ['.slider-ui-23', '.tabs-ui-23', '#wrapper'];

    function Component($el) {
        this.$el = $el;
        this.pinnedBody = this.$el.find(classes.pinnedBody)[0];
        this.pinnedButtonText = this.$el.find('.' + classes.pinnedButtonText)[0];

        this._storage ={
            buttonBodyBackground: null,
            buttonPressedBackground: null,
        };

        if (N & DS && N & DS.pinnedLink) {
            this.shortInit();
            return;
        }

        this.isAlwaysPinned = $el.data('pinned') || false;
        this.breadcrumbs = document.querySelector(classes.breadcrumbs);
        this.observer = null;
        this.tabsContainer = null;
        this.mutationOberver = null;

        N & DS.pinnedLink = {
            loaded: true
        };

        this.init();
    }

    Component.prototype.calculateLeftDistance = function(child, parent) {
        if (!child || !parent) {
            throw new Error('Both child and parent elements must be provided.');
        }

        const childRect = child.getBoundingClientRect();
        const parentRect = parent.getBoundingClientRect();

        return childRect.left - parentRect.left;
    };

    Component.prototype.applyBthGradient = function() {
        var pointer_children = document.querySelector('.copied-pinned-link .button-text-wrapper');
        var pointed_parent = document.querySelector('.copied-pinned-link');
        if (pointer_children && pointed_parent) {
            var DISTANCE_ADJUSTMENT = -37; //approximately value

            var distance = this.calculateLeftDistance(pointer_children, pointed_parent);
            var width = pointed_parent.offsetWidth;


            this.pinnedBody.style.backgroundSize = width + 'px 100%';
            this.pinnedBody.style.backgroundPosition = '-' + distance - DISTANCE_ADJUSTMENT + 'px 0';
        } else {
          throw new Error('Child or parent element not found in the DOM.');
        }
    };

    Component.prototype.findObservableObject = function() {
        for (var i = 0; i < observableItems.length; i++) {
            var selector = observableItems[i];
            var container = document.querySelector(selector);
            if (!container) {
                // eslint-disable-next-line
                continue;
            }
            var pinnedLink = container.querySelector(classes.pinnedLink);
            if (!pinnedLink) {
                // eslint-disable-next-line
                continue;
            }
            this.defineTypeOfSelector(selector, container, pinnedLink);
            break;
        }
    };

    Component.prototype.defineTypeOfSelector = function(selector, container, pinnedLink) {
        if (selector === classes.slider) {
            this.observableObject = container;
            return;
        }

        if (selector === '.' + classes.tabs) {
            this.handleTabsConditions(container);
            return;
        }
        this.observableObject = pinnedLink;
    };

    Component.prototype.handleTabsConditions = function(container) {
        var activeTabPinnedLink = container.querySelector(classes.pinnedLinkInActiveTab);
        if (activeTabPinnedLink) {
            this.observableObject = activeTabPinnedLink;
        } else {
            this.observableObject = null;
        }
        this.tabsContainer = container;
    };

    Component.prototype.shortInit = function() {
        this.applyBthGradient();
        this.initButtonHover();
        this.initButtonPressed();
        this.configureShortResizing();
    };

    Component.prototype.init = function() {
        this.findObservableObject();

        if (!this.observableObject) {
            return;
        }

        this.copyPinnedLink();
        this.applyBthGradient();

        this.initButtonHover();
        this.initButtonPressed();

        this.setupIntersection();
        this.handleTabChange();
        this.configureResizing();
        this.configurePinning();

        this.collectPinnedButtonsFromTabs();
        this.initFakeSliderButtons();
    };

    Component.prototype.initFakeSliderButtons = function() {
        if (!this.observableObject.classList.contains('slider-ui-23')) {
          return;
        }

        document.addEventListener(constants.Events.sliderReady, function(){
          this.readySliderHandler();
        }.bind(this));

        document.addEventListener(constants.Events.sliderResized, utils.debounceExtend(function() {
              this.readySliderHandler();
          }.bind(this), 300));
    };

    Component.prototype.readySliderHandler = function() {
        var fakeSliderButtons = document.querySelectorAll(classes.fakeSliderButtons);
        Array.prototype.forEach.call(fakeSliderButtons, function(button) {
            new Component($(button));
        });
    };

    Component.prototype.initButtonHover = function() {
        this.$el[0].addEventListener('mouseenter', function(event) {
            this.handleButtonHover(event.target);
        }.bind(this));
    };

    Component.prototype.handleButtonHover = function(target) {
        target.classList.add(classes.smartHover);
        var backgroundProps = this.getBackgroundProperties(this.pinnedBody);

        this._storage.buttonBodyBackground = backgroundProps.background;
        this.pinnedBody.style.background = BLACK_COLOR;

        this.pinnedButtonText.style.backgroundSize = backgroundProps.backgroundSize;
        this.pinnedButtonText.style.backgroundPosition = backgroundProps.backgroundPosition;

        var handleMouseLeave = function() {
            target.classList.remove(classes.smartHover);
            this.pinnedBody.style.background = this._storage.buttonBodyBackground;
            target.removeEventListener('mouseleave', handleMouseLeave);
        }.bind(this);

        target.addEventListener('mouseleave', handleMouseLeave);
    };

    Component.prototype.initButtonPressed = function() {
        this.$el[0].addEventListener('mousedown', function(event) {
            this.handleButtonPressed(event.currentTarget);
        }.bind(this));
    };

    Component.prototype.handleButtonPressed = function(target) {
        target.classList.add('pressed');
        target.classList.remove(classes.smartHover);
        this.pinnedBody.style.background = this._storage.buttonBodyBackground;
        var handleMouseUp = function() {
            target.classList.remove('pressed');
            document.removeEventListener('mouseup', handleMouseUp);
        };

        document.addEventListener('mouseup', handleMouseUp);
    };

    Component.prototype.getBackgroundProperties = function(element) {
        if (!element) {
            throw new Error('Element is required.');
        }

        var computedStyle = getComputedStyle(element);

        var backgroundSize = computedStyle.backgroundSize;
        var backgroundPosition = computedStyle.backgroundPosition;
        var background = computedStyle.background;

        return {
            backgroundSize: backgroundSize,
            backgroundPosition: backgroundPosition,
            background: background
        };
    };

    Component.prototype.collectPinnedButtonsFromTabs = function() {
        if (!this.tabsContainer) {
            return;
        }

        var tabs = this.tabsContainer.getElementsByClassName(classes.tabItem);
        this.pinedButtons = {};

        Array.prototype.forEach.call(tabs, function(item) {
            var pinedButtonText = item.getElementsByClassName(classes.pinnedButtonText);
            var tabIndex = item.getAttribute(classes.dataItemAttr);
            if (pinedButtonText.length > 0) {
                this.pinedButtons[tabIndex] = pinedButtonText[0].textContent;
            }
        }, this);

        if (Object.keys(this.pinedButtons).length === 0) {
            this.pinedButtons = null;
        }
    };

    Component.prototype.configurePinning = function() {
        if (!this.isAlwaysPinned) {
            return;
        }

        var isDesktop = this.isDesktop();

        if (!isDesktop) {
            this.alwaysPinOnMobile();
        }

        this.setupMutationObserver(isDesktop);
    };

    Component.prototype.setupMutationObserver = function(isDesktop) {
        this.header = document.querySelector(classes.header);

        if (!this.header || isDesktop) {
            return;
        }

        this.mutationOberver = new MutationObserver(this.mutationObserverCallback.bind(this));
        this.mutationOberver.observe(this.header, mutationObserverConfig);
        this.adjustPinnedLinkPosition(this.header);
    };


    Component.prototype.configureShortResizing = function() {
        window.addEventListener('resize', utils.debounceExtend(this.applyBthGradient.bind(this), 300));
    };

    Component.prototype.configureResizing = function() {
        var resizeHandler = this.isAlwaysPinned ? function() {
            this.applyBthGradient();
            this.resizeEventHandler();
        } : function() {
            this.applyBthGradient();
            this.recheckObservableElementPosition();
        };
        window.addEventListener('resize', utils.debounceExtend(resizeHandler.bind(this), 300));
    };

    Component.prototype.handleTabChange = function() {
        if (this.tabsContainer) {
            $(this.tabsContainer).on(events.tabChange, this.tabChangeEventHandler.bind(this));
        }
    };

    Component.prototype.setupIntersection = function() {
        var isDesktop = this.isDesktop();

        if (!(!isDesktop && this.isAlwaysPinned)) {
            this.initIntersectionObserver(this.observableObject);
        }
    };

    Component.prototype.toggleBreadcrumbs = function(isHide) {
        if (this.breadcrumbs) {
            var action = isHide ? 'add' : 'remove';
            this.breadcrumbs.classList[action](classes.hideBreadcrumbs);
        }
    };

    Component.prototype.mutationObserverCallback = function(mutationsList) {
        for (const mutation of mutationsList) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                this.adjustPinnedLinkPosition(mutation.target, true);
            }
        }
    };

    Component.prototype.adjustPinnedLinkPosition = function(target, adjustAnimationSpeed) {
        if (!this.copiedLink) {
            return;
        }
        this.updateTransitionStyle(adjustAnimationSpeed);
        this.updateTranslateStyle(target);
    };

    Component.prototype.updateTransitionStyle = function(adjustAnimationSpeed) {
        if (adjustAnimationSpeed) {
            this.copiedLink.style.transition = DEFAULT_TRANSFORM;
        }
    };

    Component.prototype.updateTranslateStyle = function(target) {
        var translateStyle = target.classList.length > 1 ? TRANSLATE_0 : TRANSLATE_17;
        this.copiedLink.style.transform = translateStyle;
    };

    Component.prototype.tabChangeEventHandler = function(_, data) {
        this.resetObservation();
        this.updatePinnedLinkWithActiveTab();
        this.updateCopiedLink();

        this.updatePinnedLinkTextForActiveTab(data);
    };

    Component.prototype.updatePinnedLinkTextForActiveTab = function(data) {
        if (data && data.tab !== undefined) {
            var newText = this.pinedButtons[data.tab];
            if (this.copiedLink && newText) {
                var oldText = this.copiedLink.getElementsByClassName(classes.pinnedButtonText)[0];
                oldText.innerHTML = newText;
            }
        }
    };

    Component.prototype.resetObservation = function() {
        if (this.observer) {
            this.observer.disconnect();
            this.observableObject = null;
        }
    };

    Component.prototype.updatePinnedLinkWithActiveTab = function() {
        var activeTabPinnedLink = this.tabsContainer.querySelector(classes.pinnedLinkInActiveTab);

        if (!activeTabPinnedLink) {
            return;
        }

        this.observableObject = activeTabPinnedLink;
        if (this.observer) {
            this.observer.observe(activeTabPinnedLink);
        }
    };

    Component.prototype.updateCopiedLink = function() {
        const activeTabPinnedLink = this.tabsContainer.querySelector(classes.pinnedLinkInActiveTab);
        const linkText = activeTabPinnedLink ? activeTabPinnedLink.querySelector(classes.linkInsideActiveTab) : null;

        if (linkText && this.copiedLink) {
            this.copiedLink.querySelector('.link-text').textContent = linkText.textContent;
        }
    };

    Component.prototype.isDesktop = function() {
        return window.innerWidth >= MOBILE_MAX_POINT;
    };

    Component.prototype.recheckObservableElementPosition = function() {
        var rect = this.observableObject.getBoundingClientRect();
        var isTogglePinnedLink = rect.y + rect.height > 0;
        this.togglePinnedLink(!isTogglePinnedLink);
    };

    Component.prototype.resizeEventHandler = function() {
        if (this.isDesktop()) {
            this.initDesktopFeatures();
        } else {
            this.handleObserverForMobile();
        }
    };

    Component.prototype.initDesktopFeatures = function() {
        this.initIntersectionObserver(this.observableObject);
        if (this.copiedLink) {
            this.copiedLink.classList.remove(classes.alwaysPinned);
            this.copiedLink.removeAttribute('style');
        }

        if (this.mutationOberver) {
            this.mutationOberver.disconnect();
        }
    };

    Component.prototype.handleObserverForMobile = function() {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }

        this.alwaysPinOnMobile();
        this.adjustPinnedLinkPosition(this.header);

        if (!this.mutationOberver) {
            this.mutationOberver = new MutationObserver(this.mutationObserverCallback.bind(this));
            this.mutationOberver.observe(this.header, mutationObserverConfig);
        } else {
            this.mutationOberver.disconnect();
            this.mutationOberver.observe(this.header, mutationObserverConfig);
        }
    };

    Component.prototype.initIntersectionObserver = function(observableObject) {
        if (this.observer) {
            this.observer.disconnect();
        }

        if (!observableObject) {
            throw new Error('Observable object is null or undefined.');
        }

        var observerOptions = this.observableObject.classList.contains('slider-ui-23')? intersectionObserverSliderOptions : intersectionObserverOptions;

        this.observer = new IntersectionObserver(this._intersectionObserverCallback.bind(this), observerOptions);
        this.observer.observe(observableObject);
    };

    Component.prototype._intersectionObserverCallback = function(entries) {
        entries.forEach(function(entry) {
            if (entry.target !== this.observableObject) {
                console.warn('Mismatch: entry.target does not match this.observableObject', entry.target, this.observableObject);
                return;
            }
            var currentY = entry.boundingClientRect.y + VIEW_PORT_SHRINK;
            var isIntersecting = entry.isIntersecting;
            var shouldToggle = !isIntersecting && currentY < 0;
            this.togglePinnedLink(shouldToggle);
        }.bind(this));
    };

    Component.prototype.copyPinnedLink = function(className) {
        var pinnedDiv = document.createElement('div');
        pinnedDiv.classList.add('copied-pinned-link');
        if (className) {
            pinnedDiv.classList.add(className);
        }

        var pinnedLinkClone = this.$el[0].cloneNode(true);
        pinnedLinkClone.removeAttribute('data-pinned');
        pinnedDiv.appendChild(pinnedLinkClone);

        this.copiedLink = pinnedDiv;

        if (this.tabsContainer) {
            this.tabChangeEventHandler();
            this.refreshPinnedLinkText(pinnedDiv);
        }

        var wrapper = document.body.querySelector('#wrapper');
        if (wrapper) {
            wrapper.appendChild(this.copiedLink);
        }
    };

    Component.prototype.refreshPinnedLinkText = function(element) {
        var textElement = element.getElementsByClassName(classes.pinnedButtonText)[0];
        var activeTab = this.tabsContainer.querySelector('.js-tabs-link.active');
        var tabIndex = activeTab.getAttribute(classes.dataItemAttr);

        if (textElement && this.pinedLinks && this.pinedLinks[tabIndex]) {
            textElement.innerHTML = this.pinedLinks[tabIndex];
        }
    };

    Component.prototype.pinComponent = function() {
        if (this.copiedLink) {
            this.copiedLink.classList.add(classes.pinned);
            this.copiedLink.classList.remove(classes.hide);
            return;
        }
        this.copyPinnedLink();

        setTimeout(function() {
            this.copiedLink.classList.add(classes.pinned);
        }.bind(this), 50);
    };

    Component.prototype.unpinComponent = function() {
        if (this.copiedLink) {
            this.copiedLink.classList.remove(classes.pinned);
            this.copiedLink.classList.add(classes.hide);
        }
    };

    Component.prototype.togglePinnedLink = function(isShow) {
        if (isShow) {
            this.pinComponent();
            this.toggleBreadcrumbs(true);
        } else {
            this.unpinComponent();
            this.toggleBreadcrumbs(false);
        }
    };

    Component.prototype.alwaysPinOnMobile = function() {
        if (this.copiedLink) {
            this.copiedLink.classList.remove(classes.pinned);
            this.copiedLink.classList.remove(classes.hide);
            this.copiedLink.classList.add(classes.alwaysPinned);
            return;
        }
        this.copyPinnedLink(classes.alwaysPinned);
    };

    Component.moduleName = 'Pinned Button 23';
    Component.selector = '.pinned-button-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('PersonInfo23', ['utils', 'media', 'imager', 'gradients'], function (utils, media, imager, gradients) {
    'use strict';

    var $window = $(window);

    /**
     * Person Info component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.desktopImageLoaded = false;
        this.mobileImageLoaded = false;
        this.$el = $el;
        this.$mobilePlaceholder = this.$el.find('.' + this.classes.mobilePlaceholder);
        this.$desktopPlaceholder = this.$el.find('.' + this.classes.desktopPlaceholder);

        var N & DS_RIGHT_RATIO = 0.58;
        var N & DS_MIDDLE_RATIO = 1.95;

        var nodes = document.querySelectorAll('.' + this.classes.personName);
        var gradientText = new gradients.GradientText();
        gradientText.init(nodes, {rightRatio: N & DS_RIGHT_RATIO, middleRatio: N & DS_MIDDLE_RATIO});

        this.render();
        $window.on('resize', utils.debounce(this.render.bind(this), 100));
    }

    Component.prototype.isDesktop = function () {
        return media.currentMode().greaterThan(media.modes.Tablet);
    };

    /**
     * Render image on the page
     */
    Component.prototype.render = function () {
        if (this.isDesktop()) {
            if (!this.desktopImageLoaded) {
                imager.create(this.$desktopPlaceholder);
                this.desktopImageLoaded = true;
            }
        } else if (!this.mobileImageLoaded) {
            imager.create(this.$mobilePlaceholder);
            this.mobileImageLoaded = true;
        }
    };

    Component.prototype.classes = {
        desktopPlaceholder: 'person-info-23__desktop-placeholder',
        mobilePlaceholder: 'person-info-23__mobile-placeholder',
        personName: 'person-info-23__person-name'
    };

    Component.moduleName = 'Person Info 23';
    Component.selector = '.person-info-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('PartnersList23', [], function() {
    'use strict';

    var classes = {
        stickyContainer: '#sticky-container',
        stickyElement: '.movable-part',
        pinned: 'pinned',
        absolute: 'absolute',
        stickyMovablePart: 'sticky-container-movable-part',//id
        customSelectInput: '.custom-select-input',
        customSelectOptions: '.custom-select-options',
        alphabeticalRow: '.alphabetical-row',
        inputWrapper: '.select-input-wrapper',
        partnerOption: '.partners-option',
        alphabeticalSectionAbsolute: 'alphabetical-section-absolute'
    };

    var specialSymbols = {
        '!': '\\!',
        '@': '\\@',
        '#': '\\#',
        '$': '\\$',
        '%': '\\%',
        '^': '\\^',
        '&': '\\&',
        '*': '\\*',
        '(': '\\(',
        ')': '\\)',
        '.': '\\.',
        '<': '\\<',
        '>': '\\>',
        '?': '\\?',
        '[': '\\[',
        ']': '\\]',
        '{': '\\{',
        '}': '\\}',
        '=': '\\=',
        '-': '\\-',
        '+': '\\+',
        /* eslint-disable */
        '\'': '\\\'',
        '"': '\\"'
        /* eslint-enable */
    };

    function Component($el) {
        this.el = $el[0];
        this.stickyContainer = this.el.querySelector(classes.stickyContainer);
        this.stickyElement = this.el.querySelector(classes.stickyElement);
        this.customSelectInput = this.el.querySelector(classes.customSelectInput);
        this.customSelectOptions = this.el.querySelector(classes.customSelectOptions);
        this.alphabeticalRow = this.el.querySelector(classes.alphabeticalRow);
        this.inputWrapper = this.el.querySelector(classes.inputWrapper);
        this.headerHeight = 65; //get from css style, magic number. header size in pinned state
        this._secondObserver = null;
        this.partnerOptions = this.el.querySelectorAll(classes.partnerOption);

        this.init();
    }

    Component.prototype.init = function() {
        this.initAlphabeticalSection();
        this.initCustomSelect();
        this.initAlphabeticalScrollEvent();
    };

    /**
     * depend on active resolution, for desktop: row, for mobile: dropdown
     */
    Component.prototype.getHeightOfActiveAlphabeticalElement = function() {
        var alphabeticalRowHeight = this.alphabeticalRow.offsetHeight;

        if (alphabeticalRowHeight === 0) {
            return this.stickyContainer.offsetHeight;
        }
        return alphabeticalRowHeight + 33 * 2;//33*2 margin which will be added when 'alphabeticalRow' is pinned
    };

    Component.prototype.setValueToDropdownInput = function(value) {
        if (value.trim() === '' || undefined) {
            return;
        }

        this.customSelectInput.value = value;
    };

    /**
     * check if selector contains special character and handle them appropriately
     */
    Component.prototype.getValidSelector = function(selector) {
        if (specialSymbols[selector]) {
            return specialSymbols[selector];
        } else {
            return selector;
        }
    };

    Component.prototype.initAlphabeticalScrollEvent = function() {
        this.stickyElement.addEventListener('click', function(e) {
            var target = e.target;

            if (target.tagName === 'A' || target.classList.contains('partners-option')) {
                e.preventDefault();
                var clickedItemId = target.dataset.key;
                var viewportWidth = window.innerWidth;

                if (viewportWidth < 992) { //992 - border between tablet and desktop view
                    this.setValueToDropdownInput(target.textContent);
                    this.setActiveDdlOption(target);
                }

                var alphabeticalRowAndHeaderHeight = this.getHeightOfActiveAlphabeticalElement() + this.headerHeight;
                var destinationItem = this.el.querySelector('#item' + this.getValidSelector(clickedItemId));

                if (!destinationItem) {
                    return;
                }

                var destinationItemPosition = destinationItem.getBoundingClientRect().top + window.pageYOffset - alphabeticalRowAndHeaderHeight;

                $('html, body').animate({
                    scrollTop: destinationItemPosition
                }, 360);
            }
        }.bind(this));
    };

    Component.prototype.setActiveDdlOption = function(target) {
        for (var i = 0; i <= this.partnerOptions.length - 1; i++) {
            this.partnerOptions[i].classList.remove('active');
        }
        target.classList.add('active');
    };

    Component.prototype.initCustomSelect = function() {
        this.inputWrapper.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            if (this.customSelectOptions.classList.contains('opened')) {
                this.customSelectOptions.classList.remove('opened');
                this.inputWrapper.classList.remove('opened');
            } else {
                this.customSelectOptions.classList.add('opened');
                this.inputWrapper.classList.add('opened');
            }
        }.bind(this));

        window.addEventListener('click', function() {
            this.customSelectOptions.classList.remove('opened');
            this.inputWrapper.classList.remove('opened');
        }.bind(this));
    };

    Component.prototype.toggleStickyElement = function toggleStickyElement(isPinned) {
        if (isPinned) {
            var stickyContainerHeight = this.stickyContainer.offsetHeight;
            this.stickyContainer.style.height = stickyContainerHeight + 'px';
            this.stickyElement.classList.add(classes.pinned);
            this.stickyElement.style.top = this.headerHeight + 'px';
        } else {
            this.stickyElement.classList.remove(classes.pinned);
            this.stickyElement.style.top = '';
            this.stickyContainer.removeAttribute('style');
        }
    };

    Component.prototype.alphabeticalSectionObserverCallback = function(entry) {
        if (!entry.isIntersecting && entry.boundingClientRect.top <= this.headerHeight) {
            this.toggleStickyElement.call(this, true);
            this._secondObserver = this.initSecondObserver();
            this.disableBreadcrumbs(true);
        } else {
            this.toggleStickyElement.call(this, false);
            this.disableBreadcrumbs(false);

            if (this._secondObserver) {
                this._secondObserver.unobserve(this.el);
            }
        }
    };

    Component.prototype.initAlphabeticalSection = function() {
        var options = {
            rootMargin: '-' + this.headerHeight + 'px 0px 0px 0px',
            threshold: 1.0
        };
        var observer = new IntersectionObserver(function(entries) {
            entries.forEach(function(entry) {
                this.alphabeticalSectionObserverCallback(entry);
            }.bind(this));
        }.bind(this), options);
        observer.observe(this.stickyContainer);
    };

    Component.prototype.addStyles = function(element, styles) {
        Object.keys(styles).forEach(function(key) {
            element.style[key] = styles[key];
        });
    };

    Component.prototype.toggleClasses = function(element, classesToAdd, classesToRemove) {
        classesToAdd.forEach(function(className) {
            element.classList.add(className);
        });
        classesToRemove.forEach(function(className) {
            element.classList.remove(className);
        });
    };

    Component.prototype.secondObserverCallback = function(entry, rootMargin) {
        if (!entry.isIntersecting && entry.boundingClientRect.top <= rootMargin) {
            this.toggleClasses(this.stickyElement, [classes.absolute], [classes.pinned]);

            this.toggleClasses(this.el, [classes.alphabeticalSectionAbsolute], []);

            this.stickyElement.removeAttribute('style');
            this.disableBreadcrumbs(false);

        } else {
            this.toggleClasses(this.stickyElement, [classes.pinned], [classes.absolute]);
            this.toggleClasses(this.el, [], [classes.alphabeticalSectionAbsolute]);
            this.addStyles(this.stickyElement, { top: this.headerHeight + 'px' });
            this.disableBreadcrumbs(true);
        }
    };

    Component.prototype.initSecondObserver = function() {
        var stickyElementHeight = this.stickyElement.offsetHeight;
        var rootMargin = stickyElementHeight + this.headerHeight;
        var options = {
            rootMargin: '-' + rootMargin + 'px 0px 0px 0px',
            threshold: 0
        };

        var observer = new IntersectionObserver(function(entries) {
            entries.forEach(function(entry) {
                this.secondObserverCallback(entry, rootMargin);
            }.bind(this));
        }.bind(this), options);

        observer.observe(this.el);
        return observer;
    };

    Component.prototype.disableBreadcrumbs = function(state) {
        var breadcrumbs = document.querySelector('.breadcrumbs-ui-23');
        var className = 'hide-breadcrumbs';

        if (!breadcrumbs) {
            return;
        }

        if (state) {
            breadcrumbs.classList.add(className);
        } else {
            breadcrumbs.classList.remove(className);
        }
    };

    Component.moduleName = 'Partners List 23';
    Component.selector = '.partners-list-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define('NewsReleases23', ['utils-share', 'animations'], function (share, animations) {
  'use strict';

  /**
   * News Releases component
   * @param { jQuery } $el
   * @constructor
   */
  function Component($el) {
    this.$el = $el;
    this.$newsList = this.$el.find('.' + this.classes.newsList);
    this.$socialLinks = this.$el.find('.' + this.classes.socialLink);
    this.setSocialLinks();
    this.$newsList.on('click', '.' + this.classes.socialLink, this.openPopup.bind(this));
    this.$items = this.$el.find('.' + this.classes.newsItem + ':not(.' + this.classes.animated + ')');
    this.$seeAllBtn = this.$el.find('.' + this.classes.seeAllBtn);

    window.addEventListener('pageshow', function () {
      if (this.$items.length) {
        animations.addAppearanceAnimation(this.$items.get(), this.classes.animated);
        animations.addAppearanceAnimation(this.$seeAllBtn.get(), this.classes.animated);
        animations.disableAnimationInEditMode(this.$items.get(), this.classes.animated);
        animations.disableAnimationInEditMode(this.$seeAllBtn.get(), this.classes.animated);
      }
    }.bind(this));
  }

  Component.prototype.setSocialLinks = function () {
    this.$socialLinks.each(function () {
        var url = window.location.origin + $(this).data('path');
        $(this)
          .removeAttr('data-path')
          .attr('data-url', url)
          .attr('data-count_url', url);
    });
  };

  Component.prototype.openPopup = function (event) {
      var url = this.getLinkData(event.currentTarget);
      share.openPopup(url);
      return false;
  };

  Component.prototype.getLinkData = function (link) {
      return share.getLink($(link).data());
  };

  Component.prototype.classes = {
      socialLink: 'news-releases-23__social-link',
      newsList: 'news-releases-23__list',
      newsItem: 'news-releases-23__item',
      seeAllBtn: 'news-releases-23__see-all',
      animated: 'animated',
  };

  Component.moduleName = 'News Releases 2023';
  Component.selector = '.news-releases-ui-23';

  return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define('NewsFilter23', ['require', 'media', 'constants', 'NewsFilterA11YLayer', 'animations', 'utils'],
  // eslint-disable-next-line max-params
  function (require, media, constants, NewsFilterA11YLayer, animations, utils) {
    'use strict';

    var $window = $(window),
        $body = $('body');

    var share = require('utils-share');

    /**
     * News Filter component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$newsList = this.$el.find('.' + this.classes.newsList);
        this.$preloader = this.$el.find('.' + constants.Classes.preloader);
        this.$viewMore = this.$el.find('.' + this.classes.viewMore);
        this.$errorMessage = this.$el.find('.' + this.classes.errorMessage);
        this.$badRequestMessage = this.$el.find('.' + this.classes.badRequestMessage);
        this.$emptyResultMessage = this.$el.find('.' + this.classes.emptyResultMessage);
        this.$filter = this.$el.find('.' + this.classes.filter);

        this.defaultParameters = {
            paths: this.$el.data('paths'),
            dateFormat: this.$el.data('dateFormat'),
            limit: this.constants.LIMIT,
            offset: 0,
            locale: CQ.I18n.getLocale()
        };
        this.defaulContext = this.createDefaultContext();
        this.isTouch = utils.hasTouchEvents();

        this.initFilters();
        this.$newsFilterA11YLayer = new NewsFilterA11YLayer($el, this, share);
        this.$newsList.on(this.isTouch ? 'click' : 'mouseover', '.' + this.classes.share, this.toggleShare.bind(this));
        this.$newsList.on('click', '.' + this.classes.socialLink, this.openPopup.bind(this));
        this.$viewMore.on('click', this.loadMoreNewsPages.bind(this));

        this.collectParametersAndLoad(true);
        this.stickyFilter();
    }

    Component.prototype.stickyFilter = function () {
        var self = this;
        this.$el.pinFilterTop(true, {
            value: 52,
            getSpacerHeight: function() {
                return self.$filter.height();
            },
        });
    };

    Component.prototype.createDefaultContext = function () {
        var socialIcons = this.$el.data('socialIcons') || '';
        return {
            socialIcons: socialIcons.split(','),
            spritePath: N & DS.spritePath,
            origin: window.location.origin,
            isAuthor: require('utils-env').isAuthor()
        };
    };

    Component.prototype.initFilters = function () {
        var $select = this.$el.find('.' + this.classes.newsFilter),
            hasNewsFilter = this.$el.data('hasNewsFilter');

        this.$year = $select.filter('.' + this.classes.year);
        this.initSelect(this.$year);
        this.collectParameters = this.collectYearParameters;

        if (hasNewsFilter) {
            this.$newsType = $select.filter('.' + this.classes.newsType);
            this.initSelect(this.$newsType);
            this.collectParameters = this.collectNewsTypeParameters;
        }

        $select.on('change', function () {
            this.collectParametersAndLoad();
            this.scrollResultsToTop();
        }.bind(this));

        var overlayScrollbarInstance = null;

        $select.on('select2:open', function (e) {
            var $list = $(e.target).parent().find('ul.select2-results__options');
            $list.unbind('mousewheel');

            var isRedesign23 = $body.hasClass('dark-mode') || $body.hasClass('light-mode');

            if (isRedesign23) {
                setTimeout(function () {
                    overlayScrollbarInstance = OverlayScrollbars($list, { className: 'os-theme-dark'});
                },10);
            }
        });

        $select.on('select2:closing', function () {
            overlayScrollbarInstance.destroy();
        });
    };

    Component.prototype.initSelect = function ($el) {
        $el.selectWoo({
            width: 'off',
            dropdownParent: $el.parent('.' + this.classes.input),
        });
        this.$selectBoxContainer = this.$el.find(this.classes.selectBoxContainer);
        this.$selectBoxContainer.addClass(this.classes.formComponentField);
    };

    Component.prototype.collectNewsTypeParameters = function () {
        return $.extend(this.collectYearParameters(), {
            newsType: this.getFilterValue(this.$newsType)
        });
    };

    Component.prototype.collectYearParameters = function () {
        return $.extend({}, this.defaultParameters, {
            year: this.getFilterValue(this.$year)
        });
    };

    Component.prototype.getFilterValue = function ($el) {
        var value = $el.val();
        if (value) {
            return value;
        }
    };

    Component.prototype.toggleShare = function (event) {
        var $currentTarget = $(event.currentTarget),
            isMobile = media.currentMode().greaterThan(media.modes.WideMobile),
            $target = $(event.target),
            openedClass = this.classes.shareOpened;

        function removeClass() {
            $currentTarget.removeClass(openedClass);
        }

        if (!isMobile && !$target.parents().hasClass(this.classes.shareMobile)) {
            return;
        } else {
            $currentTarget.addClass(openedClass);
            if (this.isTouch) {
                event.stopPropagation();
                $window.one('click', removeClass);
            } else {
                $currentTarget.one('mouseout', removeClass);
            }
        }
    };

    Component.prototype.openPopup = function (event) {
        var url = this.getLinkData(event.currentTarget);
        share.openPopup(url);
        return false;
    };

    Component.prototype.getLinkData = function (link) {
        return share.getLink($(link).data());
    };

    Component.prototype.loadMoreNewsPages = function () {
        var offset = this.$newsList.children().length,
            parameters = $.extend(this.collectParameters(), { offset: offset });

        this.loadNewsPages(parameters);
    };

    Component.prototype.collectParametersAndLoad = function (buildSchemaOrgMarkup) {
        this.loadNewsPages($.extend(this.collectParameters(), { buildSchemaOrgMarkup: buildSchemaOrgMarkup }));
    };

    Component.prototype.loadNewsPages = function (parameters) {
        $.ajax({
            url: this.constants.URL,
            data: parameters,
            beforeSend: this.toggleLoadingState.bind(this, true),
            success: this.updateNewsPages.bind(this, parameters),
            error: this.showErrorMessage.bind(this),
            complete: this.toggleLoadingState.bind(this, false),
            cache: false
        });
    };

    Component.prototype.toggleLoadingState = function (showPreloader) {
        this.$preloader.toggleClass(constants.Classes.hidden, !showPreloader);
        showPreloader && this.$errorMessage.addClass(constants.Classes.hidden);

        // if news are loaded, we animate them
        if (!showPreloader) {
            var items = document.querySelectorAll('.' + this.classes.share + ':not(.' + this.classes.animated + ')');
            var viewMore = document.querySelectorAll('.' + this.classes.viewMore);
            animations.addAppearanceAnimation(items, this.classes.animated);
            animations.addAppearanceAnimation(viewMore, this.classes.animated);
        }
    };

    Component.prototype.updateNewsPages = function (parameters, data) {
        var result = data.result,
            schemaOrgMarkup = data.schemaOrgMarkup,
            offset = parameters.offset,
            emptyResult = !result.length,
            hasMoreResults = data.total > offset + parameters.limit,
            buildSchemaOrgMarkup = !!parameters.buildSchemaOrgMarkup;
        var lastChildBeforeUpdate = this.$newsList.find(this.classes.lastNews);

        (emptyResult || !offset) && this.$newsList.empty();
        this.$emptyResultMessage.toggleClass(constants.Classes.hidden, !emptyResult);
        this.$viewMore.toggleClass(constants.Classes.hidden, !hasMoreResults);
        
        this.renderNewsPages(result);
        this.$newsFilterA11YLayer.focusFirstItemAfterLoadNewItems(lastChildBeforeUpdate);

        buildSchemaOrgMarkup && !!schemaOrgMarkup && this.addSchemaOrgMarkup(schemaOrgMarkup);
    };

    Component.prototype.renderNewsPages = function (pages) {
        var context = $.extend({ pages: pages }, this.defaulContext);
        require('utils-dust').append(this.constants.TEMPLATE, context, this.$newsList);
    };

    Component.prototype.addSchemaOrgMarkup = function (schemaOrgMarkup) {
        this.$el.prepend('<script type="application/ld+json">' + JSON.stringify(schemaOrgMarkup) + '</script>');
    };

    Component.prototype.showErrorMessage = function () {
        this.$badRequestMessage.removeClass(constants.Classes.hidden);
    };

    Component.prototype.scrollResultsToTop = function () {
        if ($body.hasClass(constants.Classes.pinnedFilter)) {
            this.$el.scrollToSelector({ duration: 500 });
        }
    };

    Component.prototype.constants = {
        URL: '/services/search/news-pages',
        TEMPLATE: 'news-list-23',
        LIMIT: 12
    };

    Component.prototype.classes = {
        selectBoxContainer: '.select2-container',
        formComponentField: 'form-component__field',
        input: 'news-filter-23__input',
        newsFilter: 'news-filter-23__select',
        newsType: 'news-filter-23__select--newstype',
        year: 'news-filter-23__select--year',
        share: 'news-filter-23__item',
        shareMobile: 'news-filter-23__share',
        shareOpened: 'news-filter-23__share--opened',
        shareButton: 'news-filter-23__share-button',
        socialLink: 'news-filter-23__social-link',
        newsList: 'news-filter-23__results',
        viewMore: 'news-filter-23__view-more',
        errorMessage: 'news-filter-23__error-message',
        badRequestMessage: 'news-filter-23--bad-request',
        emptyResultMessage: 'news-filter-23--empty-result',
        lastNews: '>li:last-child',
        newsItemIcon: 'news-filter-23__icon-item',
        filter: 'news-filter-23__filter',
        animated: 'animated',
    };

    Component.moduleName = 'News Filter 2023';
    Component.selector = '.news-filter-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('NewsFilterA11YLayer', [], function () {
  'use strict';

  var $html = $('html');

  var classes = {
    shareButton: '.news-filter-23__share-button',
    newsFilterItem: '.news-filter-23__item',
    newsFilterShareOpened: 'news-filter-23__share--opened',
    newsFilterIconsListFirstChild: '.news-filter-23__icons-list > li:first-child',
    newFilterTitle: '.news-filter-23__title',
    newsFilterTitleLink: '.news-filter-23__title a'
  };

  /**
   *
   * @param shareLib - included library from parent component
   * @constructor
   */
  function Component($el, self, shareLib) {
    this._el = $el;
    this._self = self;
    this._shareLib = shareLib;
    this.init();
  }

  Component.prototype.init = function () {
    this.initEvents();
  };

  Component.prototype.onShareButtonClickHandler = function (event) {
    var parent = $(event.target).parents(classes.newsFilterItem);

    if (parent.length) {
      parent.addClass(classes.newsFilterShareOpened);
      parent.find(classes.newsFilterIconsListFirstChild).focus();
    }
  };

  Component.prototype.onFocusinHandler = function () {
    if ($html.hasClass('key-used')) {
      var openedNews = this._el.find('.' + classes.newsFilterShareOpened);
      if (openedNews.length) {
        openedNews.removeClass(classes.newsFilterShareOpened);
      }
    }
  };

  Component.prototype.focusFirstItemAfterLoadNewItems = function (lastChild) {
    if (lastChild.length) {
      lastChild.next().find(classes.newsFilterTitleLink).focus();
    }
  };

  Component.prototype.onKeydownHandler = function (event) {
    if (event.key === 'Enter') {
      var url = this._shareLib.getLink($(event.currentTarget).children('a').data());
      this._shareLib.openPopup(url);
      return false;
    }
  };

  Component.prototype.onClickHandler = function (event) {
    var firstChild = event.target.firstChild;
    var url = this._self.getLinkData(firstChild);
    this._shareLib.openPopup(url);
    return false;
  };

  Component.prototype.initEvents = function () {
    this._el.on('click', classes.shareButton, this.onShareButtonClickHandler.bind(this));
    this._el.on('focusin', classes.newFilterTitle, this.onFocusinHandler.bind(this));
    this._self.$newsList.on('keydown', '.' + this._self.classes.newsItemIcon, this.onKeydownHandler.bind(this));
    this._self.$newsList.on('click', '.' + this._self.classes.newsItemIcon, this.onClickHandler.bind(this));
  };

  return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('MixedVacancyBlock23', ['constants', 'utm-utils'], function (constants, utmUtils) {
    'use strict';

    var $html = $('html');

    var classes = {
        placeOfWork: '.mixed-vacancy-block__place-of-work',
        buttonWrapper: '.mixed-vacancy-block__button-wrapper',
        buttonDisabled: 'mixed-vacancy-block__button-wrapper--disabled',
        checkbox: '.checkbox',
    };

    const checkboxNames = {
        office: 'office',
        home: 'home'
    };

    function Component($el) {
        this.$el = $el;
        this.$placeOfWork = this.$el.find(classes.placeOfWork);
        this.$buttonWrapper = this.$el.find(classes.buttonWrapper);
        this.$checkbox = this.$el.find(classes.checkbox);
        this.$vacancyButton = this.$buttonWrapper.find('button');
        this.$vacancyLink = this.$buttonWrapper.find('a');
        this.$inputOffice = this.$el.find('#place-of-work_office');
        this.$inputHome = this.$el.find('#place-of-work_home');
        this.$vacancyButton.on('click', this.handleButtonClick.bind(this));
        this.$placeOfWork.on('change', 'input', this.handleRadioButtonChange.bind(this));
        this.$vacancyButton.attr('disabled', true);
    }

    Component.prototype.handleRadioButtonChange = function (event) {
        const checkboxValue = $(event.target).val();
        this.$buttonWrapper.removeClass(classes.buttonDisabled);
        this.$vacancyButton.attr('disabled', false);

        if (this.$inputOffice.prop('checked') === false && this.$inputHome.prop('checked') === false) {
            this.$buttonWrapper.addClass(classes.buttonDisabled);
            this.$vacancyButton.attr('disabled', true);
        }

        if (checkboxValue === checkboxNames.office) {
            this.$vacancyLink.addClass(constants.Classes.hidden);
            this.$vacancyButton.removeClass(constants.Classes.hidden);
            this.$vacancyButton.removeAttr('aria-labelledby');
        } else if (checkboxValue === checkboxNames.home) {
            this.handleLinkClick();
            this.$vacancyLink.removeClass(constants.Classes.hidden);
            this.$vacancyButton.addClass(constants.Classes.hidden);
        }

        this.$checkbox.change(function () {
            const status = $(this).prop('checked');
            $('.checkbox').prop('checked', false);
            $(this).prop('checked', true);
            if (status === false) {
                $(this).prop('checked', false);
            }
        });

    };

    Component.prototype.handleButtonClick = function () {
        $html.trigger(constants.Events.showVacancyForm);
        this.$el.addClass(constants.Classes.hidden);
    };

    Component.prototype.handleLinkClick = function () {
        var anywhereUrlWithUtm = utmUtils.buildAnywhereUrl(this.$vacancyLink.data('href'));
        this.$vacancyLink.attr('href', anywhereUrlWithUtm);
    };

    Component.moduleName = 'Mixed Vacancy Block 23';
    Component.selector = '.mixed-vacancy-block-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('LcaListing23', ['utils-dust'], function (dust) {
    'use strict';

    function LcaListing($el) {
        var LCA_LISTING_URL = '/services/search/lca-listing',
            DUST_TEMPLATE_TABLE_ITEMS = 'lca-listing-table-items-23',
            TABLE_SORTER_ASCENDING_ORDER = 0,
            POSTING_DATE_COLUMN_INDEX = 5;

        var $self = $el,
            $errorMessage = $self.find('.ajax-error-message'),
            lcaPath = $self.data('lca-path'),
            $lcaTableWrapper = $self.find('.gray-table'),
            $lcaTable = $self.find('.lca-listing-table'),
            $emptyMessage = $self.find('.lca-listing-empty-message'),
            $disclaimer = $self.find('.lca-listing-disclaimer'),
            $preloader = $self.find('.preloader');

        if (!lcaPath) {
            return;
        }

        $.ajax({
            url: LCA_LISTING_URL,
            data: {
                lcaPath: lcaPath
            },
            cache: false,
            beforeSend: function() {
                $errorMessage.hide();
                $emptyMessage.hide();

                $preloader.addClass('preloader-blue');
            },
            success: processServerResponse,
            error: function () {
                console.error('During the search, a server error occurred.');
                $errorMessage.show();
            },
            complete: function() {
                $preloader.remove();
            }
        });

        function processServerResponse(response){
            if (response.length === 0) {
                $emptyMessage.show();
                $lcaTableWrapper.hide();
                $disclaimer.hide();
                return;
            }

            dust.append(DUST_TEMPLATE_TABLE_ITEMS, {items: response}, $lcaTable);
            $lcaTable.tablesorter({
                sortRestart: true,
                sortList: [[POSTING_DATE_COLUMN_INDEX, TABLE_SORTER_ASCENDING_ORDER]],
                headers: {
                    7: {
                        sorter: false
                    }
                }
            });
        }
    }

    LcaListing.moduleName = 'LCA Listing 2023';
    LcaListing.selector = '.lca-listing-ui-23';

    return LcaListing;
});
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('JobSearch23', [
  'RecruitingSearch23',
  'analytics',
  'utils-share',
  'constants',
  'media',
  'jquery-plugins',
// eslint-disable-next-line max-params
], function(RecruitingSearch, analytics, share, constants, media) {
  'use strict';

  var $window = $(window);
  var $body = $('body');

  var classes = $.extend({}, RecruitingSearch.prototype.classes, {
    multiselect: '.js-multi-select',
    searchSelect: '.recruiting-search__select',
    searchCheckbox: '.recruiting-search__checkbox',
    initializedMultiSelect: '.multi-select-filter',
    departments: 'job-search__departments',
    resultItem: '.search-result__item',
    shareButton: 'button.search-result__share-button-23',
    referLink: '[data-gtm-category="referral-link"]',
    shareOpened: 'search-result__share--opened',
    socialLink: '.search-result__social-link',
    submitButton: '.recruiting-search__submit',
    header: '.header-ui',
    preserveHeader: 'job-search-preserve-header',
    keywordLabel: '.recruiting-search__keyword-label',
    wrapperMobile: '.recruiting-search__wrapper-mobile',
    filterButton: '.recruiting-search__filter-button',
    filterButtonClose: 'recruiting-search__filter-button-close',
    fakePinnedInput: 'recruiting-search__fake-input',
    searchInput: 'recruiting-search__input-23:not(.recruiting-search__fake-input)',
    jobSearchOpenButton: '.recruiting-search__job-search',
    pinnedPanelCloseButton: '.recruiting-search__close-button',
    tabsComponent: '.tabs-ui-23',
  });

  var checkboxes = {
    experience: '[name="experience"]',
    relocation: '[name="relocation"]',
    remote: '[name="remote"]',
    office: '[name="office"]',
  };

  function addSocialTitleToIcon(titles) {
    return function(type) {
      return titles[type];
    };
  }

  function socialIconsReducer(prev, type) {
    prev[type] = {
      type: type,
      title: CQ.I18n.getMessage('component.general.social-icon.icon-' + type),
    };
    return prev;
  }

  /**
   * Job Search component
   * @param { jQuery } $el
   * @constructor
   */
  function Component($el) {
    RecruitingSearch.call(this, $el);
    this.$departmentsSelect = $('select[name="department"]');
    this.$jobSearchDepartments = $el.find('.job-search__departments');
    this.$isShouldUpdate = true;
    var socialIcons = this.$el.data('socialIcons');

    if (!socialIcons) {
      return;
    }

    this.titles = ['fb', 'tw', 'li', 'vk'].reduce(socialIconsReducer, {});
    this.socialIcons = this.getSocialIconsFromData(
      this.$el.data('socialIcons')
    ).map(addSocialTitleToIcon(this.titles));
    this.$fetchOptions = {
      beforeSend: function () {
        this.$departmentsSelect.trigger(constants.Events.multiSelectBeforeUpdate);
      }.bind(this),
      successCallback: function (data) {
        try {
          var result = JSON.parse(data);
          this.handleSuccessSkillsFetch(result);
        } catch (e) {
          console.warn(e);
        }
      }.bind(this)
    };
    this.$jobSearchDepartments.on('dropdown:open', function () {
      if (this.$isShouldUpdate) {
        this.$fetchOptions.url = this.createSkillsFetchRequest();
        this.fetch(this.$fetchOptions);
      }
    }.bind(this));

    this.firstDepartmentUpdate();
  }

  Component.prototype = Object.create(RecruitingSearch.prototype);

  /**
   * @inheritDoc
   * @override
   */
  Component.prototype.init = function() {
    var darkStyleApplied  = this.$el.hasClass('dark-style');
    this.$isApplyOverlay = this.$el.hasClass('apply-overlay');
    this.$mobileWrapper = this.$el.find(classes.wrapperMobile);
    this.$pinnedPanelCloseButton = this.$el.find(classes.pinnedPanelCloseButton);
    if (darkStyleApplied) {
      var openJobSearchButton = this.$el.find(classes.jobSearchOpenButton);
      openJobSearchButton.on('click', this.toggleShowForm.bind(this));
    }
    this.$filterButton = this.$el.find(classes.filterButton);
    this.$fakeSearchInput = this.$el.find('.' + classes.fakePinnedInput);
    this.$realSearchInput = this.$el.find('.' + classes.searchInput);

    this.$filterButton.removeClass(classes.filterButtonClose);
    this.$filterButton.on('click', this.toggleShowForm.bind(this));
    this.$pinnedPanelCloseButton.on('click', this.toggleShowForm.bind(this));
    this.$form.on('submit', function() {
      if (this.$form.hasClass('show')) {
        this.$form.toggleClass('show');
        this.$filterButton.toggleClass(classes.filterButtonClose);
      }
    }.bind(this));

    this.$el.attr('data-location', this.getCountry());
    this.$isPinned = this.$el.data('is-pinned');
    this.$multiSelect = this.$el.find(classes.multiselect);
    this.$searchFilters = this.$form.find(classes.searchFilter);
    this.$checkbox = this.$searchFilters.find(classes.checkbox);
    this.$header = $body.find(classes.header);
    this.$searchCheckbox = this.$el.find(classes.searchCheckbox);
    if (this.$multiSelect.length) {
      this.$multiSelect.multiSelectFilter({
        showTags: true,
        className: classes.departments,
      });
      this.$multiSelectEl = this.$el.find(classes.initializedMultiSelect);
    }

    this.$location.on(
      'select2:open',
      function() {
        this.$multiSelectEl.trigger('dropdown:close');
      }.bind(this)
    );
    this.$location.on(
      'select2:select',
      function() {
        this.setDataLocation();
        this.$isShouldUpdate = true;
      }.bind(this)
    );

    this.$results.on('click', classes.shareButton, this.toggleShare.bind(this));
    this.$results.on('click', classes.referLink, this.pushGtmEvent);
    var keyWordInputValue = this.$realSearchInput.val() || this.$fakeSearchInput.val();
    this.$realSearchInput.val(keyWordInputValue);
    this.$fakeSearchInput.val(keyWordInputValue);
    this.$fakeSearchInput.on('input keydown', this.fakeSearchInputChangeHandler.bind(this));
    this.$realSearchInput.on('input keydown', this.searchInputChangeHandler.bind(this));
    this.$fakeSearchInput.keypress(this.fakeSearchInputKeypressHandler.bind(this));
    this.$searchCheckbox.on('change', this.handlerCheckBoxSelect.bind(this));
    this.getPanelTopOffset = this.getTopOffset.bind(this);
    this.trackTabsActivity();

    if (this.$isPinned) {
      this.$searchSelect = this.$el.find(classes.searchSelect);
      this.$submitButton = this.$el.find(classes.submitButton);
      this.$el.pinFilterTop(true, {
        value: 65,
        /*
         height of mock element which occupy job-search place after it was pinned
         */
        getSpacerHeight: function() {
          if (media.currentMode().lessThan(media.modes.Desktop)) {
            return 480; //magic number
          }
          return 250; //magic number
        },
        getPanelTopOffset: this.getPanelTopOffset,
      });
      this.$header.addClass(classes.preserveHeader);
      $(window).trigger('scroll');
      this.$form.on(constants.Events.autocompleteSelected, this.autoCompleteSelectWasSelected.bind(this));
    }
  };

  /*
  this function needs to handle case when component placed inside tabs component
   */
  Component.prototype.trackTabsActivity = function () {
    var tabsComponent = this.$el.parents(classes.tabsComponent);
    if (tabsComponent.length > 0) {
      this.isVisible();
      this.getPanelTopOffset = this.getTopOffsetTabs.bind(this);
      tabsComponent.on(constants.Events.tabChange, function () {
        this.isVisible();
      }.bind(this));
    }
  };

  /*
  if component located inside tab component check if current tab is visible
   */
  Component.prototype.isVisible = function () {
    this._isActiveTab = this.$el.parents('.active').length > 0;
  };

  /**
   * 200 new dark style panel position after overlay top picture element
   */
  Component.prototype.getTopOffset = function () {
    return this.$isApplyOverlay
      ? this.$el.offset().top - 200
      : this.$el.offset().top;
  };

  Component.prototype.getTopOffsetTabs = function () {
    return this._isActiveTab? this.getTopOffset() : -1;
  };

  Component.prototype.toggleShowForm = function (state) {
    this.$form.toggleClass('show', state);
    this.$mobileWrapper.toggleClass('expanded', state);
    this.$filterButton.toggleClass(classes.filterButtonClose, state);
  };

  /**
   * called in case we have departments in URL
   */
  Component.prototype.firstDepartmentUpdate = function () {
    this.$departments = null;
    var searchParams = window.location.search;
    var urlParams = new URLSearchParams(searchParams);
    this.$departments = urlParams.getAll('department');

    if (this.$departments.length > 0) {
      var options = {
        url: this.createSkillsFetchRequest(),
        successCallback: function (data) {
          try {
            this.handleFirstSuccessSkillsFetch(JSON.parse(data));
          } catch (e) {
            console.warn(e);
          }
        }.bind(this)
      };
      this.fetch(options);
    }
  };

  Component.prototype.handlerCheckBoxSelect = function () {
    this.$isShouldUpdate = true;
  };

  Component.prototype.autoCompleteSelectWasSelected = function(event, params) {
    if (params.initialInput === 'fake') {
      this.fakeSearchInputChangeHandler();
    } else {
      this.searchInputChangeHandler();
    }
  };

  Component.prototype.fakeSearchInputChangeHandler = function() {
    this.$realSearchInput.val(this.$fakeSearchInput.val());
    this.$isShouldUpdate = true;
  };

  Component.prototype.searchInputChangeHandler = function() {
    this.$fakeSearchInput.val(this.$realSearchInput.val());
    this.$isShouldUpdate = true;
  };

  Component.prototype.fakeSearchInputKeypressHandler = function(event) {
    if (event.keyCode === 13) {
      this.$submitButton.trigger('click');
    }
  };

  Component.prototype.scrollToTop = function() {
    this.scrollResultsToTop();

    if (media.currentMode().lessThan(media.modes.Tablet)) {
      this.toggleShowForm(false);
    }
  };

  /**
   * Parse data attribute to get list of social icons
   * @param {string} data
   * @return {*|Array}
   */
  Component.prototype.getSocialIconsFromData = function(data) {
    return data && data.split(',');
  };

  /**
   * @inheritDoc
   * @override
   */
  Component.prototype.beforeLoadResults = function() {
    this.$results.on('click', classes.socialLink, this.openPopup.bind(this));
  };

  /**
   * @inheritDoc
   * @override
   */
  Component.prototype.collectSearchParameters = function(offset) {
    var searchParameters = {
      query: this.$autocomplete.val(),
      country: this.getCountry(),
      city: this.getCity(),
      sort: this.getSorting(),
      department: this.$multiSelect.val() || [],
      experience: this.getExperience(),
      relocation: this.isRelocation(),
      remote: this.isRemote(),
      office: this.isOffice(),
      offset: offset || 0,
      searchType: this.$el.data('searchtype') || '',
    };
    return $.extend({}, this.defaultSearchParameters, searchParameters);
  };

  Component.prototype.getExperience = function() {
    return this.$checkbox
      .filter(checkboxes.experience + ':checked')
      .map(function() {
        return $(this).val();
      })
      .get();
  };

  Component.prototype.isRelocation = function() {
    return this.$checkbox.filter(checkboxes.relocation + ':checked').val();
  };

  Component.prototype.isRemote = function() {
    return this.$checkbox.filter(checkboxes.remote + ':checked').val();
  };

  Component.prototype.isOffice = function() {
    return this.$checkbox.filter(checkboxes.office + ':checked').val();
  };

  /**
   * @inheritDoc
   * @override
   */
  Component.prototype.getSubmitContext = function() {
    return {
      query: this.$autocomplete.val(),
      country: this.getCountry(),
      city: this.getCity(),
      department: this.$multiSelect.val(),
      relocation: this.isRelocation(),
      office: this.isOffice(),
      remote: this.isRemote(),
    };
  };

  /**
   * @inheritDoc
   * @override
   * @return {{vacancies, spritePath: string, socialIcons: *, showFooter: boolean}}
   */
  Component.prototype.getResultsContext = function(result) {
    return {
      list: result,
      spritePath: N & DS.spritePath,
      socialIcons: this.socialIcons,
      gtmLabel: this.$el.data('referGtmLabel'),
      showFooter: true,
    };
  };

  /**
   * @inheritDoc
   * @override
   * @return {string}
   */
  Component.prototype.getResultMessageWithQuery = function(query, total) {
    var messageQuery = '"' + query + '"';

    return total === 1
      ? CQ.I18n.getMessage('component.job-search23.result_header.one_result', [
        messageQuery,
      ])
      : CQ.I18n.getMessage('component.job-search23.result_header', [
        messageQuery,
        total,
      ]);
  };

  /**
   * @inheritDoc
   * @override
   * @return {string}
   */
  Component.prototype.getResultMessage = function(total) {
    const textFor = '<span>for</span>';

    return total === 1
      ? CQ.I18n.getMessage(
        'component.redesign23.job-search.result_header.no_query.one_result', [textFor]
      )
      : CQ.I18n.getMessage('component.redesign23.job-search.result_header.no_query', [
        textFor, total,
      ]);
  };

  /**
   * @inheritDoc
   * @override
   * @return {string}
   */
  Component.prototype.getApplyButtonText = function() {
    const isResponsive = window.matchMedia('(max-width: 991px)').matches;

    return isResponsive
        ? CQ.I18n.getMessage(
            'component.job-search-23.apply'
        )
        : CQ.I18n.getMessage('component.job-search.apply'
        );
  };

  /**
   * Show/hide social icons
   * @param {Event} event - click event
   */
  Component.prototype.toggleShare = function(event) {

    var $targetShareButton = $(event.currentTarget),
      $classTarget = $targetShareButton.closest(classes.resultItem);

    function removeClass($target) {
      return function() {
        $target.removeClass(classes.shareOpened);
      };
    }

    $classTarget.addClass(classes.shareOpened);
    setTimeout(function() {
      $classTarget.find(classes.socialLink).first().focus();
    });
    $window.one('click', function() {
      $window.one('click', removeClass($classTarget));
    });
  };

  /**
   * Push GTM event for Refer button
   * @param {Event} event - click event
   */
  Component.prototype.pushGtmEvent = function(event) {
    var $targetReferButton = $(event.currentTarget);
    var gtmEvent = analytics.getEvent($targetReferButton);
    analytics.push(gtmEvent);
  };

  /**
   * Open new popup window to share
   * @param event
   * @return {boolean}
   */
  Component.prototype.openPopup = function(event) {
    var url = share.getLink($(event.currentTarget).data());
    share.openPopup(url);
    return false;
  };

  Component.prototype.setDataLocation = function() {
    var country = this.getCountry();

    this.$el.attr('data-location', country ? country : '');
  };

  /**
   * reservedSpace: 400 to adjust pinned panel position after move it over top-located component
   */
  Component.prototype.scrollResultsToTop = function() {
    if ($body.hasClass(constants.Classes.pinnedFilter)) {
      this.$el.scrollToSelector({
        duration: 500,
        reservedSpace: 400
      });
    }
  };

  Component.prototype.fetch = function (options) {
    $.ajax(options.url, {
      beforeSend: options.beforeSend,
      success: options.successCallback,
      error: function () {
        this.$departmentsSelect.trigger(constants.Events.multiSelectErrorUpdate);
      }.bind(this)
    });
  };

  Component.prototype.handleSuccessSkillsFetch = function(result) {
    this.$isShouldUpdate = false;
    var options = [];
    for (var i = 0; i < result.length; i++) {
      options.push(new Option(result[i], result[i], false, false));
    }
    this.$departmentsSelect.empty();
    this.$departmentsSelect.append(options);
    this.$departmentsSelect.trigger(constants.Events.multiSelectUpdate);
  };

  Component.prototype.handleFirstSuccessSkillsFetch = function(result) {
    this.$isShouldUpdate = false;
    var options = [];
    for (var i = 0; i < result.length; i++) {
      var isSelected = this.$departments.includes(result[i]);
      options.push(new Option(result[i], result[i], isSelected, isSelected));
    }
    this.$departmentsSelect.empty();
    this.$departmentsSelect.append(options);
    this.$departmentsSelect.trigger(constants.Events.multiSelectFirstUpdate);
    this.initSearchResult();
  };

  Component.prototype.createSkillsFetchRequest = function () {
    var parameters = this.collectSearchParameters();
    delete parameters.department;
    return this.toUrl('/services/department/search', parameters);
  };

  Component.prototype.config = {
    autocompletePath: '/services/search/smart-search.vacancy.json',
    searchUrl: '/services/vacancy/search',
  };

  Component.moduleName = 'Job Search 23';
  Component.selector = '.job-search-ui-23';

  return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ThemeSwitcher', ['constants'], function(constants) {
    'use strict';

    var $body = $(document.body);
    var classes = {
        clearAll: constants.Themes.dark + ' ' + constants.Themes.light + ' no-theme-animation',
        switcherLabel: '.theme-switcher-label',
    };
    var store = {
        key: constants.StorageKey.themeSwitcher,
        set: function (value) {
            localStorage.setItem(this.key, value);
        },
        get: function () {
            return localStorage.getItem(this.key);
        }
    };

    function Component($el) {
        this.$el = $el;
        this.init();
    }

    Component.prototype.init = function() {
        this.$el.on('click', this.toggleThemes.bind(this));
    };

    Component.prototype.toggleThemes = function(event) {
        event.stopPropagation();
        var mode = this.getMode().nextNode;
        $body.removeClass(classes.clearAll).addClass(constants.Themes.animation).addClass(mode);
        store.set(mode);
        this.triggerThemeSwitching();
        // native JS and JQuery event is not affect each other
        // they are both used in different components
        // native JS event
        var switchEvent = new CustomEvent(constants.Events.themeSwitch);
        $body[0].dispatchEvent(switchEvent);
        // JQuery event
        $body.trigger(constants.Events.themeSwitch);
    };

    /*
    adding special class to allow some components adjust color transition effect
     */
    Component.prototype.triggerThemeSwitching = function () {
        setTimeout(function () {
            $body.removeClass(constants.Themes.animation);
        }, constants.Themes.animationDuration);
    };

    Component.prototype.getMode = function () {
        if ($body.hasClass(constants.Themes.dark)) {
            return {
                currentMode: constants.Themes.dark,
                nextNode: constants.Themes.light,
            };
        }
        return {
            currentMode: constants.Themes.light,
            nextNode: constants.Themes.dark,
        };
    };

    Component.moduleName = 'Theme Switcher';
    Component.selector = '.theme-switcher-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('HeaderSearch23', ['Header23', 'media', 'constants'], function (Header, media, constants) {
    'use strict';

    var $html = $('html'),
        $overlay = $('body').children('.' + constants.Classes.overlay).last();

    var classes = {
        button: '.header-search__button',
        panel: '.header-search__panel',
        input: '.header-search__input',
        submit: '.header-search__submit',
        opened: 'opened',
        frequentSearch: '.frequent-searches-ui-23',
    };

    /**
     * HeaderSearch component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$button = this.$el.find(classes.button);
        this.$panel = this.$el.find(classes.panel);
        this.$input = this.$panel.find(classes.input);
        this.$submit = this.$panel.find(classes.submit);

        this.openPanel = this.openPanel.bind(this);
        this.closePanel = this.closePanel.bind(this);
        this.closeWhenClickedOutside = this.closeWhenClickedOutside.bind(this);
        this.onShiftTabOnButton = this.onShiftTabOnButton.bind(this);

        this.$button.one('click', this.triggerOpen);
        this.$el.on('keyup', this.onEscPress.bind(this));
        this.$submit.on('keydown', this.onTabOnSubmit.bind(this));
        this.$el.on('click', this.preventEventBubbling.bind(this));
        this.$input.on('keydown', this.preventEventBubbling.bind(this));
        Header.registerMenu({
            name: Component.moduleName,
            hasOverlay: true,
            hasDisabledScroll: function () {
                return media.currentMode().lessThan(media.modes.Desktop);
            },
            onOpen: this.openPanel,
            onClose: this.closePanel,
            closeWhenClickedOutside: this.closeWhenClickedOutside
        });
    }

    Component.prototype.preventEventBubbling = function (event) {
        event.stopPropagation();
    };

    Component.prototype.onEscPress = function (event) {
        if (event.key !== constants.Keys.esc) {
            return;
        }
        this.triggerClose();
        this.$button.focus();
    };

    Component.prototype.onTabOnSubmit = function (event) {
        if (event.key !== constants.Keys.tab || event.shiftKey) {
            return;
        }
        event.preventDefault();
        this.$button.focus();
    };

    Component.prototype.onShiftTabOnButton = function (event) {
        if (event.key !== constants.Keys.tab || !event.shiftKey) {
            return;
        }
        event.preventDefault();
        this.$submit.focus();
    };

    Component.prototype.triggerOpen = function () {
        $html.trigger(constants.Events.menuOpen, {
            opened: Component.moduleName
        });
    };

    Component.prototype.triggerClose = function () {
        $html.trigger(constants.Events.menuClose);
    };

    Component.prototype.openPanel = function () {
        this.$panel.stop(true).slideDown().queue(function () {
            this.$input.focus();
            this.$panel.addClass(classes.opened);
        }.bind(this));
        this.$button.attr('aria-expanded', true)
            .addClass(classes.opened)
            .one('click', this.triggerClose)
            .on('keydown', this.onShiftTabOnButton);
        $overlay.one('click', this.triggerClose);
    };

    Component.prototype.closePanel = function () {
        this.$input.blur();
        this.$panel.removeClass(classes.opened);
        this.$panel.stop(true).slideUp();
        $overlay.off('click', this.triggerClose);
        this.$button.attr('aria-expanded', false)
            .removeClass(classes.opened)
            .off('click', this.triggerClose)
            .one('click', this.triggerOpen)
            .off('keydown', this.onShiftTabOnButton);
    };


    Component.prototype.closeWhenClickedOutside = function () {
        var frequentSearch = this.$el.find(classes.frequentSearch);

        if (frequentSearch.length === 0) {
            this.closePanel();
            return;
        }
        if (frequentSearch.length > 0 && frequentSearch.hasClass('frequent-searches-23--hidden')) {
            this.closePanel();
        }
    };

    Component.prototype.classes = classes;

    Component.moduleName = 'Header Search 23';
    Component.selector = '.header-search-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('LocationSelector23', ['Header23', 'utils-a11y', 'constants'], function (Header, utilsA11y, constants) {
    'use strict';

    var $html = $('html'),
        $body = $('body'),
        $overlay = $body.children('.' + constants.Classes.overlay).last();

    var classes = {
        button: '.location-selector__button',
        locations: '.location-selector__panel',
        link: '.location-selector__link',
        opened: 'opened'
    };

    function triggerOpen() {
        $html.trigger(constants.Events.menuOpen, {
            opened: Component.moduleName
        });
    }

    function triggerClose() {
        $html.trigger(constants.Events.menuClose);
    }

    /**
     * Location Selector component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$button = this.$el.find(classes.button);
        this.$locations = this.$el.find(classes.locations);
        this.$lastLink = this.$locations.find(classes.link).last();

        this.hideLocations = this.toggleLocations.bind(this, false);
        this.showLocations = this.showLocations.bind(this);

        this.$button.one('click', triggerOpen);
        this.$el.on('keyup', this.closeOnEsc.bind(this));
        this.$lastLink.on('keydown', this.cycleForwardTabNavigation.bind(this));
        Header.registerMenu({
            name: Component.moduleName,
            onOpen: this.showLocations,
            onClose: this.hideLocations,
            hasOverlay: true
        });

        this.ariaLabelHidden = this.$button.attr('aria-label-hidden');
    }

    /**
     * Closes Location Selector panel on Esc keyup
     * @param {KeyboardEvent} event
     */
    Component.prototype.closeOnEsc = function (event) {
        if (event.key !== constants.Keys.esc) {
            return;
        }
        triggerClose();
        this.$button.focus();
    };

    /**
     * Cycling tab navigation (Just Tab key) inside Location Selector panel, when it is opened
     * This method is needed to prevent focusing elements, that are outside of this panel
     * @param {KeyboardEvent} event
     */
    Component.prototype.cycleForwardTabNavigation = function (event) {
        if (event.key !== constants.Keys.tab || event.shiftKey) {
            return;
        }
        event.preventDefault();
        this.$button.focus();
    };

    /**
     * Cycling tab navigation (Backwards, Tab + Shift) inside Location Selector panel, when it is opened
     * This method is needed to prevent focusing elements, that are outside of this panel
     * @param {KeyboardEvent} event
     */
    Component.prototype.cycleBackwardTabNavigation = function (event) {
        if (event.key !== constants.Keys.tab || !event.shiftKey) {
            return;
        }
        event.preventDefault();
        this.$lastLink.focus();
    };

    Component.prototype.showLocations = function () {
        this.toggleLocations(true);
        this.$button.on('keydown', this.cycleBackwardTabNavigation.bind(this));
    };

    /**
     * Opens/Closes Location Selector panel with all needed preparations/cleanup
     * @param {boolean} isOpening - is panel opening or closing
     */
    Component.prototype.toggleLocations = function (isOpening) {
        this.$button.attr('aria-label', isOpening ? this.ariaLabelHidden : '');
        this.$locations[isOpening ? 'slideDown' : 'slideUp']();
        $overlay[isOpening ? 'one' : 'off']('click', triggerClose);
        this.$button.attr('aria-expanded', isOpening)
            .toggleClass(classes.opened, isOpening)
            .off()
            .one('click', isOpening ? triggerClose : triggerOpen);
    };

    Component.moduleName = 'Location Selector';
    Component.selector = '.location-selector-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('MobileLocationSelector23', [], function () {
    'use strict';

    var $window = $(window);
    var classes = {
        button: '.mobile-location-selector__button',
        panel: '.mobile-location-selector__panel'
    };

    function Component($el) {
        this.$el = $el;
        this.$button = this.$el.find(classes.button);

        this.openMenu = this.openMenu.bind(this);
        this.closeMenu = this.closeMenu.bind(this);

        this.$button.one('click', this.openMenu);
    }

    Component.prototype.openMenu = function () {
        this.$el.addClass('opened');
        this.$button.attr('aria-expanded', true)
            .one('click', this.closeMenu);
        $window.on('click', this.closeMenu);
        this.reApplyMenuButtonFocus();
        return false;
    };

    Component.prototype.closeMenu = function () {
        this.$el.removeClass('opened');
        this.$button.attr('aria-expanded', false)
            .one('click', this.openMenu);
        $window.off('click', this.closeMenu);
        this.reApplyMenuButtonFocus();
    };

    // issue - https://jira.epam.com/jira/browse/EPMWEB-20074
    Component.prototype.reApplyMenuButtonFocus = function () {
        this.$button.blur();
        setTimeout(function () {
            this.$button.focus();
        }.bind(this), 100);
    };

    Component.moduleName = 'Location Selector Mobile';
    Component.selector = '.mobile-location-selector-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Header23', ['constants'], function (constants) {
    'use strict';

    var $html = $('html'),
        $overlay = $('body').children('.' + constants.Classes.overlay).last(),
        SMALL_HEADER_BREAKPOINT = 10;

    /**
     * Header component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$hamburgerMenu = this.$el.find('.hamburger-menu-ui-23');

        $(window).on('scroll', this.shrinkMenu.bind(this));
        $html.on(constants.Events.menuOpen, this.openMenu)
            .on(constants.Events.menuClose, this.closeMenu);
        $html.on('focusin', this.closeMenuWhenLooseFocus.bind(this));
        $(document).on('click', this.bodyClickEventHandler.bind(this));
    }

    Component.prototype.closeMenuWhenLooseFocus = function (event) {
      if (!this.$hamburgerMenu.find(event.target).length) {
        this.activeMenu = 'Hamburger Menu 23';
        this.closeMenu();
      }
    };

    Component.prototype.bodyClickEventHandler = function () {
        var currentMenu = Component.menus['Header Search 23'];
        currentMenu.closeWhenClickedOutside();
    };

    Component.prototype.openMenu = function (e, data) {
        if (!data) {
          return;
        }

        var currentMenu = Component.menus[data.opened];
        this.activeMenu && Component.menus[this.activeMenu].onClose();
        this.activeMenu = data.opened;
        currentMenu.onOpen();
        currentMenu.opened = true;
        $overlay.toggleClass(constants.Classes.hidden, !currentMenu.hasOverlay);
        var hasDisabledScroll = typeof currentMenu.hasDisabledScroll === 'function' ?
            currentMenu.hasDisabledScroll() :
            !!currentMenu.hasDisabledScroll;
        $html.toggleClass(constants.Classes.noscroll, hasDisabledScroll);
    };

    Component.prototype.closeMenu = function (e, data) {
        if (!this.activeMenu) {
            return;
        }

        var currentMenu = Component.menus[this.activeMenu],
            shouldIgnore = data && data.couldBeIgnored && currentMenu.ignoresWhenPossible,
            safeWindowClick = data && data.closed && this.activeMenu !== data.closed;

        if (shouldIgnore || safeWindowClick || currentMenu === undefined || !currentMenu.opened) {
            return;
        }

        currentMenu.onClose();
        currentMenu.opened = false;
        $overlay.addClass(constants.Classes.hidden);
        $html.removeClass(constants.Classes.noscroll);
        this.activeMenu = null;
    };

    /**
     * additionally add a class to the body to move the job-search according to the title
     */
    Component.prototype.shrinkMenu = function () {
        var scrollY = window.pageYOffset || document.documentElement.scrollTop;

        this.$el.toggleClass(this.classes.shrink, scrollY >= SMALL_HEADER_BREAKPOINT);
        $(document.body).toggleClass(this.classes.shrink, scrollY >= SMALL_HEADER_BREAKPOINT);
    };

    Component.menus = {};
    Component.registerMenu = function (params) {
        Component.menus[params.name] = {
            onOpen: params.onOpen,
            onClose: params.onClose,
            closeWhenClickedOutside: params.closeWhenClickedOutside,
            hasOverlay: params.hasOverlay,
            hasDisabledScroll: params.hasDisabledScroll,
            ignoresWhenPossible: params.ignoresWhenPossible
        };
    };

    Component.prototype.classes = {
        shrink: 'header--animated'
    };

    Component.moduleName = 'Header23';
    Component.selector = '.header-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('HamburgerMenu23', ['Header23', 'constants', 'media', 'utils'], function (Header, constants, media, utils) {
    'use strict';

    var $html = $('html'),
        $body = $('body');

    var classes = {
        button: '.hamburger-menu__button',
        menu: '.hamburger-menu__dropdown',
        menuSection: '.hamburger-menu__dropdown-section',
        accordeon: '.item--collapsed',
        thirdLevelAccordion: 'third-level-item--collapsed',
        link: '.hamburger-menu__link',
        expandedAccordeon: 'item--expanded',
        expandedThirdLevelAccordion: 'third-level-item--expanded',
        menuExpanded: 'hamburger-menu--expanded',
        child: 'item--child',
        active: '.active',
        expandChildButton: 'hamburger-menu__sub-menu-toggle-button',
        clickableLink: 'hamburger-menu__active-button',
        ctaButton: '.cta-button-ui',
        openedArrowNode: '[aria-expanded="true"]',
        hamburgerMenuList: '.hamburger-menu__list',
        thirdLevelSubMenuToggleButton: 'hamburger-menu__third-level-sub-menu-toggle-button',
        thirdLevelItem: 'hamburger-menu__third-level-item',
        firstLevelLink: 'first-level-link',
        fixedSidePanelPosition: 'fixed-position',
    };

    var mediaQueries = {
        sidePanelFixPositionQuery: '(min-width: 1920px)',
        responsive: '(min-width: 1151px)',
    };

    /**
     * HamburgerMenu component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$button = this.$el.find(classes.button);
        this.$menu = this.$el.find(classes.menu);
        this.$menuSection = this.$el.find(classes.menuSection);
        this.$hamburgerMenuList = this.$el.find(classes.hamburgerMenuList);
        this.$accordeon = this.$el.find(classes.accordeon);
        this.$thirdLevelAccordions = this.$el.find('.' + classes.thirdLevelAccordion);
        this.$link = this.$el.find(classes.link);
        var $ctaButton = this.$el.find(classes.ctaButton);
        this.$lastLink = $ctaButton.length && $ctaButton || this.$link.last();
        this.$expandChildButton = $el.find('.' + classes.expandChildButton);
        this.$expandThirdLevelChildButton = $el.find('.' + classes.thirdLevelSubMenuToggleButton);
        this.openMenu = this.openMenu.bind(this);
        this.closeMenu = this.closeMenu.bind(this);
        this.$menu.on('keyup', this.keysPressHandler.bind(this));
        this.$link.on('click', function (event) { event.stopPropagation(); });
        this.$button.one('click', this.triggerOpen);
        this.$accordeon.on('click', this.onArrowClick.bind(this));
        this.$expandChildButton.on('click', this.onRealArrowClick.bind(this));
        this.$expandThirdLevelChildButton.on('click', this.onRealArrowClick.bind(this));
        this.$clickableLinks = $el.find('.' + classes.clickableLink);
        this.$clickableLinks.on('click', this.onClickableLinkHandler.bind(this));
        Header.registerMenu({
            name: Component.moduleName,
            onOpen: this.openMenu,
            onClose: this.closeMenu,
            hasDisabledScroll: true,
            ignoresWhenPossible: true
        });
        this.expandActiveDropdown();
        this.init();
    }

    Component.prototype.init = function () {
        if (this.mediaQuery().isDesktop()) {
            $(window).on('resize', utils.debounce(this.resizeHandler.bind(this), 200));
            this.adjustSidePanelPositions();
        }

        var isRedesign23 = $body.hasClass('dark-mode') || $body.hasClass('light-mode');

        if (isRedesign23) {
            OverlayScrollbars(this.$hamburgerMenuList, { className: 'os-theme-dark hamburger-menu__scrollbar-color'});
        }
    };

    Component.prototype.resizeHandler = function () {
        this.adjustSidePanelPositions();
    };

    Component.prototype.adjustSidePanelPositions = function () {
        if (this.mediaQuery().fixedSidePanel()) {
            this.$menuSection.addClass(classes.fixedSidePanelPosition);
        } else {
            this.$menuSection.removeClass(classes.fixedSidePanelPosition);
        }
    };

    Component.prototype.onEscPress = function (event) {
        if (event.key !== constants.Keys.esc) {
            return;
        }
        this.triggerClose();
        this.$button.focus();
    };

    Component.prototype.triggerOpen = function () {
        $html.trigger(constants.Events.menuOpen, {
            opened: Component.moduleName
        });
        return false;
    };

    Component.prototype.triggerClose = function () {
        $html.trigger(constants.Events.menuClose, {
            closed: Component.moduleName
        });
    };

    Component.prototype.mediaQuery = function () {
        return {
            isDesktop: function () {
                return window.matchMedia(mediaQueries.responsive).matches;
            },
            fixedSidePanel: function () {
                return window.matchMedia(mediaQueries.sidePanelFixPositionQuery).matches;
            }
        };
    };

    Component.prototype.openMenu = function () {
        $html.addClass(classes.menuExpanded);
        this.$button.attr('aria-expanded', true)
            .one('click', this.triggerClose);
    };

    Component.prototype.closeMenu = function () {
        $html.removeClass(classes.menuExpanded);
        this.$button.attr('aria-expanded', false)
            .off()
            .one('click', this.triggerOpen);
        this.clearHoverStateFromSidePanelFirstLevelItems();
    };

    Component.prototype.clearHoverStateFromSidePanelFirstLevelItems = function() {
        var hoveredItems = this.$el.find('.hamburger-menu__link-wrapper.gradient-text-hover');
        if (hoveredItems.length) {
            hoveredItems.each(function(_, item) {
                item.classList.remove('gradient-text-hover');
                item.classList.add('gradient-text-default');
            });
        }
    };

    Component.prototype.onArrowClick = function (event) {
        var $current = $(event.target);
        if ($current.hasClass(classes.thirdLevelAccordion)) {
            $current.has('ul').length && this.toggleThirdLevelDropdown($current, event);
        } else {
            $current.has('ul').length && this.toggleDropdown($current, event);
        }
    };

    Component.prototype.onRealArrowClick = function (event) {
        var target = $(event.target);
        var parent = target.parent();
        if (target.hasClass(classes.thirdLevelSubMenuToggleButton)) {
            parent.has('ul').length && this.toggleThirdLevelDropdown(parent, event);
        } else {
            parent.has('ul').length && this.toggleDropdown(parent, event);
        }
    };

    /**
     * set aria-expanded='false' when it was closed by clicking another dropdown
     */
    Component.prototype.closedOpenedHamburgerMenuItem = function (target) {
        var prevOpenedSubMenu = this.$hamburgerMenuList.find(classes.openedArrowNode);
        if (prevOpenedSubMenu.length && !target.is(prevOpenedSubMenu)) {
            prevOpenedSubMenu.attr('aria-expanded', 'false');
        }
    };

    Component.prototype.toggleAriaAttribute = function (target) {
        target.attr('aria-expanded', function(i, val) {
            return val === 'false';
        });
    };

    Component.prototype.adjustAriaAttributes = function (event) {
        if (event) {
            var target = $(event.target);
            this.closedOpenedHamburgerMenuItem(target);
            this.toggleAriaAttribute(target);
        }
    };

    Component.prototype.toggleDropdown = function ($target, event) {
        this.adjustAriaAttributes(event);
        $target.toggleClass(classes.expandedAccordeon);
        this.$accordeon.not($target).removeClass(classes.expandedAccordeon);
    };

    Component.prototype.toggleThirdLevelDropdown = function ($target, event) {
        this.adjustAriaAttributes(event);
        $target.toggleClass(classes.expandedThirdLevelAccordion);
        this.$thirdLevelAccordions.not($target).removeClass(classes.expandedThirdLevelAccordion);
    };

    Component.prototype.expandActiveDropdown = function () {
        var activePage = this.$link.filter(classes.active);
        var parent = activePage.parent();
        if (activePage.hasClass(classes.firstLevelLink)) {
            return;
        }
        if (parent.hasClass(classes.thirdLevelItem)) {
            this.toggleThirdLevelDropdown(activePage.parents('.' + classes.thirdLevelAccordion));
        }
        this.toggleDropdown(activePage.parents(classes.accordeon));
    };

    Component.prototype.enterKeyPressHandler = function (event) {
        var keyName = event.key;
        var target = $(event.target);
        if (keyName === 'Enter' && (target.hasClass(classes.clickableLink) || target.hasClass(classes.expandChildButton))) {
            this.toggleDropdown(target.parent(), event);
        }
    };

    Component.prototype.onClickableLinkHandler = function (event) {
        var target = $(event.target);
        this.toggleDropdown(target.parent(), event);
    };

    Component.prototype.keysPressHandler = function (event) {
        this.enterKeyPressHandler(event);
        this.onEscPress(event);
    };

    Component.prototype.classes = classes;

    Component.moduleName = 'Hamburger Menu 23';
    Component.selector = '.hamburger-menu-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('TopNavigation23', ['constants', 'utils', 'gradients'], function (constants, utils, gradients) {
  'use strict';

  var $html = $('html');

  var _menuTimer = null;
  // indicate currently opened navigation menu item
  var _selectedMenuItem = null;

  var ecGradientConfig = {
    rightRatio: 0.1,
    middleRatio: 0.5,
    rte: false,
  };

  var epamGradientConfig = {
    rightRatio: 0.5,
    middleRatio: 2.5,
    rte: false,
  };

  var aiEpamGradientConfig = {
    rightRatio: 0.5,
    middleRatio: 2.5,
    rte: false,
    modeOverride: 'DARK'
  };

  var classes = {
    item: '.top-navigation__item',
    itemLink: 'top-navigation__item-link',
    dropdown: '.top-navigation__flyout',
    dropdownClassName: 'top-navigation__flyout',
    openSubmenu: 'js-opened',
    linkA11y: '.top-navigation__item-link--a11y',
    flyout: '.top-navigation__flyout-inner-section',
    topNavigationAnimation: 'top-navigation-animation',
    headerEcStyle: '.header-ec-style',
    hiddenUnderlineNode: 'hidden-underline-node',
    topNavigationSubItemsTitleText: '.top-navigation__sub-items-title-text',
    sidePanelFirstLevelLinks: '.hamburger-menu__link.first-level-link',
    sidePanelFirstLevelLinkWrapper: '.hamburger-menu__link-wrapper',
    gradientTextHover: 'gradient-text-hover',
    gradientTextDefault: 'gradient-text-default',
    gradientUnderlineNode: 'gradient-underline-node'
  };

  var animationClasses = {
    startAnimation: 'forward-animation',
    endAnimation: 'backward-animation',
    allAnimation: '.forward-animation, .backward-animation',
  };

  var NAV_MENU_ANIMATION_SPEED = 10;

  /**
   * TopNavigation component
   * @param { jQuery } $el
   * @constructor
   */
  function Component($el) {
    this.$el = $el;
    this._headerEcStyle = document.querySelector(classes.headerEcStyle);
    this._aiPage = document.body.classList.contains('ai-report-page');
    this.$items = this.$el.find(classes.item);
    this.$dropdowns = this.$el.find(classes.dropdown);
    this.$linkA11y = this.$el.find(classes.linkA11y);
    this.$flyout = this.$el.find(classes.flyout);
    this.$itemsWithSubmenu = this.$items.filter(this.hasDropdown);
    this.$lastSubLinks = $([]);
    this.$dropdowns.each(function (id, el) {
      this.$lastSubLinks = this.$lastSubLinks.add($(el).find('a').last());
    }.bind(this));
    this.bindMouseMoveHanler = utils.debounceExtend(this.mouseMoveNavigationEvent.bind(this), 50);

    this.$el.on('mouseenter ', function () {
        this.$el.on('mousemove', this.bindMouseMoveHanler);
    }.bind(this));

    this.$el.on('mouseleave', function () {
        this.closeAll();
        this.$el.off('mousemove', this.bindMouseMoveHanler);
    }.bind(this));

    this.$dropdowns.on('keydown', this.onEscOnItem.bind(this));
    this.$linkA11y.on('click', this.openSubmenuA11y.bind(this));
    this.$linkA11y.on('focus', this.closeAll.bind(this));
    this.$lastSubLinks.on('keydown', this.closeAllWithoutShiftKey.bind(this));
    $(document).on('click', this.closeAll.bind(this));
    this.$flyout.on('click', function (event) {
      event.stopPropagation();
    });

    this.initSpecialECModeGradientColors();
  }

  Component.prototype.getGradientConfig = function() {
    if (this._headerEcStyle) {
      return ecGradientConfig;
    }

    if (this._aiPage) {
      return aiEpamGradientConfig;
    }

    gradients.GradientText.prototype.getCurrentTheme.call(this);
    if (this.currentTheme === gradients.modes.EC) {
      return Object.assign(epamGradientConfig, {modeOverride: gradients.modes.DARK});
    }
    return epamGradientConfig;
  };

  Component.prototype.initSpecialECModeGradientColors = function () {
    var gradientConfig = this.getGradientConfig();

    var topPanelNodeList = document.querySelectorAll(classes.topNavigationSubItemsTitleText);
    var sidePanelNodeList = document.querySelectorAll(classes.sidePanelFirstLevelLinks);
    var topPanelNodeListArr = Array.prototype.slice.call(topPanelNodeList);
    var sidePanelNodeListArr = Array.prototype.slice.call(sidePanelNodeList);

    var nodeList = topPanelNodeListArr.concat(sidePanelNodeListArr);

    if (window.matchMedia('(min-width: 992px)').matches && !('ontouchstart' in window)) {
      this.addSidePanelGradientTextWrapperHoverEvent($(document.querySelectorAll(classes.sidePanelFirstLevelLinkWrapper)));
    }

    this.setGradientContainerBlockDisplay();
    this.splitComplexTitleIntoTwoWords(topPanelNodeListArr);
    var underlineNodeList = this.createAndGetGradientUnderlineNode(nodeList);
    this.initGradientText(nodeList, gradientConfig);
    this.initUnderlineGradient(underlineNodeList, gradientConfig);
  };

  Component.prototype.addSidePanelGradientTextWrapperHoverEvent = function(nodes) {
    var rejectActiveNodes = function(fn) {
      return function() {
        var firstChild = this.firstElementChild;

        if (firstChild && firstChild.tagName === 'A' && firstChild.classList.contains('active')) {
          return;
        }
        fn.call(this);
      };
    };

    nodes.mouseenter(rejectActiveNodes(function() {
        this.classList.add(classes.gradientTextHover);
        this.classList.remove(classes.gradientTextDefault);
    }));

    nodes.mouseleave(rejectActiveNodes(function() {
      this.classList.remove(classes.gradientTextHover);
      this.classList.add(classes.gradientTextDefault);
    }));
  };

  Component.prototype.initGradientText = function (nodeList, config) {
    this.gradientText = new gradients.GradientText();
    this.gradientText.lightInit(nodeList, config);
  };

  Component.prototype.setGradientContainerBlockDisplay = function () {
    var nodeList = document.querySelectorAll('.top-navigation__sub-items-title');
    for (var i = 0; i < nodeList.length; i++) {
      nodeList[i].classList.add('set-display-block'); //there is a problem with flex container;
    }
  };

  Component.prototype.splitComplexTitleIntoTwoWords = function (nodeList) {
    for (var i = 0; i < nodeList.length; i++) {
      var wordList = nodeList[i].textContent.trim().split(' ');
      if (wordList.length >= 2) {
        this.modifyNodeText(nodeList[i], wordList);
      }
    }
  };

  Component.prototype.createAndGetGradientUnderlineNode = function (nodeList) {
    var underlineNodeList = [];

    for (var i = 0; i < nodeList.length; i++) {
      var node = nodeList[i];
      var parent = node.parentNode;
      var cloneNode = node.cloneNode(true);
      var spanWordsInside = cloneNode.querySelectorAll('span');

      if (spanWordsInside.length > 0) {
        cloneNode.classList.add(classes.gradientUnderlineNode);
        for (var y = 0; y < spanWordsInside.length; y++) {
          var item = spanWordsInside[y];
          item.classList.add(classes.hiddenUnderlineNode);
          underlineNodeList.push(item);
        }
      } else {
        cloneNode.classList.add(classes.hiddenUnderlineNode);
        cloneNode.classList.add('single-word');
        underlineNodeList.push(cloneNode);
      }
      parent.appendChild(cloneNode);
    }

    return underlineNodeList;
  };

  Component.prototype.initUnderlineGradient = function (nodeList, config) {
    this.gradientTextUnderline = new gradients.GradientText();
    this.gradientTextUnderline.stop();
    this.gradientTextUnderline.lightInit(nodeList, config);
  };

  /**
   *
   * @param node - top navigation menu title node
   * @param wordList - array with top navigation title text, split into words
   */
  Component.prototype.modifyNodeText = function (node, wordList) {
    node.textContent = '';
    /*
     - split long title into rows.
     - move row on separate line if row length > 9
     */
    var createRow = function(word, index) {
      var nextIndex = index + 1;
      if (nextIndex >= wordList.length) {
        return {
          word: word,
          index: index
        };
      }
      var nextWord = word + ' ' + wordList[nextIndex];
      if (nextWord.length > 9) {
        return {
          word: word,
          index: index
        };
      }
      return createRow(nextWord, nextIndex);
    };

    for (var i = 0; i < wordList.length; i++) {
      var rowObj = createRow(wordList[i], i);
      i = rowObj.index;
      var span = document.createElement('span');
      span.innerHTML = rowObj.word;
      node.appendChild(span);
      node.appendChild(document.createElement('br'));
    }
  };

  Component.prototype.closeAllWithoutShiftKey = function (event) {
    if (event.shiftKey) {
      return;
    }
    this.closeAll();
  };

  Component.prototype.mouseMoveNavigationEvent = function (event) {
    var element = this.elementUnderMousePosition(event);
    if (element.hasClass(classes.itemLink) && element.hasClass('js-op')) {
      if (_selectedMenuItem === null || !_selectedMenuItem.is(element)) {
        _selectedMenuItem = element;

        var parent = element.parents(classes.item);
        this.onItemHover(parent);
      }
      return;
    }

    if (element.hasClass('top-navigation-ui-23') || element.hasClass(classes.dropdownClassName) || element.hasClass(classes.itemLink)) {
      this.closeAll();
    }
  };

  Component.prototype.onItemHover = function (parent) {
    var currentTarget = parent;
    if (_menuTimer) {
      clearTimeout(_menuTimer);
    }

    _menuTimer = setTimeout(function () {
      this.onItemLeave();
      currentTarget.one('animationend', this.forwardAnimationEnd.bind(currentTarget));
      this.openSubmenu(currentTarget);
      currentTarget.addClass(animationClasses.startAnimation);
    }.bind(this), NAV_MENU_ANIMATION_SPEED);
  };

  Component.prototype.onItemLeave = function () {
    var opened = this.$el.find('.js-opened');
    if (opened.length > 0) {
      opened.removeClass(classes.openSubmenu);
      this.showFakeBackground(true);
      this.onItemLeave();
      opened.one('animationend', this.backwardAnimationEnd.bind(opened));
      opened.addClass(animationClasses.endAnimation);
    }
  };

  Component.prototype.showFakeBackground = function (state) {
    if (state) {
      $html.addClass(classes.topNavigationAnimation);
    } else {
      $html.removeClass(classes.topNavigationAnimation);
    }
  };

  Component.prototype.elementUnderMousePosition = function (event) {
    var x = event.clientX;
    var y = event.clientY;
    return $(document.elementFromPoint(x, y));
  };

  Component.prototype.forwardAnimationEnd = function () {
    this.removeClass(animationClasses.startAnimation);
  };

  Component.prototype.backwardAnimationEnd = function () {
    this.removeClass(animationClasses.endAnimation);
  };

  Component.prototype.openSubmenuA11y = function (event) {
    event.stopPropagation();
    var $closestSubmenu = $(event.currentTarget).parents(classes.item);
    this.openSubmenu($closestSubmenu);
    $closestSubmenu.find('a').eq(1).focus();
  };

  Component.prototype.onEscOnItem = function (event) {
    if (event.key !== constants.Keys.esc) {
      return;
    }
    this.closeAll();
    $(event.currentTarget).parent().find(classes.linkA11y).focus();
  };

  Component.prototype.openSubmenu = function ($item) {
    $html.trigger(constants.Events.menuClose, {couldBeIgnored: true});
    $item.addClass(classes.openSubmenu);
  };

  Component.prototype.closeAll = function () {
    _selectedMenuItem = null;
    this.onItemLeave();
    this.showFakeBackground(false);
  };

  Component.prototype.hasDropdown = function () {
    if ($(this).children(classes.dropdown).length > 0) {
      $(this).find('.top-navigation__item-link').addClass('js-op');
      return true;
    }
    return false;
  };

  Component.moduleName = 'Top Navigation 23';
  Component.selector = '.top-navigation-ui-23';

  return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Breadcrumbs', ['media', 'constants'], function (media, constants) {
    'use strict';

    var BREADCRUMBS_TOGGLE_DELTA = 5,
        visibilityState = {
            shown: 'shown',
            hidden: 'hidden'
        },
        classes = {
            hidden: 'breadcrumbs--hidden',
            lastBreadcrumbItemLink: '.breadcrumbs__item:last > a'
        };

    var $window = $(window),
        $html = $('html');

    /**
     * Breadcrumbs component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.lastScrollTop = 0;
        this.toggleBreadcrumbs = this.toggleBreadcrumbs.bind(this);

        this.activateScroll();
        this.addA11YAttributes();
        $html.on(constants.Events.menuOpen, this.detach.bind(this))
            .on(constants.Events.menuClose, this.activate.bind(this));
    }

    Component.prototype.addA11YAttributes = function () {
        var lastBreadcrumbLink = this.$el.find(classes.lastBreadcrumbItemLink);
        if (lastBreadcrumbLink.length) {
            lastBreadcrumbLink.attr('aria-current', 'page');
        }
    };

    Component.prototype.toggleBreadcrumbs = function () {
        var isMobile = !media.currentMode().greaterThan(media.modes.Desktop),
            scrolledValue = $window.scrollTop(),
            isScrolledLessThanDelta = Math.abs(this.lastScrollTop - scrolledValue) <= BREADCRUMBS_TOGGLE_DELTA;

        if (isMobile || isScrolledLessThanDelta) {
            return;
        }

        var shouldHide = scrolledValue > this.lastScrollTop && scrolledValue >= 0,
            shouldShow = scrolledValue + $window.height() < $(document).height(),
            $el = this.$el;

        this.lastScrollTop = scrolledValue;

        if (shouldHide) {
            $el.addClass(classes.hidden).on(constants.Events.transitionEnd, function () {
                requestAnimationFrame(function () {
                    $el.addClass(constants.Classes.hidden);
                });
                $el.off(constants.Events.transitionEnd);
            });

            return;
        }
        if (shouldShow) {
            $el.removeClass(constants.Classes.hidden);
            requestAnimationFrame(function () {
                $el.removeClass(classes.hidden)
                    .off(constants.Events.transitionEnd);
            });
        }
    };

    Component.prototype.detach = function () {
        this.ignoreScroll();
        this.previousState = this.$el.hasClass(this.classes.hidden) ? visibilityState.hidden : visibilityState.shown;
        this.$el.addClass(this.classes.hidden);
    };

    Component.prototype.activate = function (e, data) {
        var isIgnored = data && data.couldBeIgnored;
        if (!this.previousState || isIgnored) {
            return;
        }
        this.activateScroll();
        this.previousState === visibilityState.shown && this.$el.removeClass(this.classes.hidden);
        this.previousState = null;
    };

    Component.prototype.ignoreScroll = function () {
        $window.off('scroll', this.toggleBreadcrumbs);
    };

    Component.prototype.activateScroll = function () {
        $window.on('scroll', this.toggleBreadcrumbs);
    };

    Component.prototype.classes = classes;

    Component.moduleName = 'Breadcrumbs';
    Component.selector = '.breadcrumbs-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('GeneralVacancyBlock23', ['constants'], function (constants) {
    'use strict';

    var $html = $('html');

    var classes = {
        vacancyForm: '.general-vacancy-form-holder'
    };

    function Component($el) {
        this.$vacancyForm = $el.find(classes.vacancyForm);
        $html.on(constants.Events.showVacancyForm, this.showVacancyForm.bind(this));
        $(document).ready(this.resizeVideos);
    }

    Component.prototype.showVacancyForm = function () {
        this.$vacancyForm.removeClass(constants.Classes.hidden);
    };

    Component.prototype.resizeVideos = function () {
        var $videos = $(document).find('.vacancy_content iframe');
        $videos.each(function () {
            var initialWidth = $(this).attr('width');
            var computedWidth = $(this).width();

            if (computedWidth < initialWidth) {
                var initialHeight = $(this).attr('height');
                var ratio = initialWidth / initialHeight;
                $(this).height(computedWidth / ratio);
            }
        });
    };

    Component.moduleName = 'General Vacancy Block 23';
    Component.selector = '.general-vacancy-block-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('FrequentSearches23', ['constants'], function (constants) {
    'use strict';

    var classes = {
        frequentSearches: '.frequent-searches-ui-23',
        hidden: 'frequent-searches-23--hidden',
        input: '.frequent-searches__input',
        headerSearchInput: '.header-search__input',
        headerSearchField: '.header-search__field',
        searchInput: '.search__input',
        searchResultsInput: '.search-results__input',
        item: '.frequent-searches__item',
        itemActive: 'frequent-searches__item--active',
        footer: '.footer-ui-23'
    };

    var $window = $(window);

    function Component($el) {
        this.$el = $el;
        this.elHeight = $el.height();
        this.$input = $(document).find(classes.input);
        this.$headerSearchField = $(document).find(classes.headerSearchField);
        this.$headerSearchInput = $(document).find(classes.headerSearchInput);
        this.$searchResultsInput = $(document).find(classes.searchResultsInput);
        this.$searchInput = $(document).find(classes.searchInput);
        this.$items = $el.find(classes.item);
        this.currentItemIndex = -1;
        this.defaultPlaceholder = this.$input.attr('placeholder');
        this.$footer = $(classes.footer);

        this.openEl = this.openEl.bind(this);
        this.closeEl = this.closeEl.bind(this);
        this.markActiveItem = this.markActiveItem.bind(this);
        this.resetActiveItem = this.resetActiveItem.bind(this);

        this.$input.attr('autocomplete', 'off');
        this.initEvents();
        this.updateHeight();
    }

    Component.prototype.initEvents = function () {
        this.$input.on('focus', this.openEl)
            .on('keyup', this.openEl);
        this.$items.on('click', this.onItemClick.bind(this));
        $window.on('resize', this.updateHeight.bind(this));
    };

    Component.prototype.updateHeight = function () {
        var footerTop = this.$footer.offset().top - 20,
            elTop = this.$el.offset().top,
            elBottom = elTop + this.elHeight;

        this.$el.css('max-height', elBottom > footerTop ? footerTop - elTop : 'none');
    };

    Component.prototype.toggleEl = function (state) {
        if ($('.header-search__button').hasClass('opened')) {
            if (state || !!this.$headerSearchInput.val().length) {
                this.resetActiveItem();
            }
            this.$headerSearchField.children(classes.frequentSearches).toggleClass(classes.hidden, state || !!this.$headerSearchInput.val().length);
            return;
        }

        if (this.$searchInput.length !== 0) {
            if (state || !!this.$searchInput.val().length) {
                this.resetActiveItem();
            }
            this.$el.toggleClass(classes.hidden, state || !!this.$searchInput.val().length);
            return;
        }

        if (this.$searchResultsInput.length !== 0) {
            if (state || !!this.$searchResultsInput.val().length) {
                this.resetActiveItem();
            }
            this.$el.toggleClass(classes.hidden, state || !!this.$searchResultsInput.val().length);
            return;
        }

        this.updateElState(state);

        if (this.$input.val().length) {
            this.$input.removeAttr('aria-describedby');
        } else {
            this.$input.attr('aria-describedby', 'search-label');
        }
    };

    Component.prototype.openEl = function () {
        this.toggleEl(false);
        $window.on('click', this.closeEl);
    };

    Component.prototype.closeEl = function (event) {
        if (event && this.$input.is(event.target)) {
            return;
        }

        this.toggleEl(true);
        $window.off('click', this.closeEl);
    };

    Component.prototype.updateElState = function (state) {
        if (!state) {
            this.$input.off('keydown');
            this.$input.on('keydown', this.onKeyDown.bind(this));
            this.updateHeight();
            return;
        }

        this.clearElState();
    };

    Component.prototype.clearElState = function () {
        this.$input.off('keydown');
        this.currentItemIndex = -1;
        this.$items.removeClass(classes.itemActive);
        this.resetActiveItem();
        this.$input.attr('placeholder', this.defaultPlaceholder);
    };

    Component.prototype.onItemClick = function (event) {
        this.$input.val(event.target.innerText).focus();
        this.closeEl();
    };

    Component.prototype.resetActiveItem = function () {
        this.$input.removeAttr('aria-activedescendant');
        this.$items.removeAttr('aria-selected id');
    };

    Component.prototype.markActiveItem = function (activeItem) {
        var activeItemId = 'selected-option';
        this.$input.attr('aria-activedescendant', activeItemId);
        activeItem.attr({
            'aria-selected': 'true',
            'id': activeItemId
        });
    };

    Component.prototype.selectItem = function (index) {
        this.activeItem = this.$items.eq(index);
        this.$items.removeClass(classes.itemActive);
        this.activeItem.addClass(classes.itemActive);
        this.resetActiveItem();
        this.markActiveItem(this.activeItem);
        this.$input.attr('placeholder', this.activeItem[0].innerText);
        this.currentItemIndex = index;
    };

    Component.prototype.selectPrev = function () {
        if (this.currentItemIndex <= 0) {
            this.selectItem(this.$items.length - 1);
            return;
        }

        this.selectItem(this.currentItemIndex - 1);
    };

    Component.prototype.selectNext = function () {
        if (this.currentItemIndex >= this.$items.length - 1) {
            this.selectItem(0);
            return;
        }

        this.selectItem(this.currentItemIndex + 1);
    };

    Component.prototype.onKeyDown = function (event) {
        switch (event.key) {
            case constants.Keys.arrowUp: {
                this.selectPrev();
                break;
            }
            case constants.Keys.arrowDown: {
                this.selectNext();
                break;
            }
            case constants.Keys.enter: {
                this.$input.removeAttr('aria-describedby');

                if (this.currentItemIndex > -1) {
                    event.preventDefault();
                    this.$input.val(this.$items.eq(this.currentItemIndex)[0].innerText);
                    this.clearElState();
                }
                break;
            }
            case constants.Keys.tab: {
                this.closeEl();
                break;
            }
            default: {
                break;
            }
        }
    };

    Component.prototype.classes = classes;

    Component.moduleName = 'Frequent Searches 23';
    Component.selector = '.frequent-searches-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Footer23', ['WeChatPopup', 'jquery-plugins'], function (WeChatPopup) {
    'use strict';

    function Component($el) {
        this.$el = $el;
        this.$linksContainer = this.$el.find('.' + this.classes.linksContainer);
        this.$weChatLink = this.$el.find('.' + this.classes.link + '[data-type="wechat"]');
        this.data = {
            src: this.$el.data('wechatQrSrc'),
            id: this.$el.data('wechatId')
        };

        $(document).ready(this.readyCallback.bind(this));

        var scrollBlocksContainers = document.querySelectorAll('.scroll-blocks-ui-23__list');

        scrollBlocksContainers.forEach(function (item) {
            if (item.childElementCount < 4) {
                $(item).addClass('scroll-blocks-ui-23__disable-scrolling');
            }
        });

        $(window).on('resize', this.removeLinksDot.bind(this));
        $.onFontLoad(this.removeLinksDot.bind(this));

        this.$weChatLink.length && this.initWeChatPopup();

        $('#scroll-top').click(function() {
            $('html, body').animate({
                scrollTop: 0
              }, 1000);
        });

        this.markEmptyItems();
        this.isSingleLine();
    }

    Component.prototype.readyCallback = function () {
        var $footerTabbableElements = this.$el.find('a, button');

        $footerTabbableElements.each(function(index, element) {
            $(element).on('focus', function() {
                this.centerElementInView($(element));
            }.bind(this));
        }.bind(this));
    };

    Component.prototype.loadCallback = function () {
        var footerLinks = this.$el.find(this.classes.footerLinks)[0];
        if (footerLinks && footerLinks.getBoundingClientRect().height < 30) {
            this.$el.addClass('single-line');
        }
    };

    Component.prototype.markEmptyItems = function () {
        this.$el.find(this.classes.couldBeEmpty).each(function (index, heading) {
            if (heading.innerText && heading.innerText.trim() === '') {
                $(heading).addClass('empty');
            }
        });
    };

    Component.prototype.isSingleLine = function () {
        window.addEventListener('load', this.loadCallback.bind(this));
    };

    Component.prototype.removeLinksDot = function () {
        var pipeClass = this.classes.pipe,
            prevElem;
        this.$linksContainer.each(function () {
            var $elem = $(this);
            $elem.toggleClass(pipeClass, $.isOffsetEqual([prevElem || $elem, $elem]));
            prevElem = $elem;
        });
    };

    Component.prototype.initWeChatPopup = function () {
        this.$popup = new WeChatPopup();

        this.$weChatLink.on('click', function (e) {
            e.preventDefault();
            this.$popup.open(this.data, this.$weChatLink);
        }.bind(this));
    };

    Component.prototype.centerElementInView = function(element) {
        var windowHeight = $(window).height();
        var elementTop = element.offset().top;
        var elementHeight = element.outerHeight();
        var scrollToPosition = elementTop - windowHeight / 2 + elementHeight / 2;

        $(window).scrollTop(scrollToPosition);
    };

    Component.prototype.classes = {
        linksContainer: 'social-links',
        link: 'social-link',
        pipe: 'item--piped',
        couldBeEmpty: '.heading, .rte',
        footerLinks: '.footer-links',
    };
    Component.selector = '.footer-ui-23';
    Component.moduleName = 'Footer23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('EventsViewer23', ['utils-dust', 'utils-env', 'animations'], function (dust, env, animations) {
    'use strict';

    function Component($el) {
        this.$el = $el;
        this.$eventsViewer = this.$el.parent('.' + this.classes.eventsViewer);
        this.$tabsContainer = this.$eventsViewer.parent('.' + this.classes.tabsItem).parent('.' + this.classes.tabsComp);
        this.$list = this.$el.find('.' + this.classes.list);
        this.$viewMore = this.$el.find('.' + this.classes.viewMore);
        this.$errorMessage = this.$el.find('.' + this.classes.ajaxError);
        this.path = this.$el.data('path');
        this.isAuthor = env.isAuthor();
        this.category = this.$el.data('category');
        this.language = CQ.I18n.getLocale();
        this.dateFormat = this.$el.data('dateFormat');

        $(window).on('load', function() {
            this.getEvents();
            this.init();
        }.bind(this));
    }

    Component.prototype.init = function () {
        this.$el.on('mouseover', '.link-with-bottom-arrow', this.hoverIn.bind(this));
        this.$el.on('mouseout', '.link-with-bottom-arrow', this.hoverOut.bind(this));
        this.$viewMore.on('click', this.getEvents.bind(this));

        if (this.$tabsContainer.length) {
            this.$tabsContainer.find('.' + this.classes.tabsLink).each(function(index, item) {
                if (!$(item).hasClass(this.classes.active)) {
                    $(item).on('click focus', this.animateActiveElements.bind(this));
                }
            }.bind(this));
        }

        this.putCorrectAriaLabelForEventList.bind(this)();
    };

    Component.prototype.animateActiveElements = function () {
        if (env.isEditMode()) {
            var $allEventsInEditMode = this.$list.find('.' + this.classes.item + ':not(.' + this.classes.animated + ')');
            animations.disableAnimationInEditMode($allEventsInEditMode.get(), this.classes.animated);
            animations.disableAnimationInEditMode(this.$viewMore.get(), this.classes.animated);
            return;
        }

        setTimeout(function() {
            var $activeTab = this.$tabsContainer.find('.' + this.classes.tabsItem + '.' + this.classes.active);
            var $activeTabEvents = $activeTab.find('.' + this.classes.item + ':not(.' + this.classes.animated + ')');
            var $activeViewMore = $activeTab.find('.' + this.classes.viewMore + ':not(.' + this.classes.animated + ')');

            if ($activeViewMore.length) {
                animations.addAppearanceAnimation($activeViewMore.get(), this.classes.animated);
            }

            if ($activeTabEvents.length) {
                animations.addAppearanceAnimation($activeTabEvents.get(), this.classes.animated);
            } else if (!$activeTab.length) {
                // In case when we don't use the Tabs component outside of our event viewer component
                var $eventsOutsideTabs = this.$list.find('.' + this.classes.item + ':not(.' + this.classes.animated + ')');
    
                if ($eventsOutsideTabs.length) {
                    animations.addAppearanceAnimation($eventsOutsideTabs.get(), this.classes.animated);
                    animations.addAppearanceAnimation(this.$viewMore.get(), this.classes.animated);
                }
            }
        }.bind(this));
    };

    Component.prototype.hoverIn = function (event) {
        var eventContainer = $(event.target).parents('.events-viewer23__item');
        eventContainer.length > 0 && eventContainer.addClass('hover');
    };

    Component.prototype.hoverOut = function (event) {
        var eventContainer = $(event.target).parents('.events-viewer23__item');
        eventContainer.length > 0 && eventContainer.removeClass('hover');
    };

    Component.prototype.getEvents = function () {
        var offset = this.$list.children().length,
            params = {
                method: 'GET',
                url: this.config.eventUrl,
                data: {
                    path: this.path,
                    category: this.category,
                    language: this.language,
                    limit: this.constants.LIMIT,
                    offset: offset,
                    dateFormat: this.dateFormat,
                    buildSchemaOrgMarkup: offset === 0,
                },
                success: this.renderEvents.bind(this),
                error: this.showErrorMessage.bind(this)
            };

        $.ajax(params);
    };

    var eventsListMarkup, firstListIsLoaded = false;

    Component.prototype.fillEventsListMarkup = function (schemaOrgMarkup) {
        if (eventsListMarkup !== null && eventsListMarkup !== undefined) {
            for (var i = 0; i < schemaOrgMarkup.itemListElement.length; i++) {
                schemaOrgMarkup.itemListElement[i].position = eventsListMarkup.itemListElement.length + i + 1;
            }
            eventsListMarkup.itemListElement = Object.values(eventsListMarkup.itemListElement).concat(Object.values(schemaOrgMarkup.itemListElement));
        } else {
            eventsListMarkup = schemaOrgMarkup;
        }
    };

    Component.prototype.renderEvents = function (data) {
        var schemaOrgMarkup = data.schemaOrgMarkup;

        if (firstListIsLoaded) {
            if (schemaOrgMarkup) {
                this.fillEventsListMarkup(schemaOrgMarkup);
            }
            if (eventsListMarkup !== null && eventsListMarkup !== undefined) {
                this.addSchemaOrgMarkup(eventsListMarkup);
            }
        } else {
            eventsListMarkup = schemaOrgMarkup;
        }
        firstListIsLoaded = true;

        var offset = this.$list.children().length;

        dust.append('events-viewer23-items', {content: data.result, isAuthor: this.isAuthor, category: this.category}, this.$list);

        this.animateActiveElements.bind(this)();

        var $items = this.$el.find('.' + this.classes.item);

        if (!($items.length <= this.constants.LIMIT)) {
            this.focusOnFirstNewItem.bind(this)(offset);
        }

        if (offset + data.result.length >= data.total) {
            return this.$viewMore.addClass(this.classes.buttonDisabled);
        }
    };

    Component.prototype.addSchemaOrgMarkup = function (schemaOrgMarkup) {
        this.$el.prepend('<script type="application/ld+json">' + JSON.stringify(schemaOrgMarkup) + '</script>');
    };

    Component.prototype.showErrorMessage = function () {
        var active = this.classes.active;
        this.$errorMessage.addClass(active);
    };

    Component.prototype.putCorrectAriaLabelForEventList = function () {
        var $tabsLinks = this.$tabsContainer.find('.' + this.classes.tabsLink); 
        var standardEventTabsQuantity = 2;

        if ($tabsLinks.length !== standardEventTabsQuantity) {
            return;
        }

        var firstTabLinkText = $tabsLinks.first().text();
        var secondTabLinkText = $tabsLinks.eq(1).text();
        var $eventsViewerLists = this.$tabsContainer.find('.' + this.classes.list);

        if ($eventsViewerLists.length === standardEventTabsQuantity) {
            var $firstEventsViewerList = $eventsViewerLists.first();
            var $secondEventsViewerList = $eventsViewerLists.eq(1);

            $firstEventsViewerList.attr('aria-label', firstTabLinkText);
            $secondEventsViewerList.attr('aria-label', secondTabLinkText);
        }
    };

    Component.prototype.centerElementInView = function (element) {
        var windowHeight = $(window).height();
        var elementTop = $(element).offset().top;
        var elementHeight = $(element).outerHeight();
        var scrollToPosition = elementTop - windowHeight / 2 + elementHeight / 2;

        $(window).scrollTop(scrollToPosition);
    };

    Component.prototype.focusOnFirstNewItem = function (offset) {
        var $firstNewItemLink = this.$list.children().eq(offset).find('.' + this.classes.itemLink);

        $firstNewItemLink.focus();
        this.centerElementInView($firstNewItemLink);
    };

    Component.prototype.classes = {
        eventsViewer: 'events-viewer',
        list: 'events-viewer23__list',
        ajaxError: 'events-viewer23__ajax-error-message',
        buttonDisabled: 'hidden',
        viewMore: 'events-viewer23__view-more',
        active: 'active',
        item: 'events-viewer23__item',
        itemLink: 'events-viewer23__title-link',
        animated: 'animated',
        tabsComp: 'tabs-ui-23',
        tabsItem: 'tabs-23__item',
        tabsLink: 'tabs-23__link'
    };

    Component.prototype.config = {
        eventUrl: '/services/search/events/viewer'
    };

    Component.prototype.constants = {
        LIMIT: 12,
    };

    Component.moduleName = 'Events Viewer 2023';
    Component.selector = '.events-viewer-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ContactDetailsReference23', ['utils', 'gradients'], function (utils, gradients) {
    'use strict';

    function Component($el) {
        utils.addExtensionToPhoneNumber($el);

        var nodes = document.querySelectorAll('.contact-details-reference__name');
        if (nodes.length > 0) {
            var N & DS_RIGHT_RATIO = 0.5;
            var N & DS_MIDDLE_RATIO = 1.4;
            var gradientText = new gradients.GradientText();
            gradientText.init(nodes, {rightRatio: N & DS_RIGHT_RATIO, middleRatio: N & DS_MIDDLE_RATIO});
        }
    }

    Component.moduleName = 'Contact Details Reference 2023';
    Component.selector = '.contact-details-reference-ui-23';

    return Component;
});



/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('BackgroundVideo23', ['utils', 'media'], function (utils, media) {
    'use strict';

    var $window = $(window),
        MENU_HEIGHT = 52;

    var classes = {
        container: '.background-video__container',
        showMobileImage: 'background-video--show-mobile-image',
        fullSizeVideo: 'background-video--match-size-of-video',
        contentPointer: 'background-video__content-pointer',
        soundIcon: 'background-video__sound-icon',
        enableSound: 'background-video__hasSound',
        showArrow: 'background-video__show-arrow',
    };

    /**
     * BackgroundVideo component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$parent = this.$el.parent('.background-video');
        this.$parent.addClass('background-video--relative');
        this.$player = this.$el.find(classes.container)[0];
        this.$contentPointer = this.$parent.find('.' + classes.contentPointer);
        this.$soundIcon = this.$parent.find('.' + classes.soundIcon);
        this.$isShowArrow = this.$el.hasClass(classes.showArrow);
        this.$playSound = this.$el.hasClass(classes.enableSound);
        $(document).ready(this.documentReadyCallback.bind(this)); //ie fix
        $window.on('scroll', utils.debounce(this.callbackFunctions.bind(this), 3));
        $window.on('resize', utils.debounce(this.callbackFunctions.bind(this), 100));
        this.$contentPointer.on('click', this.scrollToContent.bind(this));
        this.$soundIcon.on('click', this.toggleMute.bind(this));
    }

    Component.prototype.getVideoRect = function() {
        return {
          bottomY: this.$el[0].getBoundingClientRect().bottom + window.pageYOffset,
        };
    };

    Component.prototype.scrollToContent = function() {
        $('html, body').animate({ scrollTop: this.getVideoRect().bottomY - MENU_HEIGHT }, 800);
    };

    Component.prototype.callbackFunctions = function () {
        this.playPauseVideo();
        if (this.$isShowArrow) {
            this.isShowAdditionalIcons();
        }
    };

    Component.prototype.documentReadyCallback = function() {
        this.callbackFunctions();
        if (!this.$isShowArrow) {
            this.$contentPointer.addClass('hidden');
        }
    };

    Component.prototype.isShowAdditionalIcons = function() {
        if (!this.$el.hasClass(classes.fullSizeVideo)) {
            return;
        }

        var winHeight = window.innerHeight + window.pageYOffset;
        
        if (
            this.getVideoRect().bottomY > winHeight && 
            this.$el.hasClass(classes.fullSizeVideo) && 
            media.currentMode().greaterThan(media.modes.Tablet) 
            ) {
            this.$contentPointer.removeClass('hidden');
            this.$soundIcon.addClass('background-video--icon-fixed');
            return;
        }
        this.$contentPointer.addClass('hidden');
        this.$soundIcon.removeClass('background-video--icon-fixed');
    };

    Component.prototype.toggleMute = function () {
        if (this.$player.muted) {
            this.$soundIcon.addClass('background-video--sound-enabled');
            this.$player.muted = false;
        } else {
            this.$player.muted = true;
            this.$soundIcon.removeClass('background-video--sound-enabled');
        }
    };

    Component.prototype.isOnScreen = function () {
      var windowTop = $window.scrollTop(),
        windowBottom = windowTop + $window.height(),
        elTop = this.$el.offset().top,
        elMiddle = elTop + this.$el.outerHeight() / 2;

      return !(windowTop + MENU_HEIGHT > elMiddle || elMiddle > windowBottom);
    };

    Component.prototype.playPauseVideo = function () {
        var showMobileImage = this.$el.hasClass(classes.showMobileImage) && media.currentMode().lessThan(media.modes.Tablet);
        if (!showMobileImage && this.isOnScreen()) {
            this.$player.play();
            return;
        }
        this.$player.pause();
    };

    Component.selector = '.background-video-ui-23';
    Component.moduleName = 'Background Video 23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('AnywhereVacancyBlock23', ['utils', 'utm-utils'], function (utils, utmUtils) {
    'use strict';

    var classes = {
        button: '.anywhere-vacancy-block__button',
        link: '.anywhere-vacancy-block__link'
    };

    function Component($el) {
        this.el = $el;
        this.$button = $el.find(classes.button);
        this.$link = $el.find(classes.link);
        this.initRTEGradients = function() {utils.initRTEGradients(this.el);}.bind(this);

        window.addEventListener('load', this.initRTEGradients);
        window.addEventListener('resize', utils.debounceExtend(this.initRTEGradients, 300));
        
        this.handleButtonClick();
        this.handleLinkClick();
    }

    Component.prototype.handleButtonClick = function () {
        var anywhereUrlWithUtm = utmUtils.buildAnywhereUrl(this.$button.data('href'));
        this.$button.attr('href', anywhereUrlWithUtm);
    };

    Component.prototype.handleLinkClick = function () {
        var url = this.$link.data('href');

        if (url !== undefined && url.indexOf('anywhere') >= 0) {
            var anywhereUrlWithUtm = utmUtils.buildAnywhereUrl(url);
            this.$link.attr('href', anywhereUrlWithUtm);
        }
    };

    Component.moduleName = 'Anywhere Vacancy Block 23';
    Component.selector = '.anywhere-vacancy-block-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define('Anchor23', ['media'], function (media) {
    'use strict';

    var classes = {
        title: 'anchors-23__title',
        link: 'anchors-23__link',
        tabsWrapper: '.anchors-23__ul-wrapper',
        backToTopButton: '.to-top-button',
        backToTopButtonWrapper: '.to-top-button-wrapper',
        backToTopButtonContainer: '.to-top-button-container',
        open: 'open',
        active: 'active',
        hideButton: 'hide-button',
        pinnedToBottom: 'pinned-to-bottom',
    };

    /**
     * Anchors component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;

        this.selectAnchorFromHash();

        this.$el.find(classes.tabsWrapper).on('click', this.tabsWrapperClickEventHandler.bind(this));

        $(window).on('click', this.closeTabOnOutsideClick.bind(this));

        this.$el.find(classes.backToTopButton).on('click', this.backToTop.bind(this));
        $(window).on('scroll', this.backToTopButtonScrollHandler.bind(this));
        $(window).on('resize', this.backToTopButtonResizeHandler.bind(this));

        $(window).load(function() {
            this.backToTopButtonScrollHandler();
            this.backToTopButtonResizeHandler();
        }.bind(this));
    }

    Component.prototype.openDropdown = function (event) {
        var $target = $(event.target);

        if ($target.parent().hasClass(classes.title)) {
            var $tabsWrapper = this.$el.find(classes.tabsWrapper);

            if ($target.parent().hasClass(classes.active) && !$tabsWrapper.hasClass(classes.open)) {
                $tabsWrapper.addClass(classes.open);
                event.preventDefault();
                event.stopPropagation();
            } else {
                this.switchActiveAnchor(event);
            }
        }
    };

    Component.prototype.backToTop = function () {
        this.$el.scrollToSelector({
            duration: 400,
            reservedSpace: 140,
        });
    };

    Component.prototype.switchActiveAnchor = function (event) {
        var $target = $(event.target);

        if ($target.hasClass(classes.link)) {
            var $linkTitle = $target.parent('.' + classes.title);
            if (!$linkTitle.hasClass(classes.active)) {
                this.$el.find('.' + classes.title + '.' + classes.active).removeClass(classes.active);
                $linkTitle.addClass(classes.active);
            }
        }
    };

    Component.prototype.isMobileView = function () {
        return media.getViewportWidth() < media.modes.Tablet.start;
    };

    Component.prototype.tabsWrapperClickEventHandler = function (event) {
        this.isMobileView() ? this.openDropdown(event) : this.switchActiveAnchor(event);
    };

    /**
     * Scroll to tab from hash
     */
    Component.prototype.selectAnchorFromHash = function () {
        var $link = this.$el.find('a[href="' + location.hash + '"]');
        if ($link.length) {
            this.$el.find('.' + classes.title + '.' + classes.active).removeClass(classes.active);
            $link.parent('.' + classes.title).addClass(classes.active);
        }
        var $target = this.$el.find(location.hash);

        if ($target.length) {
            $(window).load(function() {
                $target.scrollToSelector();
            });
        }
    };

    Component.prototype.backToTopButtonScrollHandler = function () {
        var buttonContainer = this.$el.find(classes.backToTopButtonContainer)[0];
        var anchors = this.$el[0];
        var anchorsClientRect = anchors.getBoundingClientRect();
        if (anchorsClientRect.y < 0) {
            this.$el.removeClass(classes.hideButton);

            if (anchorsClientRect.bottom > window.innerHeight) {
                $(buttonContainer).removeClass(classes.pinnedToBottom);
            } else {
                $(buttonContainer).addClass(classes.pinnedToBottom);
            }
        } else {
            this.$el.addClass(classes.hideButton);
        }
    };

    Component.prototype.backToTopButtonResizeHandler = function () {
        var buttonWrapper = this.$el.find(classes.backToTopButtonWrapper);

        if (window.innerWidth < 1308) {
            var buttonContainer = this.$el.find(classes.backToTopButtonContainer);

            var anchorsRight = this.$el[0].getBoundingClientRect().right;
            var isResponsive = window.innerWidth < 991;
            var buttonIndentFromRightWindowBorder = isResponsive ? 0 : 15;
            var indentFromAnchorsToRightWindowBorder = window.innerWidth - anchorsRight;
            var buttonWidth = buttonContainer[0].offsetWidth;

            buttonWrapper.css('margin-right', '-' + indentFromAnchorsToRightWindowBorder + 'px');
            buttonWrapper.css('right', buttonIndentFromRightWindowBorder + buttonWidth + 'px');
        } else {
            buttonWrapper.css('margin-right', '');
            buttonWrapper.css('right', '-28px');
        }
    };

    Component.prototype.closeTabOnOutsideClick = function () {
        var tabsWrapper = this.$el.find(classes.tabsWrapper);
        tabsWrapper.hasClass(classes.open) && tabsWrapper.removeClass(classes.open);
    };

    Component.moduleName = 'Anchors-23';
    Component.selector = '.anchors-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Accordion23', ['utils', 'utils-env'], function (utils, env) {
    'use strict';

    function Component($el) {
        this.$el = $el;
        this.$accordionButton = $el.find(classes.accordionButton);
        this.$accordionTitle = $el.find(classes.accordionTitle);
        this.$accordionButtonRead = $el.find(classes.accordionButtonRead);
        this.$accordionBackgroundPanel = $el.find(classes.accordionBackgroundPanel);
        this.$accordionPasys = $el.find(classes.accordionPasys);
        this.$responsiveImages = this.$el.find(classes.responsiveImage);
        this.$accordionReadLess = $el.find(classes.accordionReadLess);
        this.$accordionArrow = $el.find(classes.accordionArrow);
        this.$accordionPreview = $el.find(classes.accordionPreview);

        this.initRTEGradients = function() {utils.initRTEGradients(this.$el);}.bind(this);
        window.addEventListener('load', this.initRTEGradients);
        window.addEventListener('resize', utils.debounceExtend(this.initRTEGradients, 300));
        
        this.init();
        var getAccordionWrapper = function(accordionElement) {
            return function(item){
                if (item.children[0]) {
                    if (item.children[0].children[0]) {
                        return item.children[0].children[0] === accordionElement.context;
                    }
                }
                return null;
            };
        };
        this.$sections = Array.prototype.slice.call(document.querySelectorAll('.section__wrapper', 0));
        this.$accordeonWrapper = this.$sections.filter(getAccordionWrapper(this.$el));
        this.$accordeonWrapper.forEach(function(item){
            item.classList.add('accordion-margin');
        });

        if (env.isEditMode()) {
            this.$accordionPasys.removeClass(classes.hidden);
        }
    }

    Component.prototype.init = function () {
        this.$accordionReadLess.text(constants.readLess);
        this.$accordionBackgroundPanel.click(this.toggleContent.bind(this, false));
        this.$accordionButtonRead.click(this.toggleContent.bind(this, true));
        var expandedAccordion = this.$accordionButton.attr(constants.showInExpandedView);

        if (this.$accordionPreview.text().trim()) {
            this.$accordionPreview.removeClass(classes.hidden);
        }

        if (expandedAccordion === 'true') {
            this.$accordionPasys.removeClass(classes.hidden);
            this.$accordionReadLess.removeClass(classes.hidden);
            this.$accordionArrow.removeClass(classes.hidden);
            this.$accordionButton.removeClass(classes.accordionButtonOpen);
            this.$accordionTitle.removeClass(classes.accordionTitleOpen);
            this.$responsiveImages.trigger(constants.renderImage);
            this.$accordionBackgroundPanel.attr('aria-label', constants.expanded);
        }
    };

    Component.prototype.toggleContent = function (needToScroll) {
        this.$responsiveImages = this.$el.find(classes.responsiveImage);
        var scrollTop = this.$el.offset().top;
        if (this.$accordionPasys.hasClass(classes.hidden)) {
            this.$accordionPasys.removeClass(classes.hidden);
            this.$accordionButton.removeClass(classes.accordionButtonOpen);
            this.$accordionTitle.removeClass(classes.accordionTitleOpen);
            this.$accordionReadLess.removeClass(classes.hidden);
            this.$accordionArrow.removeClass(classes.hidden);
            this.$responsiveImages.trigger(constants.renderImage);
            this.$accordionBackgroundPanel.attr('aria-expanded', true);
            this.$accordionBackgroundPanel.attr('aria-label', constants.expanded);
        } else {
            this.$accordionPasys.addClass(classes.hidden);
            this.$accordionButton.addClass(classes.accordionButtonOpen);
            this.$accordionTitle.addClass(classes.accordionTitleOpen);
            this.$accordionReadLess.addClass(classes.hidden);
            this.$accordionArrow.addClass(classes.hidden);
            this.$accordionBackgroundPanel.attr('aria-expanded', false);
            this.$accordionBackgroundPanel.attr('aria-label', constants.collapsed);
            if (needToScroll && $(window).width() <= constants.mobileDevice) {
                $(window).scrollTop(scrollTop - 83);
            } else if (needToScroll) {
                $(window).scrollTop(scrollTop - 95);
            }
        }
    };

    var constants = {
        readLess: Granite.I18n.get('component.accordion.read_less'),
        showInExpandedView: 'showInExpandedView',
        renderImage: 'renderImage',
        collapsed: 'collapsed',
        expanded: 'expanded',
        mobileDevice: 991
    };

    var classes = {
        accordionBackgroundPanel: '.accordion-23__background-panel',
        accordionButton: '.accordion-23__button',
        accordionTitle: '.accordion-23__title',
        accordionButtonRead: '.accordion-23__button-read',
        accordionPasys: '.accordion-23__parsys',
        responsiveImage: '.responsive-image-ui-23',
        accordionButtonOpen: 'accordion-23__button-open',
        accordionTitleOpen: 'accordion-23__title-open',
        accordionReadLess: '.accordion-23__read-less',
        accordionArrow: '.accordion-23__arrow',
        accordionPreview: '.accordion-23__preview-description',
        hidden: 'hidden'
    };

    Component.moduleName = 'Accordion-23';
    Component.selector = '.accordion-ui-23';

    return Component;
});

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Animation23', ['utils'], function (utils) {
    'use strict';

    var CLASSES = {
        ANIMATION_IMAGE_CONTAINER: 'animation__image-container'
    };

    var SCREEN_THRESHOLD_RATIO = 100;

    var Component = function () {
        function Component($el) {
            _classCallCheck(this, Component);

            this.$el = $el[0];
            this.$imageContainer = this.$el.querySelector('.' + CLASSES.ANIMATION_IMAGE_CONTAINER);
            this.imageName = $el.attr('data-image-name');
            this.isActive = true;
            this.isEditMode = $el.is('[is-edit-mode]');
            this.delayAnimation = this.loadAnimationPicture();

            this.init();
            this.initEvents();
        }

        _createClass(Component, [{
            key: 'init',
            value: function init() {
                this.onScrollChange();
            }
        }, {
            key: 'initEvents',
            value: function initEvents() {
                window.addEventListener('scroll', utils.debounce(this.onScrollChange.bind(this), 300));
                this.delayAnimation.addEventListener('data_ready', this.onAnimationLoaded.bind(this));
            }
        }, {
            key: 'onScrollChange',
            value: function onScrollChange() {
                if (this.isActive && this.isOnScreen(SCREEN_THRESHOLD_RATIO)) {
                    this.delayAnimation.play();
                    this.isActive = false;
                }
            }

            /**
             * @property screenThresholdRatio - Where on the screen should the picture be scrolled to consider it displayed.
             *                              Value from 0 to 100, 0 - top, 50 - center, 100 - bottom
             * */

        }, {
            key: 'isOnScreen',
            value: function isOnScreen(screenThresholdRatio) {
                var scrollThreshold = window.innerHeight * (screenThresholdRatio / 100) + window.scrollY;
                var imageTopPosition = window.scrollY + this.$imageContainer.getBoundingClientRect().top;
                var imageCenterPosition = imageTopPosition + this.$imageContainer.offsetHeight / 2;
                return imageCenterPosition <= scrollThreshold;
            }
        }, {
            key: 'loadAnimationPicture',
            value: function loadAnimationPicture() {
                return bodymovin.loadAnimation({
                    container: this.$imageContainer,
                    renderer: 'svg',
                    loop: false,
                    autoplay: false,
                    path: '/etc/designs/epam-com/json-animations/' + this.imageName + '.js',
                    rendererSettings: {
                        className: 'animation__svg',
                        viewBoxOnly: true
                    }
                });
            }
        }, {
            key: 'onAnimationLoaded',
            value: function onAnimationLoaded() {
                if (this.isEditMode) {
                    this.delayAnimation.goToAndPlay(this.delayAnimation.totalFrames, true);
                    this.isActive = false;
                }
            }
        }]);

        return Component;
    }();

    Component.moduleName = 'Animation23';
    Component.selector = '.animation-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('CategoriesSwitcher23', ['utils', 'utils-env', 'imager', 'constants'], function (utils, env, imager, constants) {
    'use strict';

    var CLASSES = {
        TILE: 'categories-switcher__tile-title',
        LEFT_SECTION: 'categories-switcher-left-part',
        RIGHT_SECTION: 'categories-switcher-right-part',
        ACTIVE: 'active',
        ACTIVE_TILE: '.categories-switcher__tile-title.active',
        ACTIVE_CONTENT: '.categories-switcher__content-item.active',
        CONTENT_ITEM: 'categories-switcher__content-item',
        CONTENT_ITEM_MOBILE: 'categories-switcher__content-item-mob',
        HIDE: 'hidden',
        RESPONSIVE_IMAGE: 'responsive-image-ui-23',
        TITLES_SECTION: 'categories-switcher-tiles-section',
        IMAGE_PLACEHOLDER: 'imager-placeholder',
        LIST: 'list',
        TAB_23: '.tabs-ui-23'
    };

    var VARIABLES = {
        RESPONSIVE_HEADER_HEIGHT: 52, //this value was taken from header styles;
        RESPONSIVE_TOP_INDENT: 20
    };

    var EVENTS = {
        nextSlide: 'cat.switcher.next',
        prevSlide: 'cat.switcher.prev'
    };

    var activatedComponents = [];

    var Component = function () {
        function Component($el) {
            _classCallCheck(this, Component);

            this.$el = $el;
            this.$modernEl = $el[0];
            this.$tiles = $('.' + CLASSES.TILE, this.$modernEl);
            this.$items = $('.' + CLASSES.CONTENT_ITEM, this.$modernEl);
            this.$itemsMobile = $('.' + CLASSES.CONTENT_ITEM_MOBILE, this.$modernEl);
            this.$tilesSection = this.$modernEl.querySelector('.' + CLASSES.TITLES_SECTION);
            this.itemsLength = this.$items.length;

            this.init();

            activatedComponents.push(this);
        }

        _createClass(Component, [{
            key: 'init',
            value: function init() {
                var _this = this;

                if (env.isEditMode()) {
                    this.editModeEvents();
                    return;
                }

                this.identifyDeviceType(this);
                this.initDefaultSwitcherView();
                this.addEventHandler();
                this.setTitleIndex();
                this.initEvents();
                this.specialEventForTabParent();

                document.onreadystatechange = function () {
                    if (document.readyState === 'complete') {
                        _this.preLoadImages();
                        _this.applySuperTagToTrademarkSymbols();
                    }
                };
            }
        }, {
            key: 'specialEventForTabParent',
            value: function specialEventForTabParent() {
                var _this2 = this;

                var tabParent = this.$modernEl.closest(CLASSES.TAB_23);
                if (!tabParent) {
                    return;
                }

                $(window).on(constants.Events.tabChanged, function () {
                    _this2.renderResponsiveImg(_this2.$modernEl);
                });
            }
        }, {
            key: 'setTitleIndex',
            value: function setTitleIndex() {
                $.each(this.$tiles, function (index, item) {
                    item.setAttribute('item-index', index);
                });
            }
        }, {
            key: 'nextSlide',
            value: function nextSlide() {
                var activeSlideIndex = this.$items.index(this.getActiveSlide());
                var nextSlideIndex = activeSlideIndex < this.itemsLength - 1 ? activeSlideIndex + 1 : 0;
                this.switchSlide(this.$items[nextSlideIndex]);
            }
        }, {
            key: 'prevSlide',
            value: function prevSlide() {
                var activeSlideIndex = this.$items.index(this.getActiveSlide());
                var prevSlideIndex = activeSlideIndex > 0 ? activeSlideIndex - 1 : this.itemsLength - 1;
                this.switchSlide(this.$items[prevSlideIndex]);
            }
        }, {
            key: 'switchSlide',
            value: function switchSlide(slide) {
                this.reset();

                slide.classList.remove(CLASSES.HIDE);
                slide.classList.add(CLASSES.ACTIVE);
                this.renderResponsiveImg(slide);
            }
        }, {
            key: 'getActiveSlide',
            value: function getActiveSlide() {
                return this.$modernEl.querySelector(CLASSES.ACTIVE_CONTENT);
            }
        }, {
            key: 'getActiveTitle',
            value: function getActiveTitle() {
                return this.$modernEl.querySelector(CLASSES.ACTIVE_TILE);
            }
        }, {
            key: 'reset',
            value: function reset() {
                for (var i = 0; i < this.$tiles.length; i++) {
                    this.$tiles[i].classList.remove(CLASSES.ACTIVE);
                }

                for (var _i = 0; _i < this.itemsLength; _i++) {
                    this.$items[_i].classList.remove(CLASSES.ACTIVE);
                    this.$items[_i].classList.add(CLASSES.HIDE);
                }

                if (this.$itemsMobile.length > 0) {
                    for (var _i2 = 0; _i2 < this.itemsLength; _i2++) {
                        this.$itemsMobile[_i2].classList.remove(CLASSES.ACTIVE);
                        this.$itemsMobile[_i2].style.maxHeight = null;
                    }
                }
            }
        }, {
            key: 'initDefaultSwitcherView',
            value: function initDefaultSwitcherView() {
                this.reset();

                if (this.device === 'desktop') {
                    this.$tiles[0].classList.add(CLASSES.ACTIVE);
                    this.$tiles[0].setAttribute('tabindex', 0);
                    this.$items[0].classList.add(CLASSES.ACTIVE);
                    this.$items[0].classList.remove(CLASSES.HIDE);
                }

                if (this.device === 'mobile' && !this.mobileImagesLoaded) {
                    var mobileImagesContainer = this.$modernEl.querySelector('.' + CLASSES.LEFT_SECTION);
                    this.mobileImagesLoaded = true;
                    this.renderResponsiveImg(mobileImagesContainer);
                }
            }
        }, {
            key: 'addEventHandler',
            value: function addEventHandler() {
                var _this3 = this;

                var tiles = Array.prototype.slice.call(this.$tiles);

                tiles.forEach(function (tile) {
                    tile.addEventListener('click', function (event) {
                        _this3.tileClickHandler(event.currentTarget, _this3);
                    });
                });
            }
        }, {
            key: 'mobileClickHandler',
            value: function mobileClickHandler(el, self) {
                var activeTile = this.$modernEl.querySelector(CLASSES.ACTIVE_TILE);

                if (!!activeTile && !activeTile.isEqualNode(el)) {
                    this.reset();
                }

                var content = el.nextElementSibling;

                el.classList.toggle(CLASSES.ACTIVE);
                content.classList.toggle('active');
                self.activeTile = el;
                self.activeContent = content;

                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + 'px';
                }

                this.moveContentToTop(this);
            }
        }, {
            key: 'moveContentToTop',
            value: function moveContentToTop(self) {
                if (self.activeTile !== undefined && self.activeTile.classList.contains(CLASSES.ACTIVE)) {
                    var bodyRect = document.body.getBoundingClientRect();
                    var elemRect = self.activeContent.getBoundingClientRect();

                    $('html, body').animate({
                        scrollTop: elemRect.top - bodyRect.top - VARIABLES.RESPONSIVE_HEADER_HEIGHT - VARIABLES.RESPONSIVE_TOP_INDENT
                    }, 500);
                }
            }
        }, {
            key: 'desktopClickHandler',
            value: function desktopClickHandler(el) {
                this.reset();

                var id = el.getAttribute('tile-id');
                var container = this.$modernEl.querySelector('[content-id="' + id + '"]');

                el.classList.add(CLASSES.ACTIVE);
                container.classList.add(CLASSES.ACTIVE);
                container.classList.remove(CLASSES.HIDE);

                this.renderResponsiveImg(container);
            }
        }, {
            key: 'renderResponsiveImg',
            value: function renderResponsiveImg(container) {
                var respImg = container.querySelectorAll('.' + CLASSES.RESPONSIVE_IMAGE);

                if (respImg.length > 0) {
                    $(respImg).trigger('renderImage');
                    window.dispatchEvent(new Event('resize'));
                }
            }
        }, {
            key: 'tileClickHandler',
            value: function tileClickHandler(el, self) {
                if (this.device === 'desktop') {
                    this.desktopClickHandler(el, self);
                } else {
                    this.mobileClickHandler(el, self);
                }
            }
        }, {
            key: 'identifyDeviceType',
            value: function identifyDeviceType() {
                if (window.matchMedia('(min-width: 992px)').matches) {
                    this.device = 'desktop';
                } else {
                    this.device = 'mobile';
                }
            }
        }, {
            key: 'getTitleItem',
            value: function getTitleItem(index) {
                if (index < 0) {
                    return this.$tiles[this.itemsLength - 1];
                }
                if (index > this.itemsLength - 1) {
                    return this.$tiles[0];
                }
                return this.$tiles[index];
            }
        }, {
            key: 'keyAction',
            value: function keyAction(index, event) {
                event.preventDefault();
                this.$modernEl.querySelector('[tabindex="0"]').removeAttribute('tabindex');
                var tile = this.getTitleItem(index);
                tile.setAttribute('tabindex', 0);
                tile.focus();
                this.desktopClickHandler(tile);
            }
        }, {
            key: 'arrowClickHandler',
            value: function arrowClickHandler(e) {
                if (e.keyCode === 36) {
                    this.keyAction(0, e);
                }

                if (e.keyCode === 35) {
                    this.keyAction(this.itemsLength - 1, e);
                }

                if (e.keyCode === 38 || e.keyCode === 37) {
                    var itemIndex = this.getActiveTitle().getAttribute('item-index');
                    this.keyAction(Number(itemIndex) - 1, e);
                }

                if (e.keyCode === 40 || e.keyCode === 39) {
                    var _itemIndex = this.getActiveTitle().getAttribute('item-index');
                    this.keyAction(Number(_itemIndex) + 1, e);
                }
            }
        }, {
            key: 'resizeEventCallback',
            value: function resizeEventCallback() {
                this.identifyDeviceType(this);

                if (!this.currentDevice) {
                    this.currentDevice = this.device;
                    return;
                }

                if (this.currentDevice !== this.device) {
                    this.initDefaultSwitcherView();
                    this.currentDevice = this.device;
                }
            }
        }, {
            key: 'initEvents',
            value: function initEvents() {
                var _this4 = this;

                window.addEventListener('resize', utils.debounceExtend(function () {
                    _this4.resizeEventCallback();
                }, 300));

                this.$tilesSection.addEventListener('keydown', this.arrowClickHandler.bind(this));
            }
        }, {
            key: 'editModeEvents',
            value: function editModeEvents() {
                var _this5 = this;

                this.switchSlide(this.$items[0]);
                this.$el.on(EVENTS.prevSlide, function () {
                    _this5.prevSlide();
                });
                this.$el.on(EVENTS.nextSlide, function () {
                    _this5.nextSlide();
                });
            }
        }, {
            key: 'preLoadImages',
            value: function preLoadImages() {
                var respImgPlaceHolders = activatedComponents.map(function (component) {
                    var $rightSection = component.$el.find('.' + CLASSES.RIGHT_SECTION);
                    return $rightSection.find('.' + CLASSES.IMAGE_PLACEHOLDER).toArray();
                }).flat();

                if (!respImgPlaceHolders.length) {
                    return;
                }

                respImgPlaceHolders.forEach(function (placeholder) {
                    imager.create($(placeholder));
                });
            }
        }, {
            key: 'applySuperTagToTrademarkSymbols',
            value: function applySuperTagToTrademarkSymbols() {
                var blockTitles = activatedComponents.flatMap(function (component) {
                    return Array.from(component.$modernEl.querySelector('.' + CLASSES.LEFT_SECTION).querySelectorAll('.' + CLASSES.TILE + ' .' + CLASSES.LIST));
                });

                blockTitles.forEach(function (blockTitle) {
                    blockTitle.innerHTML = blockTitle.innerHTML.replace(/®/g, '<sup>®</sup>');
                });
            }
        }]);

        return Component;
    }();

    Component.moduleName = 'CategoriesSwitcher23';
    Component.activatedComponents = activatedComponents;
    Component.events = EVENTS;
    Component.selector = '.categories-switcher-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ClientLogicPopUp23', ['utils', 'utils-env', 'ClientLogicPopUpService23'], function (utils, env, ClientPopUpService) {
    'use strict';

    var CLASSES = {
        POP_UP_CONTENT: '.pop-up__content',
        POP_UP_SUCCESS_REQUEST_MESSAGE: '.pop-up__request-message-success',
        POP_UP_ERROR_REQUEST_MESSAGE: '.pop-up__request-message-error',
        POP_UP_CLOSE_BUTTON: '.pop-up__button-close',
        POP_UP_BACKDROP: '.pop-up__backdrop',
        POP_UP_WRAPPER: '.pop-up__wrapper',
        POP_UP_FORM: '.pop-up__form',
        POP_UP_TRY_AGAIN_LINK: '.pop-up__request-message-error__link',
        POP_UP_EMAIL_INPUT: '.pop-up__email-input',
        POP_UP_HELP_SECTION: '.pop-up__help',
        TEXT_FIELD_UI: '.text-field-ui',
        VALIDATION_TOOLTIP: '.validation-tooltip',
        VALIDATION_TEXT: '.validation-text',
        SUBMIT_BUTTON: '.custom-button',
        BUTTON_SUBMIT_LOADING_GIF: '.spinner-button.custom-button',
        REMEMBER_ME: '.remember-me .custom-checkbox-input',
        POP_UP_HELP_LINK: '.pop-up__help-link',
        HAMBURGER_MENU_BUTTON: '.hamburger-menu__button',
        POP_UP_HELP_LOADING_GIF: '.pop-up__help-loading'
    };

    var hamburgerMenuBreakPoint = '(max-width: 1129px)';

    var Component = function () {
        function Component(el) {
            _classCallCheck(this, Component);

            this._el = el[0];
            this.$rememberMe = this._el.querySelector(CLASSES.REMEMBER_ME);
            this.$popUpHelpLink = this._el.querySelector(CLASSES.POP_UP_HELP_LINK);
            this.$popUpContent = this._el.querySelector(CLASSES.POP_UP_CONTENT);
            this.$successMessage = this._el.querySelector(CLASSES.POP_UP_SUCCESS_REQUEST_MESSAGE);
            this.$errorMessage = this._el.querySelector(CLASSES.POP_UP_ERROR_REQUEST_MESSAGE);
            this.$popUpCloseButton = this._el.querySelector(CLASSES.POP_UP_CLOSE_BUTTON);
            this.$popUpBackDrop = this._el.querySelector(CLASSES.POP_UP_BACKDROP);
            this.$popUpWrapper = this._el.querySelector(CLASSES.POP_UP_WRAPPER);
            this.$popUpForm = this._el.querySelector(CLASSES.POP_UP_FORM);
            this.$popUpTryAgainLink = this._el.querySelector(CLASSES.POP_UP_TRY_AGAIN_LINK);
            this.$popUpEmailInput = this._el.querySelector(CLASSES.POP_UP_EMAIL_INPUT);
            this.$textFieldUI = this._el.querySelector(CLASSES.TEXT_FIELD_UI);
            this.$popUpValidationTooltip = this._el.querySelector(CLASSES.VALIDATION_TOOLTIP);
            this.$popUpValidationText = this._el.querySelector(CLASSES.VALIDATION_TEXT);
            this.$popUpHelpSection = this._el.querySelector(CLASSES.POP_UP_HELP_SECTION);
            this.$submitButton = this._el.querySelector(CLASSES.SUBMIT_BUTTON);
            this.$buttonSubmitLoadingGifs = this._el.querySelectorAll(CLASSES.BUTTON_SUBMIT_LOADING_GIF);
            this.$popUpHelpLoadingGif = this._el.querySelector(CLASSES.POP_UP_HELP_LOADING_GIF);
            this.$hamburgerMenuButton = document.body.querySelector(CLASSES.HAMBURGER_MENU_BUTTON);
            this.isAuthor = env.isAuthor();
            this.setCurrentClientLoginButtonAndEvent();
            this.initEvents();
            this.$clientPopUpService = new ClientPopUpService(this);
        }

        _createClass(Component, [{
            key: 'validateEmail',
            value: function validateEmail(email) {
                var re = /^(?=.{1,65}$)[a-zA-Z0-9!#$%&'*+\-/=?^_`{|}~]+(\.[a-zA-Z0-9!#$%&'*+\-/=?^_`{|}~]+)*@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.[a-zA-Z]{2,}$/;
                return re.test(email);
            }
        }, {
            key: 'setCurrentClientLoginButtonAndEvent',
            value: function setCurrentClientLoginButtonAndEvent() {
                var isHamburgerMenu = window.matchMedia(hamburgerMenuBreakPoint).matches;

                if (isHamburgerMenu) {
                    this.isAuthor ? this.$clientLoginButtons = document.body.querySelectorAll('a[href="/content/infongen/en/client-login.html"]') : this.$clientLoginButtons = document.body.querySelectorAll('a[href="/client-login"]');
                } else {
                    this.isAuthor ? this.$clientLoginButtons = document.body.querySelectorAll('a[href="/content/infongen/en/client-login.html"]') : this.$clientLoginButtons = document.body.querySelectorAll('a[href="/client-login"]');
                }
            }
        }, {
            key: 'initEvents',
            value: function initEvents() {
                var _this6 = this;

                this.$clientLoginButtons.forEach(function (item) {
                    item.addEventListener('click', _this6.openPopUp.bind(_this6));
                });
                window.addEventListener('resize', utils.debounce(this.setCurrentClientLoginButtonAndEvent.bind(this), 300));
                this.$popUpCloseButton && this.$popUpCloseButton.addEventListener('click', this.closePopUp.bind(this));
                this.$popUpTryAgainLink && this.$popUpTryAgainLink.addEventListener('click', this.resetPopUpWithNeedHelpSection.bind(this));
                this.$popUpBackDrop && this.$popUpBackDrop.addEventListener('mousedown', this.closePopUp.bind(this));
                this.$popUpWrapper && this.$popUpWrapper.addEventListener('mousedown', function (e) {
                    return e.stopPropagation();
                });
                this.$popUpEmailInput && this.$popUpEmailInput.addEventListener('change', this.isEmailValid.bind(this));
            }
        }, {
            key: 'isEmailValid',
            value: function isEmailValid() {
                var emailValue = this.$popUpEmailInput.value;
                var isValid = this.validateEmail(emailValue);

                if (isValid) {
                    this.$textFieldUI.classList.remove('validation-field');
                } else {
                    this.$textFieldUI.classList.add('validation-field');
                    !emailValue.length ? this.$popUpValidationText.textContent = 'This is required field' : this.$popUpValidationText.textContent = 'Incorrect email format';
                    this.$popUpEmailInput.focus();
                }
                return isValid;
            }
        }, {
            key: 'resetPopUpWithNeedHelpSection',
            value: function resetPopUpWithNeedHelpSection(event) {
                var showHelpSection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

                if (event) {
                    event.preventDefault();
                }

                this.$errorMessage.classList.remove('active');
                this.$errorMessage.classList.add('hidden');

                this.$successMessage.classList.remove('active');
                this.$successMessage.classList.add('hidden');

                this.$popUpContent.classList.remove('hidden');
                this.$popUpContent.classList.add('active');

                this._el.classList.remove('show-unknown-email-error');

                if (showHelpSection) {
                    this.showHelpSection();
                } else {
                    this.hideHelpSection();
                }
            }
        }, {
            key: 'showHelpSection',
            value: function showHelpSection() {
                this.$popUpHelpSection.classList.remove('hidden');
                this.$popUpHelpSection.classList.add('active');
            }
        }, {
            key: 'hideHelpSection',
            value: function hideHelpSection() {
                this.$popUpHelpSection.classList.add('hidden');
                this.$popUpHelpSection.classList.remove('active');
            }
        }, {
            key: 'closePopUp',
            value: function closePopUp() {
                this.$clientLoginButtons.forEach(function (item) {
                    item.classList.remove('active');
                });
                this._el.classList.add('hidden');
                this._el.classList.remove('active');
                this.resetPopUpWithNeedHelpSection(null, false);
                this.hideSpinner();
            }
        }, {
            key: 'closeHamburgerMenu',
            value: function closeHamburgerMenu() {
                var isHamburgerMenuOpen = document.querySelector('html').classList.contains('hamburger-menu--expanded');
                isHamburgerMenuOpen && this.$hamburgerMenuButton.click();
            }
        }, {
            key: 'remembermeProxy',
            value: function remembermeProxy(normalFlow, alternativeFlow) {
                var isRememberMe = this.getCookieByName('rememberme');
                if (isRememberMe === 'true') {
                    normalFlow && normalFlow();
                } else {
                    alternativeFlow && alternativeFlow();
                }
            }
        }, {
            key: 'openPopUp',
            value: function openPopUp(e) {
                var _this7 = this;

                e.preventDefault();
                this.remembermeProxy(function () {
                    _this7.$submitButton.click();
                }, function () {
                    _this7.showPopupWindow();
                });
            }
        }, {
            key: 'showPopupWindow',
            value: function showPopupWindow() {
                this.closeHamburgerMenu();
                this.$clientLoginButtons.forEach(function (item) {
                    item.classList.add('active');
                });

                this._el.classList.remove('hidden');
                this._el.classList.add('active');
            }
        }, {
            key: 'getCookieByName',
            value: function getCookieByName(cookieName) {
                var matches = document.cookie.match(new RegExp('(?:^|; )' + cookieName.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + '=([^;]*)'));
                return matches ? decodeURIComponent(matches[1]) : undefined;
            }
        }, {
            key: 'showSpinner',
            value: function showSpinner() {
                this.$submitButton.setAttribute('disabled', true);
                this.$buttonSubmitLoadingGifs.forEach(function (item) {
                    item.classList.add('active');
                });
            }
        }, {
            key: 'hideSpinner',
            value: function hideSpinner() {
                this.$submitButton.removeAttribute('disabled');
                this.$buttonSubmitLoadingGifs.forEach(function (item) {
                    item.classList.remove('active');
                });
            }
        }, {
            key: 'showHelpSectionSpinner',
            value: function showHelpSectionSpinner() {
                this.$popUpHelpLoadingGif.classList.remove('hidden');
                this.$popUpHelpLoadingGif.classList.add('active');
                this.$popUpHelpLink.classList.remove('active');
                this.$popUpHelpLink.classList.add('hidden');
            }
        }, {
            key: 'hideHelpSectionSpinner',
            value: function hideHelpSectionSpinner() {
                this.$popUpHelpLoadingGif.classList.add('hidden');
                this.$popUpHelpLoadingGif.classList.remove('active');
                this.$popUpHelpLink.classList.add('active');
                this.$popUpHelpLink.classList.remove('hidden');
            }

            /**
             *
             * @param messageType - error or success
             */

        }, {
            key: 'showMessage',
            value: function showMessage(messageType) {
                this.$popUpContent.classList.remove('active');
                this.$popUpContent.classList.add('hidden');
                this._el.classList.remove('show-unknown-email-error');
                if (messageType === 'error') {
                    this.$errorMessage.classList.remove('hidden');
                    this.$errorMessage.classList.add('active');
                } else {
                    this.$successMessage.classList.remove('hidden');
                    this.$successMessage.classList.add('active');
                }
            }
        }, {
            key: 'showUnknownEmailError',
            value: function showUnknownEmailError() {
                this._el.classList.add('show-unknown-email-error');
            }
        }]);

        return Component;
    }();

    Component.moduleName = 'Client Login pop-up 2023';
    Component.selector = '.client-logic-pop-up-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ClientLogicFetchService23', [], function () {
    'use strict';

    var handlerErrors = function handlerErrors(response, errorCallback) {
        if (!response.ok) {
            errorCallback && errorCallback();
            throw Error(response.statusText);
        }
        return response;
    };

    var sendRequest = function sendRequest(options) {
        var url = options.url,
            data = options.data,
            successCallback = options.successCallback,
            errorCallback = options.errorCallback;
        //currently project is using YUI Compressor which has knows issue with promise catch block

        fetch(url, data).then(function (response) {
            return handlerErrors(response, errorCallback);
        }).then(function (response) {
            successCallback(response);
        });
    };

    return {
        sendRequest: sendRequest
    };
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ClientLogicPopUpService23', ['ClientLogicFetchService23'], function (fetchService) {
    'use strict';

    var CLASSES = {
        popup: '.client-logic-pop-up-ui-23 script', recaptcha: '.recaptcha-ui.g-recaptcha'
    };

    var EVENTS = {
        popupLoaded: 'recaptcha.event.loaded', fetchSend: 'fetched.send'
    };

    var URLS = {
        captchaValidation: '/services/recaptcha/validation',
        infongenContentPath: '/content/infongen/en',
        supportEmailUrl: '/services/notify/infongen-support-team?userEmail='
    };

    var INFONGEN_REQUEST_OPTIONS = {
        method: 'GET',
        headers: {
            'Referer': 'https://www.infongen.com/'
        }
    };

    var Component = function () {
        function Component(popupInstance) {
            _classCallCheck(this, Component);

            this._popupComponent = popupInstance;
            this.$recaptchaOnloadScript = document.querySelector(CLASSES.popup);
            this.$isRecaptchaLaoded = false;
            this.init();
        }

        _createClass(Component, [{
            key: 'init',
            value: function init() {
                this.initEvents();
            }
        }, {
            key: 'initEvents',
            value: function initEvents() {
                var _this8 = this;

                this._popupComponent.$popUpForm.addEventListener('submit', function (event) {
                    return _this8.handlePopupFormSubmit(event);
                });
                this._popupComponent._el.addEventListener(EVENTS.popupLoaded, function (event) {
                    return _this8.handleRecaptchaScriptLoaded(event);
                });
                this._popupComponent.$popUpHelpLink.addEventListener('click', function () {
                    return _this8.sendEmailToSupport();
                });
            }
        }, {
            key: 'handleRecaptchaScriptLoaded',
            value: function handleRecaptchaScriptLoaded() {
                this.renderRecaptchaForm();
                grecaptcha.execute(this.$recaptchaId);
            }
        }, {
            key: 'sendRecaptcha',
            value: function sendRecaptcha() {
                this._popupComponent.showSpinner();
                this.loadRecaptcha();
            }
        }, {
            key: 'loadRecaptcha',
            value: function loadRecaptcha() {
                if (!this.$isRecaptchaLaoded) {
                    this.createAndAddReCaptchaScript();
                } else {
                    grecaptcha.execute(this.$recaptchaId);
                }
            }
        }, {
            key: 'handlePopupFormSubmit',
            value: function handlePopupFormSubmit(event) {
                var _this9 = this;

                event.preventDefault();
                this._popupComponent.remembermeProxy(function () {
                    _this9.sendRecaptcha();
                }, function () {
                    if (!_this9._popupComponent.isEmailValid()) {
                        return;
                    }
                    _this9.sendRecaptcha();
                });
            }
        }, {
            key: 'createAndAddReCaptchaScript',
            value: function createAndAddReCaptchaScript() {
                var script = document.createElement('script');
                script.setAttribute('src', 'https://www.google.com/recaptcha/api.js?onload=onloadCallback&render=explicit');
                script.defer = true;
                script.async = true;
                this._popupComponent._el.insertBefore(script, this.$recaptchaOnloadScript);
                this.$isRecaptchaLaoded = true;
            }
        }, {
            key: 'renderRecaptchaForm',
            value: function renderRecaptchaForm() {
                var siteKey = document.querySelector('#popup-recaptcha-container').dataset.sitekey;
                this.$recaptchaId = grecaptcha.render('popup-recaptcha-container', {
                    'sitekey': siteKey,
                    'callback': this.recaptchaOnExecuteHandler.bind(this),
                    'size': 'invisible'
                });
            }
        }, {
            key: 'getPagePath',
            value: function getPagePath() {
                var regex = /\.[^.]*$/;
                var currentUrlLocation = window.location.pathname.replace(regex, '');
                return currentUrlLocation.includes(URLS.infongenContentPath) ? currentUrlLocation : URLS.infongenContentPath + currentUrlLocation;
            }
        }, {
            key: 'recaptchaErrorCallback',
            value: function recaptchaErrorCallback() {
                grecaptcha.reset(this.$recaptchaId);
                this.showErrorMessage();
                this._popupComponent.hideSpinner();
                this.saveToCookie('rememberme', 'false');
            }
        }, {
            key: 'recaptchaOnExecuteHandler',
            value: function recaptchaOnExecuteHandler(responseKey) {
                var _this10 = this;

                fetchService.sendRequest({
                    url: URLS.captchaValidation + '?currentPage=' + this.getPagePath() + '&g-recaptcha-response=' + responseKey,
                    body: {
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        }
                    },
                    successCallback: function successCallback(response) {
                        return _this10.handleRecaptchaSuccessfulResponse(response);
                    },
                    errorCallback: function errorCallback() {
                        return _this10.recaptchaErrorCallback();
                    }
                });
            }

            /**
             *
             * @param response has two options false/true
             * @returns {Promise<void>}
             */

        }, {
            key: 'handleRecaptchaSuccessfulResponse',
            value: function handleRecaptchaSuccessfulResponse(response) {
                var _this11 = this;

                response.json().then(function (result) {
                    if (result) {
                        _this11.sendEmailToInfongen();
                    } else {
                        _this11.recaptchaErrorCallback();
                    }
                });
            }
        }, {
            key: 'getUserEmail',
            value: function getUserEmail() {
                var _this12 = this;

                var userEmail = null;
                this._popupComponent.remembermeProxy(function () {
                    userEmail = _this12._popupComponent.getCookieByName('client-login-user-email');
                }, function () {
                    userEmail = _this12._popupComponent.$popUpEmailInput.value;
                });
                return this.escapeUserLogin(userEmail);
            }
        }, {
            key: 'sendEmailToInfongen',
            value: function sendEmailToInfongen() {
                var _this13 = this;

                var infongenEndPoint = document.querySelector('.client-logic-pop-up-ui-23').dataset.endPoint;
                fetchService.sendRequest({
                    url: '' + infongenEndPoint + this.getUserEmail(),
                    data: INFONGEN_REQUEST_OPTIONS,
                    successCallback: function successCallback(response) {
                        _this13.infongenFinalActions();
                        _this13.handleInfongenSuccessResponse(response);
                    },
                    errorCallback: function errorCallback() {
                        _this13.infongenFinalActions();
                        _this13.showErrorMessage();
                        _this13.saveToCookie('rememberme', 'false');
                    }
                });
            }
        }, {
            key: 'handleInfongenSuccessResponse',
            value: function handleInfongenSuccessResponse(response) {
                var _this14 = this;

                response.text().then(function (result) {
                    var isEmpty = result.length === 0;
                    if (isEmpty) {
                        _this14._popupComponent.showPopupWindow();
                        _this14._popupComponent.resetPopUpWithNeedHelpSection();
                        _this14._popupComponent.showUnknownEmailError();
                        _this14.setPreviousEmail();
                    } else {
                        if (_this14._popupComponent.$rememberMe.checked) {
                            _this14.saveToCookie('rememberme', 'true');
                            _this14.saveToCookie('client-login-user-email', _this14._popupComponent.$popUpEmailInput.value);
                        }
                        window.location.href = result;
                    }
                });
            }
        }, {
            key: 'infongenFinalActions',
            value: function infongenFinalActions() {
                this._popupComponent.hideSpinner();
                grecaptcha.reset(this.$recaptchaId);
            }
        }, {
            key: 'setPreviousEmail',
            value: function setPreviousEmail() {
                var _this15 = this;

                this._popupComponent.remembermeProxy(function () {
                    var email = _this15._popupComponent.getCookieByName('client-login-user-email');
                    _this15._popupComponent.$popUpEmailInput.value = email;
                });
            }
        }, {
            key: 'saveToCookie',
            value: function saveToCookie(key, value) {
                if (value.trim().length !== 0) {
                    document.cookie = key + '=' + value;
                }
            }
        }, {
            key: 'escapeUserLogin',
            value: function escapeUserLogin(login) {
                return encodeURI(login);
            }
        }, {
            key: 'showErrorMessage',
            value: function showErrorMessage() {
                this._popupComponent.showPopupWindow();
                this._popupComponent.showMessage('error');
                this.saveToCookie('rememberme', 'false');
            }
        }, {
            key: 'showSuccessMessage',
            value: function showSuccessMessage() {
                this._popupComponent.showPopupWindow();
                this._popupComponent.showMessage();
                this.saveToCookie('rememberme', 'false');
            }
        }, {
            key: 'hidePopUpHelpAndSpinner',
            value: function hidePopUpHelpAndSpinner() {
                this._popupComponent.hideHelpSectionSpinner();
                this._popupComponent.hideHelpSection();
            }
        }, {
            key: 'sendEmailToSupport',
            value: function sendEmailToSupport() {
                var _this16 = this;

                if (!this._popupComponent.isEmailValid()) {
                    return;
                }

                this._popupComponent.showHelpSectionSpinner();

                fetchService.sendRequest({
                    url: '' + URLS.supportEmailUrl + this.getUserEmail(),
                    data: INFONGEN_REQUEST_OPTIONS,
                    successCallback: function successCallback() {
                        _this16.hidePopUpHelpAndSpinner();
                        _this16.showSuccessMessage();
                    },
                    errorCallback: function errorCallback() {
                        _this16.hidePopUpHelpAndSpinner();
                        _this16.showErrorMessage();
                    }
                });
            }
        }]);

        return Component;
    }();

    Component.moduleName = 'Client Login pop-up 2023';

    return Component;
});

/*
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ColumnControl23', ['media', 'utils'], function (media, utils) {
    'use strict';

    var CLASSES = {
        COLUMN_CONTROL_HOLDER: 'colctrl__holder',
        TWO_COLUMNS_FOR_RESPONSIVE: 'colctrl--two-columns-for-responsive',
        HIDE_COLUMN_ON_RESPONSIVE: ' colctrl__col--hide-on-responsive',
        RESPONSIVE_COLUMN: ['colctrl__col', 'colctrl__col--width-50', 'colctrl__col--hide-on-desktop'],
        RESPONSIVE_COLUMN_PADDINGS: ['colctrl__col--top-0', 'colctrl__col--right-0', 'colctrl__col--bottom-0', 'colctrl__col--left-0']
    };

    var CONSTANTS = {
        LOGICAL_BLOCK_ELEMENTS_NUMBER: 2,
        RESPONSIVE_COLUMNS_NUMBER: 2
    };

    var Component = function () {
        function Component(el) {
            _classCallCheck(this, Component);

            this.el = el[0];
            this.twoColumnsForResponsive = this.el.classList.contains(CLASSES.TWO_COLUMNS_FOR_RESPONSIVE);

            if (this.twoColumnsForResponsive) {
                this.initResponsiveColumns();
                if (this.originalColumnsHolders.length !== CONSTANTS.RESPONSIVE_COLUMNS_NUMBER) {
                    this.setColumns();
                    window.addEventListener('resize', utils.debounceExtend(this.setColumns.bind(this), 500));
                }
            }
        }

        _createClass(Component, [{
            key: 'initResponsiveColumns',
            value: function initResponsiveColumns() {
                var _this17 = this;

                this.originalColumnsHolders = [].concat(_toConsumableArray(this.el.getElementsByClassName(CLASSES.COLUMN_CONTROL_HOLDER)));
                if (this.originalColumnsHolders.length === CONSTANTS.RESPONSIVE_COLUMNS_NUMBER) {
                    return;
                }

                var columnTag = this.originalColumnsHolders[0].parentElement ? this.originalColumnsHolders[0].parentElement.tagName : 'div';
                var holderTag = this.originalColumnsHolders[0].tagName;

                this.originalColumnsElements = this.originalColumnsHolders.map(function (element) {
                    return [].concat(_toConsumableArray(element.children));
                });
                this.isResponsiveView = false;

                // eslint-disable-next-line no-return-assign
                [].concat(_toConsumableArray(this.el.children)).forEach(function (column) {
                    return column.classList += CLASSES.HIDE_COLUMN_ON_RESPONSIVE;
                });

                var columnsElements = [].concat(_toConsumableArray(this.el.querySelectorAll('.' + CLASSES.COLUMN_CONTROL_HOLDER + ' > *')));
                var logicalBlocksNumber = columnsElements.length / CONSTANTS.LOGICAL_BLOCK_ELEMENTS_NUMBER;
                var firstColumnElementsNumber = Math.ceil(logicalBlocksNumber / CONSTANTS.RESPONSIVE_COLUMNS_NUMBER) * CONSTANTS.LOGICAL_BLOCK_ELEMENTS_NUMBER;

                this.responsiveColumnsElements = [columnsElements.slice(0, firstColumnElementsNumber), columnsElements.slice(firstColumnElementsNumber)];
                this.responsiveColumnsHolders = this.responsiveColumnsElements.map(function () {
                    var _column$classList;

                    var column = document.createElement(columnTag);
                    var columnHolder = document.createElement(holderTag);
                    (_column$classList = column.classList).add.apply(_column$classList, _toConsumableArray(CLASSES.RESPONSIVE_COLUMN).concat(_toConsumableArray(CLASSES.RESPONSIVE_COLUMN_PADDINGS)));
                    columnHolder.classList.add(CLASSES.COLUMN_CONTROL_HOLDER);
                    column.appendChild(columnHolder);
                    _this17.el.appendChild(column);
                    return columnHolder;
                });
            }
        }, {
            key: 'setColumns',
            value: function setColumns() {
                var _this18 = this;

                var isResponsive = window.matchMedia('(max-width: 767px)').matches;

                if (isResponsive === this.isResponsiveView) {
                    return;
                }

                if (this.isResponsiveView) {
                    this.originalColumnsHolders.forEach(function (columnHolder, index) {
                        columnHolder.append.apply(columnHolder, _toConsumableArray(_this18.originalColumnsElements[index]));
                    });
                } else {
                    this.responsiveColumnsHolders.forEach(function (columnHolder, index) {
                        columnHolder.append.apply(columnHolder, _toConsumableArray(_this18.responsiveColumnsElements[index]));
                    });
                }

                this.isResponsiveView = !this.isResponsiveView;
            }
        }]);

        return Component;
    }();

    Component.moduleName = 'Column Control 23';
    Component.selector = '.colctrl-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('DetailPagesFilter23', ['utils-dust', 'utils-env', 'constants', 'jquery-plugins'], function (dust, env, constants) {
    'use strict';

    var classes = {
        industries: '.detail-pages-filter-23__select--industries',
        contentTypes: '.detail-pages-filter-23__select--content-types',
        topics: '.detail-pages-filter-23__select--topics',
        detailPagesMainList: '.detail-pages-list--main',
        detailPagesSecondaryList: '.detail-pages-list--secondary',
        detailPagesList: ' .detail-pages-list-ui__holder',
        detailPagesListNotEmpty: 'detail-pages-list__holder--not-empty',
        viewMore: '.detail-pages-filter-23__view-more',
        viewMoreLink: '.detail-pages-filter-23__view-more-button',
        lastRowItem: 'detail-pages-list-23__item-last-row',
        message: '.detail-pages-filter-23__error-message',
        topPanel: '.detail-pages-filter-23',
        detailPagesLink: '.detail-pages-list-23__link',
        filterComponent: '.detail-pages-filter-23-ui',
        filterContainer: '.detail-pages-filter-23__filter-wrap',
        filterDropdownContainer: '.detail-pages-filter-23__filter-list-wrap',
        filterSelected: 'detail-pages-filter-23__filter_selected',
        filterPanel: '.detail-pages-filter-23__filter-top',
        filterPanelStickyTop: 'detail-pages-filter-23-ui_sticky-fixed',
        filterPanelStickyBottom: 'detail-pages-filter-23-ui_sticky-absolute',
        filterPanelSpacer: '.detail-pages-filter-23__filter-panel-spacer',
        filterPanelBtn: '.detail-pages-filter-23__filter-panel-btn',
        filterExpanded: 'detail-pages-filter-23__filter_expanded',
        filterListItem: '.detail-pages-filter-23__filter-list-item',
        filterListItemActive: 'detail-pages-filter-23__filter-list-item_active',
        filterListItemIcon: '.detail-pages-filter-23__link-icon',
        filterSelectedCount: '.detail-pages-filter-23__filter-list-selected-count',
        filterClearParametersBtn: '.detail-pages-filter-23__filter-list-btn-clear',
        filterApplyBtn: '.gradient-border-button',
        filterApplyBtnDisabled: 'custom-button-disabled',
        filterTags: '.detail-pages-filter-23__filter-tags',
        filterTagsNotEmpty: 'detail-pages-filter-23__filter-tags-not-empty',
        filterTagItem: '.detail-pages-filter-23__filter-tag-item',
        filterTagItemClear: '.detail-pages-filter-23__filter-tag-item_clear',
        filterClearTagsBtn: '.detail-pages-filter-23__filter-tags-btn-clear',
        filterRemoveTagBtn: '.detail-pages-filter-23__filter-tag-btn-remove',
        filterPanelHasPinned: 'detail-pages-filter-23_has-pinned',
        filterDataIdAttr: 'data-filter-id',
        filterTagDataIdAttr: 'data-filter-tag-id',
        infoMessage: '.detail-pages-list-ui__info-block',
        filterTitle: '.detail-pages-filter-23__title',
        breadcrumbs: '.breadcrumbs-ui-23',
        pageHeader: '.header-ui-23',
        headerState: 'releasing-header',
        image: '.detail-pages-list-23__img-inner',
        imageContainer: '.detail-pages-list-23__img',
        errorImage: 'error-image',
        empty: 'empty'
    };

    var $body = $(document.body);

    var config = {
        URL: '/services/search/detail-pages.json',
        DEFAULT_URL: '/services/search/detail-pages.default.json',
        TEMPLATE: 'detail-pages-list-23',
        DEFAULT_IMAGE: '/etc/designs/epam-com/images/detail-page/default-filter-image.jpg',
        ROW_LENGTH: 3,
        LIMIT: 9,
        TOPICS_COUNT: 'component.detail-pages-filter.topics-count',
        FILTER_STORE_NAME: 'filtersStore'
    };

    var messagesKeys = {
        ajaxErrorMessage: 'component.general.ajax-error-message',
        ajaxErrorTryAgain: 'component.general.ajax-error-try-again',
        searchNoResults: 'component.detail-pages-filter.search-no-results',
        searchEmptyResult: 'component.general.search-empty-result-for-'
    };

    var FilterScrollOffset = 62;
    var FilterScrollOffsetWithTitle = 0;
    var FilterScrollOffsetWithTitleMobile = 25;
    var MobileBreakpoint = 992;

    var viewType = {
        filter: 'filter',
        careersBlog: 'careers-blog',
        downloadPdf: 'downloadPdf'
    };

    /**
     * Detail Pages Filter component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.$el = $el;
        this.$detailPagesMainList = this.$el.find(classes.detailPagesMainList + classes.detailPagesList);
        this.$detailPagesSecondaryList = this.$el.find(classes.detailPagesSecondaryList + classes.detailPagesList);
        this.$viewMore = this.$el.find(classes.viewMore);
        this.$viewMoreLink = this.$viewMore.find(classes.viewMoreLink);
        this.$preloader = this.$el.find('.' + constants.Classes.preloader);
        this.$message = this.$el.find(classes.message);
        this.$messageText = this.$message.find('p');
        this.$topPanel = this.$el.find(classes.topPanel);
        this.contentReferenceLabelsView = this.$el.data('content-reference-labels-view');
        this.viewType = this.$el.data('viewType');
        this.isDownloadable = this.viewType === viewType.downloadPdf;
        this.$filterWrapper = this.$el.find(classes.filterDropdownContainer);
        this.$filterTitle = this.$el.find(classes.filterTitle);
        this.$filterContainer = this.$el.find(classes.filterContainer);
        this.$filterPanel = this.$el.find(classes.filterPanel);
        this.$filterPanelBtn = this.$el.find(classes.filterPanelBtn);
        this.$filterSelectedCount = this.$el.find(classes.filterSelectedCount);
        this.$filterClearParametersBtn = this.$el.find(classes.filterClearParametersBtn);
        this.$filterListItem = this.$el.find(classes.filterListItem);
        this.$filterListItemIcon = this.$el.find(classes.filterListItemIcon);
        this.$filterApplyBtn = this.$el.find(classes.filterApplyBtn);
        this.$filterTags = this.$el.find(classes.filterTags);
        this.$filterTagItemClear = this.$el.find(classes.filterTagItemClear);
        this.$filterClearTagsBtn = this.$el.find(classes.filterClearTagsBtn);
        this.isAuthor = env.isAuthor();
        this.paths = this.$el.data('paths') || '';
        this.$infoMessage = this.$el.find(classes.infoMessage);
        this.$pageHeader = $(classes.pageHeader);
        this.defaultParameters = {
            paths: this.paths.split(','),
            limit: config.LIMIT,
            offset: 0,
            viewType: this.viewType,
            hideTags: !this.isDownloadable
        };
        this.filtersStore = {
            filters: [],
            filtersChecked: []
        };

        this.initViewType();

        this.$viewMoreLink.on('click', this.loadMoreDetailPages.bind(this));
        this.focusOnFirstLoadedItem.bind(this);
    }

    Component.prototype.initViewType = function () {
        var _this19 = this;

        this.$filterPanelBtn.on('click', this.toggleFilterList.bind(this));
        this.$filterContainer.on('click', classes.filterListItem, this.toggleFilterListItem.bind(this));
        this.$filterContainer.on('click', classes.filterRemoveTagBtn, this.removeFilterTag.bind(this));
        this.$filterClearParametersBtn.on('click', this.clearAllFilterParameters.bind(this));
        this.$filterClearTagsBtn.on('click', this.clearAllFilterTags.bind(this));
        this.$filterApplyBtn.on('click', function (_ref) {
            var target = _ref.target;

            if (!target.classList.contains('custom-button-disabled')) {
                _this19.applyFilters();
            }
        });
        this.stickHeader();
        this.closeOnClickOutside();
        this.filtersStore.filters = $('[' + classes.filterDataIdAttr + ']').map(function (_, el) {
            return { value: $(el).attr('' + classes.filterDataIdAttr), label: $(el).text().trim() };
        }).get();
        var self = this;
        window.addEventListener('load', function () {
            // 'performance.navigation.type === performance.navigation.TYPE_BACK_FORWARD' is deprecated but was added for Safari.
            // Modern 'performance.getEntriesByType('navigation')' doesn't support in Safari.
            if (window.performance && window.performance.getEntriesByType('navigation').length && performance.getEntriesByType('navigation')[0].type === 'back_forward' || performance.navigation.type === performance.navigation.TYPE_BACK_FORWARD) {
                self.filtersStore.filtersChecked = self.getFilterLocalStorage();
            }

            self.collectParametersAndLoad(true).done(function () {
                self.updateFilterView();
                self.updateFilterTagsView();
            });
        });

        this.$filterWrapper.length > 0 && this.$filterWrapper[0].addEventListener('contextmenu', this.contextmenuEventCallback);
    };

    Component.prototype.contextmenuEventCallback = function (e) {
        e.preventDefault();
        var clickEvent = new MouseEvent('click', {
            bubbles: true
        });
        e.target.dispatchEvent(clickEvent);
    };

    Component.prototype.stickHeader = function () {
        var $parent = this.$el;
        var $child = $parent.find(classes.filterPanel);
        var $spacer = $parent.find(classes.filterPanelSpacer);
        var skipFirstScroll = true;

        function handleScroll() {
            // Fix for https://jira.epam.com/jira/browse/EPMWEB-23506 issue. Filter panel wrong position after page routing forward and backward
            if (skipFirstScroll) {
                skipFirstScroll = false;
                return;
            }

            var pageHeaderHeight = this.$pageHeader.height();
            var childOffset = $spacer[0].getBoundingClientRect().top - $parent[0].getBoundingClientRect().top;
            var parentTop = $parent[0].getBoundingClientRect().top + childOffset - pageHeaderHeight || 0;
            var crossChildHeight = 0;

            if ($child.height() > $parent[0].getBoundingClientRect().bottom) {
                crossChildHeight = $parent[0].getBoundingClientRect().bottom - $child.height();
            }

            if (parseInt(crossChildHeight) < 0) {
                $parent.removeClass(classes.filterPanelStickyTop);
                $parent.addClass(classes.filterPanelStickyBottom);
                $body.removeClass(classes.filterPanelHasPinned);
            } else {
                $parent.removeClass(classes.filterPanelStickyBottom);

                if (parentTop <= crossChildHeight) {
                    $parent.addClass(classes.filterPanelStickyTop);
                    $body.addClass(classes.filterPanelHasPinned);
                    this.releaseHeader();
                } else {
                    $parent.removeClass(classes.filterPanelStickyTop);
                    $body.removeClass(classes.filterPanelHasPinned);
                }
            }
        }

        document.addEventListener('scroll', handleScroll.bind(this));
    };

    Component.prototype.releaseHeader = function () {
        this.$pageHeader[0].removeEventListener('transitionend', this.headerAnimationEventHandler);
        this.$pageHeader[0].addEventListener('transitionend', this.headerAnimationEventHandler, { once: true });
        $body.addClass(classes.headerState);
    };

    Component.prototype.headerAnimationEventHandler = function () {
        if (!$body.hasClass(classes.filterPanelHasPinned)) {
            $body.removeClass(classes.headerState);
        }
    };

    Component.prototype.closeOnClickOutside = function () {
        var self = this;

        document.addEventListener('click', function handleClickOutsideBox(event) {
            var $target = $(event.target);

            if (!$target.closest(classes.filterDropdownContainer).length && $(classes.filterContainer).hasClass(classes.filterExpanded) && !$target.closest(classes.filterPanelBtn).length) {
                self.toggleFilterList();
            }
        });
    };

    Component.prototype.toggleFilterList = function () {
        this.$filterWrapper.animate({ scrollTop: '0px' }, 0);
        this.$filterContainer.toggleClass(classes.filterExpanded);
    };

    Component.prototype.toggleFilterListItem = function (e) {
        var $target = $(e.target);

        if (!$target.attr(classes.filterDataIdAttr)) {
            $target = $(e.target.parentElement.parentElement);
        }

        var selectedFilterId = $target.attr(classes.filterDataIdAttr);
        var filterChecked = this.filtersStore.filtersChecked.find(function (filter) {
            return filter.value === selectedFilterId;
        });

        if (filterChecked) {
            if (filterChecked.applied) {
                filterChecked.selected = !filterChecked.selected;
            } else {
                this.filtersStore.filtersChecked = this.filtersStore.filtersChecked.filter(function (filter) {
                    return filter.value !== selectedFilterId;
                });
            }
        } else {
            var filter = this.filtersStore.filters.find(function (el) {
                return el.value === selectedFilterId;
            });

            filter = Object.assign({}, filter, {
                selected: true,
                applied: false
            });
            this.filtersStore.filtersChecked.push(filter);
        }

        this.updateFilterView();
    };

    Component.prototype.clearAllFilterParameters = function () {
        this.filtersStore.filtersChecked.forEach(function (filter) {
            filter.selected = false;
        });
        this.updateFilterView();
    };

    Component.prototype.clearAllFilterTags = function () {
        this.removeFilterTags();
        this.filtersStore.filtersChecked = [];
        this.updateFilterView();
        this.collectParametersAndLoad();
    };

    Component.prototype.removeFilterTag = function (e) {
        var $btn = $(e.target);
        var $parent = $(e.target).closest('li');
        var id = $btn.attr(classes.filterTagDataIdAttr);
        this.filtersStore.filtersChecked = this.filtersStore.filtersChecked.filter(function (filter) {
            return filter.value !== id;
        });
        $parent.remove();
        this.updateFilterView();
        this.collectParametersAndLoad();
    };

    Component.prototype.removeFilterTags = function () {
        this.$filterTagItemClear.nextAll().remove();
    };

    Component.prototype.applyFilters = function () {
        var _this20 = this;

        var isSticky = this.$filterPanel.attr('class').split(/\s+/).some(function (item) {
            return item === 'sticky';
        });

        var titleOffset = window.innerWidth < MobileBreakpoint ? FilterScrollOffsetWithTitleMobile : FilterScrollOffsetWithTitle;

        var filterOffset = this.$filterTitle.length ? titleOffset : FilterScrollOffset;

        if (isSticky) {
            $('html, body').animate({
                scrollTop: this.$topPanel.offset().top - filterOffset
            }, 0);
        }

        this.filtersStore.filtersChecked = this.filtersStore.filtersChecked.filter(function (filter) {
            return filter.selected;
        });
        this.filtersStore.filtersChecked.forEach(function (filter) {
            filter.applied = true;
        });
        this.updateFilterTagsView();
        this.updateFilterView();
        this.toggleFilterList();
        this.collectParametersAndLoad();

        setTimeout(function () {
            document.querySelectorAll(classes.breadcrumbs).forEach(function (item) {
                $(item).addClass(constants.Classes.hidden);
            });
        }, 10);

        setTimeout(function () {
            if (_this20.$topPanel && _this20.$topPanel[0]) {
                _this20.$topPanel[0].scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        }, 150);
    };

    Component.prototype.updateFilterView = function () {
        var _this21 = this;

        var filterSelectedCount = this.filtersStore.filtersChecked.reduce(function (acc, filter) {
            return filter.selected ? acc + 1 : acc;
        }, 0);
        var isFiltersApplied = this.filtersStore.filtersChecked.some(function (filter) {
            return filter.applied;
        });
        var isFilterUpdated = this.filtersStore.filtersChecked.some(function (filter) {
            return filter.selected !== filter.applied;
        });

        if (filterSelectedCount) {
            this.$filterContainer.addClass(classes.filterSelected);
        } else {
            this.$filterContainer.removeClass(classes.filterSelected);
        }

        if (isFiltersApplied) {
            this.$filterTags.addClass(classes.filterTagsNotEmpty);
        } else {
            this.$filterTags.removeClass(classes.filterTagsNotEmpty);
        }

        if (isFilterUpdated) {
            this.$filterApplyBtn.removeClass(classes.filterApplyBtnDisabled);
            this.$filterApplyBtn.removeAttr('disabled');
        } else {
            this.$filterApplyBtn.addClass(classes.filterApplyBtnDisabled);
            this.$filterApplyBtn.attr('disabled', 'disabled');
        }

        $(classes.filterListItem).removeClass(classes.filterListItemActive);
        this.filtersStore.filtersChecked.forEach(function (filter) {
            var $filterItem = _this21.$el.find('[' + classes.filterDataIdAttr + '=\'' + filter.value + '\']');

            if (filter.selected) {
                $filterItem.addClass(classes.filterListItemActive);
            }
        });

        this.$filterSelectedCount.text(filterSelectedCount);
        this.setFilterLocalStorage();
    };

    Component.prototype.updateFilterTagsView = function () {
        var Tag = function Tag(_ref2) {
            var label = _ref2.label,
                value = _ref2.value;
            return '\n        <li class="detail-pages-filter-23__filter-tag-item">\n            <div class="detail-pages-filter-23__filter-tag">\n                <span class="detail-pages-filter-23__filter-tag-label">' + label + '</span>\n                <button type="button" class="detail-pages-filter-23__filter-tag-btn-remove" data-filter-tag-id="' + value + '"></button>\n            </div>\n        </li>\n        ';
        };

        this.removeFilterTags();
        this.$filterTagItemClear.after(this.getAppliedFilters(this.filtersStore.filtersChecked).map(Tag).join(''));
    };

    Component.prototype.setFilterLocalStorage = function () {
        window.localStorage.setItem(config.FILTER_STORE_NAME, JSON.stringify(this.filtersStore.filtersChecked));
    };

    Component.prototype.getFilterLocalStorage = function () {
        return JSON.parse(window.localStorage.getItem(config.FILTER_STORE_NAME)) || [];
    };

    Component.prototype.getAppliedFilters = function (filterList) {
        return filterList.filter(function (filter) {
            return filter.applied;
        });
    };

    Component.prototype.collectFilterParameters = function () {
        var filterType = this.viewType === viewType.filter || this.isDownloadable ? 'industries' : 'topics';

        return $.extend({}, this.defaultParameters, _defineProperty({}, filterType, this.getAppliedFilters(this.filtersStore.filtersChecked).map(function (filter) {
            return filter.value;
        })));
    };

    Component.prototype.loadMoreDetailPages = function (event) {
        this.$viewMore.addClass(constants.Classes.hidden);

        var offset = this.$detailPagesMainList.children().length,
            parameters = $.extend(this.collectFilterParameters(), { offset: offset });

        this.loadDetailPages(parameters);
        event.preventDefault();
    };

    Component.prototype.collectParametersAndLoad = function (buildSchemaOrgMarkup) {
        var parameters = this.collectFilterParameters();

        if (buildSchemaOrgMarkup && !this.isDownloadable) {
            parameters.buildSchemaOrgMarkup = buildSchemaOrgMarkup;
        }

        return this.loadDetailPages(parameters);
    };

    Component.prototype.loadDetailPages = function (parameters) {
        return $.ajax({
            url: this.defaultLoad ? config.DEFAULT_URL : config.URL,
            data: parameters,
            cache: false,
            beforeSend: this.toggleLoadingState.bind(this, true),
            success: this.loadDetailPagesAdapter.bind(this, parameters),
            complete: this.onRequestCompleteHandler.bind(this),
            error: this.showErrorMessage.bind(this)
        });
    };

    Component.prototype.onRequestCompleteHandler = function () {
        this.toggleLoadingState(false);
        this.hideEmptyImages();
    };

    Component.prototype.hideEmptyImages = function () {
        if (this.isDownloadable) {
            var allImages = this.$el.find(classes.image);
            var dividedArray = [];
            var chunkSize = 3;

            for (var i = 0; i < allImages.length; i += chunkSize) {
                var chunk = allImages.slice(i, i + chunkSize);
                dividedArray.push(chunk);
            }

            // hide empty image rows to maintain a clean and organized layout
            dividedArray.forEach(function (item) {
                var isEmpty = item.toArray().every(function (element) {
                    return !element.src.length;
                });
                var errorCount = 0;

                if (isEmpty) {
                    $(item).parent(classes.imageContainer).addClass(classes.errorImage);
                }

                $(item).each(function (index, image) {
                    $(image).on('error', function () {
                        errorCount++;

                        if (errorCount === chunkSize) {
                            $(item).parent(classes.imageContainer).addClass(classes.errorImage);
                        }
                    });
                });
            });

            // hide single image
            allImages.on('error', function () {
                $(this).parent(classes.imageContainer).addClass(classes.empty);
            });
        }
    };

    Component.prototype.loadDetailPagesAdapter = function (parameters, data) {
        if (this.viewType !== viewType.filter) {
            this.updateDetailPages(parameters, data);
            return;
        }

        var newData = data;

        this.defaultLoad = !data.result.length;

        if (this.secondLoad) {
            newData.defaultResult = data.result;
            data.result = [];
            this.secondLoad = false;
            this.defaultLoad = false;

            this.updateDetailPages(parameters, newData);
            return;
        }

        if (this.defaultLoad) {
            this.collectParametersAndLoad();

            this.secondLoad = true;
            this.defaultLoad = false;

            return;
        }

        this.updateDetailPages(parameters, newData);
    };

    Component.prototype.toggleLoadingState = function (showPreloader) {
        this.$preloader.toggleClass(constants.Classes.hidden, !showPreloader);
        this.$infoMessage.toggleClass(constants.Classes.hidden, showPreloader);
        showPreloader && this.$message.addClass(constants.Classes.hidden);
    };

    Component.prototype.updateDetailPages = function (parameters, data) {
        var result = data.result,
            schemaOrgMarkup = data.schemaOrgMarkup,
            defaultResult = data.defaultResult || [],
            total = data.total,
            limit = parameters.limit,
            offset = parameters.offset,
            isEmptyMainResult = !result.length,
            isEmptyDefaultResult = !defaultResult.length,
            isEmptyResults = isEmptyMainResult && isEmptyDefaultResult,
            hasMoreResults = total > offset + limit,
            buildSchemaOrgMarkup = parameters.buildSchemaOrgMarkup,
            messageType = this.$el.data('viewType') === viewType.careersBlog ? 'query' : 'combination';

        if (isEmptyMainResult || !offset) {
            this.$detailPagesMainList.empty();
            this.$detailPagesSecondaryList.empty();
        }
        !isEmptyDefaultResult && this.updateErrorMessage([messagesKeys.searchNoResults]);
        isEmptyResults && this.updateErrorMessage([messagesKeys['searchEmptyResult'] + messageType]);
        this.$message.toggleClass(constants.Classes.hidden, isEmptyDefaultResult && !isEmptyResults);
        this.$viewMore.toggleClass(constants.Classes.hidden, !hasMoreResults);
        if (this.$topPanel.length) {
            this.$detailPagesMainList.toggleClass(classes.detailPagesListNotEmpty, !isEmptyMainResult);
        }

        this.renderDetailPages(defaultResult, offset, this.$detailPagesSecondaryList);
        this.renderDetailPages(result, offset, this.$detailPagesMainList);

        buildSchemaOrgMarkup && !!schemaOrgMarkup && this.addSchemaOrgMarkup(schemaOrgMarkup);
    };

    Component.prototype.renderDetailPages = function (pages, offset, $container) {
        var context = {
            pages: pages,
            lastRowIdx: this.calculateLastRowIndex(pages.length),
            defaultImage: config.DEFAULT_IMAGE,
            isAuthor: this.isAuthor,
            contentReferenceLabelsView: this.contentReferenceLabelsView,
            viewType: this.viewType,
            isDownloadable: this.isDownloadable
        };

        offset && $container.children().removeClass(classes.lastRowItem);
        dust.append(config.TEMPLATE, context, $container);
        this.toggleLoadingState(false);
        this.focusOnFirstLoadedItem(offset);
    };

    Component.prototype.focusOnFirstLoadedItem = function (offset) {
        var detailPagesItems = this.$detailPagesMainList.children();

        if (detailPagesItems.length > config.LIMIT) {
            detailPagesItems.eq(offset).find(classes.detailPagesLink).focus();
        }
    };

    Component.prototype.calculateLastRowIndex = function (length) {
        var rows = Math.ceil(length / config.ROW_LENGTH);
        return (rows - 1) * config.ROW_LENGTH;
    };

    Component.prototype.addSchemaOrgMarkup = function (schemaOrgMarkup) {
        this.$el.prepend('<script type="application/ld+json">' + JSON.stringify(schemaOrgMarkup) + '</script>');
    };

    Component.prototype.showErrorMessage = function () {
        this.updateErrorMessage([messagesKeys.ajaxErrorMessage, messagesKeys.ajaxErrorTryAgain]);
        this.$message.removeClass(constants.Classes.hidden);
    };

    Component.prototype.updateErrorMessage = function (keys) {
        var resultMessage = keys.length > 1 ? keys.map(function (message) {
            return CQ.I18n.getMessage(message);
        }).join(' ') : CQ.I18n.getMessage(keys[0]);

        this.$messageText.html(resultMessage);
    };

    Component.moduleName = 'Detail Pages Filter 23';
    Component.selector = '.detail-pages-filter-23-ui';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('InstagramFeed23', ['SwipeCarousel'], function (SwipeCarousel) {
    'use strict';

    var classes = {
        blocksContainer: '.instagram-feed__container',
        scrollContainer: '.instagram-feed__scroll-container',
        progressBar: '.instagram-feed__progress-bar',
        slider: '.slider'
    };

    function Component($el) {
        this.element = $el[0];
        this.scrollContainer = this.element.querySelector(classes.scrollContainer);
        this.owl = this.element.querySelector(classes.blocksContainer);
        this.slider = this.element.querySelector(classes.slider);
        this.progressBar = this.element.querySelector(classes.progressBar);
        this.initCarousel();
    }

    Component.prototype = new SwipeCarousel();

    Component.moduleName = 'Instagram Feed 23';
    Component.selector = '.instagram-feed-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

define('LeadershipViewer23', ['SwipeCarousel', 'gradients', 'utils', 'constants'], function (SwipeCarousel, gradients, utils, constants) {
    'use strict';

    var classes = {
        TEXT_GRADIENT: '.text-gradient',
        SLIDER_ITEMS: '.leadership-viewer-ui-23-scroll__info-wrapper',
        ITEMS: '.leadership-viewer-ui-23__info-wrapper',
        NON_SLIDER_ITEM: '.leadership-viewer-ui-23__info',
        ITEM_NAME_WRAPPER: '.name-wrapper',
        ITEM_NAME: '.name',
        ITEM_NAME_UNDERLINE: '.name-underline',
        TRANSFERRED: 'transferred',
        TRANSPARENT: 'transparent',
        SCROLL: '.leadership-viewer-ui-23-scroll',
        BLOCKS_CONTAINER: '.leadership-viewer-ui-23-scroll__container',
        PROGRESS_BAR: '.leadership-viewer-ui-23-scroll__progress-bar',
        SLIDER: '.slider',
        TABS: '.tabs-ui-23'
    };

    var N & DS_RIGHT_RATIO = 0.1;
    var N & DS_MIDDLE_RATIO = 1.2;

    function Component($el) {
        this.element = $el[0];

        var sliderItems = this.element.querySelectorAll(classes.SLIDER_ITEMS);
        var items = this.element.querySelectorAll(classes.ITEMS);

        this.scrollContainer = this.element.querySelector(classes.SCROLL);
        this.owl = this.element.querySelector(classes.BLOCKS_CONTAINER);
        this.slider = this.element.querySelector(classes.SLIDER);
        this.progressBar = this.element.querySelector(classes.PROGRESS_BAR);
        this.onLoad = this.onLoad.bind(this);
        this.onResize = this.onResize.bind(this);
        this.detectOutOfBoundsText = this.detectOutOfBoundsText.bind(this);

        this.isSlider = !!sliderItems.length;
        this.itemsToProcess = this.isSlider ? sliderItems : items;
        this.gradientText = new gradients.GradientText();
        this.gradientTextUnderline = new gradients.GradientText();

        this.initEvents();
        if (sliderItems.length) {
            this.initCarousel({
                0: {
                    margin: 24
                },
                991: {
                    margin: 49
                } });
        }
    }

    Component.prototype = new SwipeCarousel();

    Component.prototype.initEvents = function () {
        window.addEventListener('load', this.onLoad);
    };

    Component.prototype.onLoad = function () {
        this.detectOutOfBoundsText();

        var nameWrapperNodes = [];
        this.itemsToProcess.forEach(function (node) {
            return nameWrapperNodes.push(node.querySelector(classes.ITEM_NAME_WRAPPER));
        });

        var nameNodes = nameWrapperNodes.map(function (node) {
            return node.querySelector(classes.ITEM_NAME);
        });

        this.gradientText.init(nameNodes, { rightRatio: N & DS_RIGHT_RATIO, middleRatio: N & DS_MIDDLE_RATIO });

        this.handleUnderlines();

        // sometimes in edit mode resize occurs before onLoad, without proper initialization
        var bindedResize = this.onResize.bind(this);
        var windowWidth = window.innerWidth;
        window.addEventListener('resize', function () {
            if (window.innerWidth !== windowWidth) {
                windowWidth = window.innerWidth;
                utils.debounce(bindedResize, 500);
            }
        });

        if (this.element.closest(classes.TABS)) {
            //native JS can't handle JQuery events
            $(window).on(constants.Events.tabChanged, this.onResize);
        }
    };

    Component.prototype.onResize = function () {
        this.detectOutOfBoundsText();
        this.handleUnderlines();
    };

    Component.prototype.handleUnderlines = function () {
        var nameWrapperNodes = [];
        this.itemsToProcess.forEach(function (node) {
            return nameWrapperNodes.push(node.querySelector(classes.ITEM_NAME_WRAPPER));
        });
        var underlineNodes = [];
        nameWrapperNodes.forEach(function (node) {
            if (node.classList.contains(classes.TRANSFERRED)) {
                var _underlineNodes;

                var underlineChildren = node.querySelector(classes.ITEM_NAME_UNDERLINE).children;
                (_underlineNodes = underlineNodes).push.apply(_underlineNodes, _toConsumableArray(underlineChildren));
            } else {
                underlineNodes.push(node.querySelector(classes.ITEM_NAME_UNDERLINE));
            }
        });

        underlineNodes = underlineNodes.filter(function (node) {
            return node.nodeName !== 'BR';
        });

        this.gradientTextUnderline.stop();
        this.gradientTextUnderline.init(underlineNodes, { rightRatio: N & DS_RIGHT_RATIO, middleRatio: N & DS_MIDDLE_RATIO });
    };

    Component.prototype.detectOutOfBoundsText = function () {
        for (var i = 0; i < this.itemsToProcess.length; i++) {
            var slideItemPersonName = this.itemsToProcess[i].querySelector(classes.ITEM_NAME);
            slideItemPersonName.style.display = 'inline';

            if (slideItemPersonName.getClientRects().length > 1) {
                this.itemsToProcess[i].querySelector(classes.ITEM_NAME_WRAPPER).classList.add(classes.TRANSFERRED);
            } else {
                this.itemsToProcess[i].querySelector(classes.ITEM_NAME_WRAPPER).classList.remove(classes.TRANSFERRED);
            }
        }
    };

    Component.selector = '.leadership-viewer-ui-23';
    Component.moduleName = 'LeadershipViewer23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('LocationsViewer23', ['media', 'utils', 'SocialIcons', 'jquery-plugins'], function (media, utils, SocialIcons) {
    'use strict';

    var $window = $(window),
        spaceBeforeTop = 76,
        spaceWithBlockSize = 194,
        delay = 100;

    var classes = {
        carousel: '.locations-viewer-23__carousel',
        country: 'locations-viewer-23__country',
        countryButton: '.locations-viewer-23__country-btn',
        countryList: '.locations-viewer-23__country-list',
        active: 'active',
        owlLoaded: 'owl-loaded',
        carouselButtons: '.owl-nav button',
        nextLocationBtn: '.locations-viewer-23__next-country-btn',
        activeCountry: '.locations-viewer-23__country .active',
        activeCountryTile: '.owl-item.active .locations-viewer-23__country',
        countryCounter: '.locations-viewer-23__country-counter',
        horizontalScrollbar: '.carousel-horizontal-scrollbar',
        horizontalScrollbarWrapper: '.horizontal-scrollbar-wrapper',
        slider: '.slider',
        progressBar: 'slider__progress-bar',
        navigationContainer: 'slider__navigation',
        pagination: 'slider__pagination',
        sumPage: 'slider__pagination--sum-page',
        currentPage: 'slider__pagination--current-page',
        leftArrow: 'slider__left-arrow',
        rightArrow: 'slider__right-arrow',
        dot: 'slider__dot'
    };

    function Component($el) {
        this.$el = $el;
        this.$carousel = this.$el.find(classes.carousel);
        this.$countryCounter = this.$el.find(classes.countryCounter);
        this.$countryList = this.$el.find(classes.countryList);
        this.countryCount = this.$countryList.children().length;
        this.$countryButton = this.$el.find(classes.countryButton);
        this.$horizontalScrollbar = this.$el.find(classes.horizontalScrollbar);
        this.$horizontalScrollbarWrapper = this.$el.find(classes.horizontalScrollbarWrapper);
        this.$nextLocationBtn = this.$el.find(classes.nextLocationBtn);
        this.windowWidth = $window.width();
        this.$slider = this.$el.find(classes.slider);
        this.currentCount = 1;
        this.isTablet = media.currentMode().greaterThan(media.modes.WideMobile);

        var responsive = {};

        responsive[media.modes.WideMobile.start] = { items: this.countryCount > 2 ? 2 : this.countryCount };
        responsive[media.modes.Desktop.start] = { items: this.countryCount > 3 ? 3 : this.countryCount };
        responsive[media.modes.Broad.start] = { items: this.countryCount > 4 ? 4 : this.countryCount };

        var isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
        var isResponsiveView = window.innerWidth < 992;

        var config = $.extend({}, this.config, {
            dots: false,
            lazyLoad: false,
            loop: !isTouchDevice && !isResponsiveView,
            mouseDrag: !isTouchDevice,
            touchDrag: !isTouchDevice,
            nav: false,
            onInitialized: this.carouselInitialized.bind(this),
            navElement: 'button type="button"',
            navText: ['Previous card', 'Next card']
        });

        this.$el.attr('data-item-count', this.countryCount);
        this.$parentTabItem = this.$carousel.parents('.js-tabs-item');

        if (!this.$parentTabItem.length) {
            this.$carousel.owlCarousel(config);
        }

        $window.on('tab.loaded tab.changed tab.change', function () {
            this.$parentTabItem.removeAttr('tabindex');

            if (this.$carousel.parents('.js-tabs-item.active').length && !this.$carousel.hasClass(classes.owlLoaded)) {
                this.$carousel.owlCarousel(config);
                this.$carouselButtons = this.$carousel.find(classes.carouselButtons);
                this.addEventListenersToCarouselButtons();
                this.addEventListenersToNextLocation();
            }
        }.bind(this));

        this.$actualElements = this.$carousel.find('.owl-item:not(.cloned)');
        this.$countries = this.$carousel.find('.owl-item:not(.cloned) .' + classes.country);
        this.$carousel.on('click', '.' + classes.country, this.carouselClickHandler.bind(this)).on('refreshed.owl.carousel', this.updateSelectors.bind(this)).on('translated.owl.carousel', this.onTranslated.bind(this));
        $window.on('resize orientationchange', function () {
            if ($window.width() !== this.windowWidth) {
                utils.debounce(this.recalculateHeight(), delay);
                this.reInitCarousel(config).done(this.focusOnActive.bind(this));
            }
        }.bind(this));

        this.socialIcons = new SocialIcons(this.$el);

        utils.addExtensionToPhoneNumber(this.$el);

        this.isUrlContainsHash(config);
        this.addEventListenersToCountryButtons(this.countryCount);

        var transientObject = {};
        var defaultSliderOptions = {
            onChanged: this.setCurrentSlideCount.bind(this),
            onDrag: this.onDrag.bind(transientObject),
            onDragged: this.onDragged.bind(transientObject),
            onInitialized: this.onInitialized.bind(this),
            loop: true,
            margin: 10,
            touchDrag: true,
            autoplay: false,
            navClass: [classes.leftArrow, classes.rightArrow],
            dotClass: classes.dot,
            dotsClass: classes.progressBar,
            navContainerClass: classes.navigationContainer,
            responsiveRefreshRate: 0,
            nav: true,
            navText: [' ', ' '],
            responsive: {
                0: {
                    items: 1
                },
                768: {
                    items: 2,
                    slideBy: 2
                }
            }
        };

        this.$slider.each(function (index, item) {
            var $slider = $(item);
            var itemCount = $slider.data('cities-count');

            if (itemCount > 1) {
                $slider.owlCarousel(defaultSliderOptions);
            }
        });

        var leftArrow = this.$el.find('.' + classes.leftArrow);
        leftArrow.after('<div class="' + classes.pagination + '"><span class="' + classes.currentPage + '"></span><span class="' + classes.sumPage + '"></span></div>');
    }

    Component.prototype.setHorizontalScrollbar = function () {
        var totalCountriesCount = this.countryCount;

        if (totalCountriesCount <= 4) {
            return;
        }

        var horizontalScrollbarWrapperWidth = this.$horizontalScrollbarWrapper.width();

        this.$horizontalScrollbarWrapper.css({ visibility: 'visible' });

        var horizontalScrollbar = this.$horizontalScrollbar;
        var horizontalScrollbarItems = horizontalScrollbar.find('.horizontal-scrollbar-item');

        var owlStage = this.$carousel.find('.owl-stage');

        owlStage.on('mousedown', function () {
            isCarouselMovedByUser = true;
        });

        var owlStageWidth = +owlStage[0].style.width.slice(0, -2);
        var initialOwlCarouselPosition = 1108 * (Math.ceil(owlStageWidth / 1108) / 4);

        var k = 277 * totalCountriesCount / horizontalScrollbarWrapperWidth;

        horizontalScrollbarItems.css({ width: horizontalScrollbarWrapperWidth / totalCountriesCount * 4 });

        var horizontalScrollbarItemWidth = horizontalScrollbarWrapperWidth * 2 + horizontalScrollbarWrapperWidth / totalCountriesCount * 4;
        horizontalScrollbar.css({
            width: horizontalScrollbarItemWidth,
            transform: 'translateX(-' + horizontalScrollbarWrapperWidth + 'px)'
        });

        var isCarouselMovedByUser = false;
        var isMouseDown = false;
        var offset = 0;
        var scrollbarPosition = 0;
        var diff = 0;

        function moveHorizontalScrollbarWhenCarouselChanged(animationTime) {
            var translateX = owlStage[0].style.transform.slice(13, -13);
            scrollbarPosition = parseInt((translateX - initialOwlCarouselPosition) / k);
            horizontalScrollbar.css({
                left: scrollbarPosition + 'px',
                transition: 'left ' + animationTime + 's ease 0s'
            });
        }

        this.$carousel.on('changed.owl.carousel', function () {
            setTimeout(function () {
                moveHorizontalScrollbarWhenCarouselChanged(0);
            }, 0);
        });

        horizontalScrollbar.on('mousedown', function (e) {
            if (e.target.getAttribute('data-horizontal-scrollbar') === 'item') {
                isMouseDown = true;
                offset = e.clientX;
            }
        });

        document.addEventListener('mouseup', function () {
            if (isMouseDown) {
                scrollbarPosition = (scrollbarPosition + diff + horizontalScrollbarWrapperWidth) % horizontalScrollbarWrapperWidth;
            }

            isMouseDown = false;

            if (isCarouselMovedByUser) {
                setTimeout(function () {
                    moveHorizontalScrollbarWhenCarouselChanged(1.5);
                }, 0);
            }

            isCarouselMovedByUser = false;
        });

        document.addEventListener('mousemove', function (e) {
            if (isMouseDown) {
                diff = e.clientX - offset;

                horizontalScrollbar.css({
                    left: (scrollbarPosition + diff) % horizontalScrollbarWrapperWidth + 'px',
                    transition: 'left 0s ease 0s'
                });

                owlStage.css({
                    transform: 'translate3d(-' + (initialOwlCarouselPosition + (scrollbarPosition + diff + horizontalScrollbarWrapperWidth) % horizontalScrollbarWrapperWidth * k) + 'px, 0px, 0px)',
                    transition: 'all 0s ease 0s'
                });
            }

            if (isCarouselMovedByUser) {
                moveHorizontalScrollbarWhenCarouselChanged(0);
            }
        });
    };

    Component.prototype.setMobileCarouselView = function () {
        var isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;

        if (isTouchDevice) {
            var owlStage = this.$carousel.find('.owl-stage');

            owlStage.css({
                position: 'relative',
                left: '-32px',
                width: '100vw',
                'padding-left': '32px',
                'padding-right': 'calc(100vw - 229px + 8px + 32px)',
                transform: 'none',
                transition: 'none',
                'overflow-x': 'auto'
            });
        }
    };

    Component.prototype.onInitialized = function (event) {
        if (this.isTablet && event.item.count !== 1 && event.item.count % 2 !== 0) {
            event.item.count += 1;
            event.relatedTarget._items.push($('<div class="owl-item"></div>'));
            event.relatedTarget._mergers.push(1);
        }
    };

    Component.prototype.openSlider = function () {
        var additionalOptions = {
            responsive: {
                0: {
                    items: 1
                },
                768: {
                    items: 2,
                    slideBy: 2
                }
            }
        };

        var updatedOptions = $.extend({}, this.defaultSliderOptions, additionalOptions);
        this.$slider.trigger('refresh.owl.carousel', updatedOptions);
    };

    Component.prototype.onDrag = function (event) {
        this.initialCurrent = event.relatedTarget.current();
    };

    Component.prototype.onDragged = function (event) {
        var owl = event.relatedTarget;
        owl.current(this.initialCurrent);

        if (owl._drag.direction === 'left') {
            owl.next();
        }

        if (owl._drag.direction === 'right') {
            owl.prev();
        }
    };

    Component.prototype.setSlidesTotal = function () {
        var totalOffices = this.$el.find('.' + classes.country + '.' + classes.active).data().cities;
        var totalSlides = this.isTablet ? Math.ceil(totalOffices / 2).toString().padStart(2, '0') : totalOffices.toString().padStart(2, '0');
        this.$el.find('.' + classes.sumPage).text(' / ' + totalSlides);
    };

    Component.prototype.addItem = function () {
        var offices = this.$el.find('[data-country="' + this.currentActiveCountry + '"]').find('.owl-item:not(.cloned)');

        if (this.isTablet && offices.length % 2 !== 0) {
            offices.last().after('<div class="owl-item-placeholder" aria-hidden="true"></div>');
        }
    };

    Component.prototype.setCurrentSlideCount = function (event) {
        if (event.page.index === -1) {
            this.currentCount = 1;
        } else {
            this.currentCount = event.page.index + 1;
        }
        this.$el.find('.' + classes.currentPage).text(this.currentCount.toString().padStart(2, '0'));
    };

    Component.prototype.isUrlContainsHash = function (config) {
        var url = window.location.href;
        var re = new RegExp('(\/?#.{1,})', 'i');
        var result = re.test(url);
        if (result) {
            this.reInitCarousel(config).done(this.focusOnActive.bind(this));
        }
    };

    Component.prototype.carouselInitialized = function () {
        this.$carouselButtons = this.$carousel.find(classes.carouselButtons);
        this.setHorizontalScrollbar();
        this.setMobileCarouselView();
    };

    Component.prototype.reInitCarousel = function (config) {
        var defer = $.Deferred();

        setTimeout(function () {
            this.$carousel.trigger('to.owl.carousel');
            this.$carousel.owlCarousel(config);
            defer.resolve();
        }.bind(this), delay);

        return defer.promise();
    };

    Component.prototype.recalculateHeight = function () {
        if (!this.$countryList.hasClass(classes.active)) {
            return;
        }

        setTimeout(function () {
            this.$countryList.height(this.$opened.outerHeight());
        }.bind(this), 0);
    };

    Component.prototype.scrollToList = function ($country) {
        var isLandscape = window.innerWidth > window.innerHeight && media.currentMode().lessThan(media.modes.Tablet);
        if (isLandscape && $country.hasClass(classes.active)) {
            return;
        }
        var reservedSpace = isLandscape ? -spaceWithBlockSize : spaceBeforeTop;
        this.$carousel.scrollToSelector({ reservedSpace: reservedSpace, duration: 400 });
    };

    Component.prototype.updateSelectors = function () {
        this.$countries = this.$carousel.find('.owl-item:not(.cloned) .' + classes.country);
        this.setMobileCarouselView();
        this.updateActiveCountryScrollPosition();
    };

    Component.prototype.clearState = function () {
        this.$countries.removeClass(classes.active);
        this.$countryList.children().removeClass(classes.active).attr('aria-hidden', true);

        if (this.$carouselButtons) {
            this.$carouselButtons.removeAttr('tabindex');
        }
    };

    Component.prototype.updateHeight = function () {
        var height = this.$opened.outerHeight();

        this.$countryList.toggleClass(classes.active, !!height);

        setTimeout(function () {
            this.$countryList.height(this.$opened.outerHeight());
        }.bind(this), 0);
    };

    Component.prototype.onTranslated = function () {
        if (!this.currentActiveCountry) {
            return;
        }
        this.$countries.filter('[data-country="' + this.currentActiveCountry + '"]').removeClass('active');
        this.$el.find('.owl-item.active').find('[data-country="' + this.currentActiveCountry + '"]').addClass('active');
    };

    Component.prototype.carouselClickHandler = function (event) {
        this.toggleExpand(event);
        this.updateCountryCounterLabel();
        this.addItem();
        this.openSlider();
        this.setSlidesTotal();
    };

    Component.prototype.toggleActiveCountry = function ($target, countryName, isOpened) {
        this.$el.find('.locations-viewer-23__country .locations-viewer-23__country-title').removeClass('active');

        if (!isOpened) {
            this.$el.find('.locations-viewer-23__country[data-country="' + countryName + '"] .locations-viewer-23__country-title').addClass('active');
        }

        var owlStage = this.$carousel.find('.owl-stage');

        var isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;

        if (isTouchDevice) {
            var owlStageScrollLeft = $(owlStage).scrollLeft();
            var countryOffsetLeft = $($target).offset().left;

            $(owlStage).animate({
                scrollLeft: owlStageScrollLeft + countryOffsetLeft - 32
            }, 400);
        }
    };

    Component.prototype.updateActiveCountryScrollPosition = function () {
        var owlStage = this.$carousel.find('.owl-stage');
        var activeCountry = this.$el.find(classes.activeCountry);

        var isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;

        if (isTouchDevice && activeCountry.length) {
            var activeCountryOffsetLeft = $(activeCountry).offset().left;

            $(owlStage).scrollLeft(activeCountryOffsetLeft - 32);
        }
    };

    Component.prototype.toggleExpand = function (event) {
        var $target = $(event.currentTarget),
            countryName = $target.data('country');

        this.$opened = this.$countryList.find('[data-country="' + countryName + '"]');
        var isOpened = this.$opened.hasClass(classes.active);
        this.currentActiveCountry = isOpened ? null : countryName;
        this.toggleActiveCountry($target, countryName, isOpened);
        this.toggleBlock(isOpened, countryName, $target);
        this.updateHeight();
        this.scrollToList($target);
    };

    Component.prototype.updateCountryCounterLabel = function () {
        var activeCountryNode = this.$el.find('.locations-viewer-23__country[data-country="' + this.currentActiveCountry + '"]');
        if (activeCountryNode.length > 0) {
            var cities = activeCountryNode[0].dataset.cities;
            var label = cities >= 2 ? CQ.I18n.getMessage('component.locations-viewer23.locations', cities) : CQ.I18n.getMessage('component.locations-viewer23.one-location');
            this.$countryCounter.html(label);
            this.$countryCounter.removeClass('hidden');
        } else {
            this.$countryCounter.addClass('hidden');
        }
    };

    Component.prototype.toggleBlock = function (isOpened, countryName, target) {
        this.clearState();
        var $active = this.$countries.filter('[data-country="' + countryName + '"]'),
            $activeButtons = this.$carousel.find('.owl-item.active').find(classes.countryButton),
            $selectedButton = target.find('button'),
            $countryButton = this.$carousel.find(classes.countryButton),
            indexOfActiveItem = this.$countries.index($active);

        $active.toggleClass(classes.active, !isOpened);
        this.$opened.toggleClass(classes.active, !isOpened);
        this.$carousel.toggleClass(classes.active, !isOpened);

        var isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;

        if (!isTouchDevice) {
            this.$carousel.trigger('to.owl.carousel', [indexOfActiveItem, 300]);
        }

        if (!isOpened) {
            this.$opened.removeAttr('aria-hidden');
            if (this.$carouselButtons) {
                this.$carouselButtons.attr('tabindex', '-1');
            }
            $countryButton.attr('tabindex', '-1');
            $countryButton.attr('aria-expanded', true);
            $selectedButton.attr('tabindex', '0');
        } else {
            this.$opened.attr('aria-hidden', true);
            $countryButton.attr('aria-expanded', false);
            $activeButtons.attr('tabindex', '0');
        }
    };

    Component.prototype.focusOnActive = function () {
        if (!this.currentActiveCountry) {
            return;
        }

        this.$actualElements = this.$carousel.find('.owl-item:not(.cloned)');
        var $active = this.$actualElements.has('.' + classes.country + '[data-country="' + this.currentActiveCountry + '"]');

        this.$carousel.trigger('to.owl.carousel', this.$actualElements.index($active));
    };

    Component.prototype.config = {
        loop: true,
        callbacks: true,
        items: 4,
        autoWidth: true,
        responsive: {},
        lazyLoad: false,
        nav: true
    };

    Component.prototype.addEventListenersToCountryButtons = function (countryCount) {
        this.$countryButton.each(function (index) {
            var $currentButton = $(this);
            var countryTitle = $currentButton.attr('data-country-title');
            var citiesCount = $currentButton.attr('data-cities-count');
            var locationsText = citiesCount > 1 ? ' locations' : ' location';
            var ariaLabel = 'Card ' + (index + 1) + ' of ' + countryCount + ' ' + countryTitle;
            $currentButton.attr('aria-label', ariaLabel);

            function isButtonExpanded() {
                return $currentButton.attr('aria-expanded') !== 'false';
            }

            $currentButton.on('unfocus', function () {
                !isButtonExpanded() && $currentButton.attr('aria-label', ariaLabel);
            });

            $currentButton.on('click', function () {
                isButtonExpanded() ? $currentButton.attr('aria-label', ariaLabel) : $currentButton.attr('aria-label', countryTitle + ' button ' + citiesCount + locationsText);
            });
        });
    };

    Component.prototype.addEventListenersToCarouselButtons = function () {
        var self = this;

        this.$carouselButtons.on('focus', function () {
            var currentSection = this.closest('.section__wrapper');
            var currentSectionTop = currentSection.getBoundingClientRect().top;
            if (currentSectionTop < 0) {
                var currentSectionOffsetTop = $(currentSection).offset().top;
                $('html, body').animate({ scrollTop: currentSectionOffsetTop }, 0);
            }
        });

        this.$carouselButtons.on('click', function () {
            self.refreshActiveCardsCounts();
            var ariaLabelText = self.createCarouselButtonAriaLabelText();
            $(this).attr('aria-label', ariaLabelText);
        });

        this.$carouselButtons.on('blur', function () {
            $(this).removeAttr('aria-label');
        });
    };

    Component.prototype.addEventListenersToNextLocation = function () {
        var self = this;

        this.$nextLocationBtn.on('click', function () {
            var $active = self.$countries.filter('.active'),
                indexOfActiveItem = self.$countries.index($active);

            if (indexOfActiveItem !== self.countryCount - 1) {
                $active.parent().next().find(classes.countryButton).click();
            } else {
                self.$countries.first().find(classes.countryButton).click();
            }
        });
    };

    Component.prototype.refreshActiveCardsCounts = function () {
        var $activeCards = this.$carousel.find(classes.activeCountryTile);

        this.activeCardsCounts = $activeCards.map(function () {
            return $(this).attr('data-count');
        });
    };

    Component.prototype.createCarouselButtonAriaLabelText = function () {
        var boundIndex = this.activeCardsCounts.length;

        for (var i = 0; i < this.activeCardsCounts.length - 1; i++) {
            if (this.activeCardsCounts[i] > this.activeCardsCounts[i + 1]) {
                boundIndex = i + 1;
            }
        }

        var parts = [];
        var head = this.activeCardsCounts.slice(0, boundIndex);
        var tail = this.activeCardsCounts.slice(boundIndex);
        var headText = this.createRange(head);
        var tailText = this.createRange(tail);
        headText && parts.push(headText);
        tailText && parts.push(tailText);

        return 'Cards ' + parts.join(', ') + ' out of ' + this.countryCount + ' are shown';
    };

    Component.prototype.createRange = function (arr) {
        if (arr.length === 0) {
            return '';
        }

        if (arr.length === 1) {
            return arr[0];
        }

        return arr[0] + ' - ' + arr[arr.length - 1];
    };

    Component.moduleName = 'Locations Viewer 23';
    Component.selector = '.locations-viewer-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('NestedTextBlock23', ['utils-env', 'utils-browser'], function (env) {
    'use strict';

    var CLASSES = {
        animated: 'animated',
        item: '.nested-text-block__item'
    };

    var Component = function () {
        function Component($el) {
            _classCallCheck(this, Component);

            this.$el = $el[0];
            this.$items = this.$el.querySelectorAll(CLASSES.item);
            this.tabletMediaQuery = '(min-width: 768px)';

            this.init();
        }

        _createClass(Component, [{
            key: 'init',
            value: function init() {
                var self = this;
                var isTablet = window.matchMedia(this.tabletMediaQuery).matches;
                var oneRowThreshold = 1;
                var tabletThreshold = 0.5;
                var mobileThreshold = 0.25;

                var thresholdOption = oneRowThreshold;
                if (self.$items.length > 3) {
                    thresholdOption = isTablet ? tabletThreshold : mobileThreshold;
                }

                window.addEventListener('load', function () {
                    var intersectionObserver = new IntersectionObserver(function (entries, observer) {
                        entries.forEach(function (entry) {
                            if (entry.isIntersecting) {
                                self.animateBlocksInSeries();
                                observer.unobserve(self.$el);
                            }
                        });
                    }, {
                        threshold: thresholdOption
                    });
                    intersectionObserver.observe(self.$el);
                });

                self.disableAnimationInEditMode();
            }
        }, {
            key: 'disableAnimationInEditMode',
            value: function disableAnimationInEditMode() {
                if (env.isEditMode()) {
                    var itemsArray = [];

                    for (var i = 0; i < this.$items.length; i++) {
                        itemsArray.push(this.$items[i]);
                    }

                    itemsArray.forEach(function (item) {
                        item.classList.add(CLASSES.animated);
                    });
                }
            }
        }, {
            key: 'animateBlocksInSeries',
            value: function animateBlocksInSeries() {
                var itemsArray = [];

                for (var i = 0; i < this.$items.length; i++) {
                    itemsArray.push(this.$items[i]);
                }

                itemsArray.forEach(function (item, index) {
                    setTimeout(function () {
                        item.classList.add(CLASSES.animated);
                    }, 150 * index);
                });
            }
        }]);

        return Component;
    }();

    Component.moduleName = 'NestedTextBlock23';
    Component.selector = '.nested-text-block-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('RolloverBlocks23', ['media', 'animations'], function (media, animations) {
    'use strict';

    var CLASSES = {
        BLOCK: 'rollover-blocks__block',
        FOCUSED_BLOCK: 'rollover-blocks__block--focused',
        BLOCK_CONTENT: 'rollover-blocks__content',
        ROLLOVER_BLOCK: 'rollover-blocks__description-rollover',
        LINK_A11Y: 'rollover-blocks__link-holder--a11y',
        LINK_LEARN_MORE: 'rollover-blocks__link',
        LINK_LEARN_MORE_ICON: 'link-arrow',
        RTE_LINKS: 'rollover-blocks__text a'
    };

    var Component = function () {
        function Component($el) {
            _classCallCheck(this, Component);

            this.el = $el[0];
            this.isResponsive = media.currentMode().lessThan(media.modes.Desktop);
            this.blocks = this.el.querySelectorAll('.' + CLASSES.BLOCK);
            this.activeBlock = localStorage.getItem('activeBlock');
            var left = +localStorage.getItem('left');
            this.addEventListenersToBlocks();
            if (this.activeBlock !== null && this.isResponsive) {
                this.blocks[this.activeBlock].classList.add('flipped');
                this.blocks[this.activeBlock].classList.add('active');
                $el.scrollLeft($(this.blocks[this.activeBlock]).position().left - left);
            }

            this.addBlocksAnimation();
        }

        _createClass(Component, [{
            key: 'addEventListenersToBlocks',
            value: function addEventListenersToBlocks() {
                var _this22 = this;

                this.blocks.forEach(function (block, index) {
                    var blockContent = block.querySelector('.' + CLASSES.BLOCK_CONTENT);
                    var rolloverBlock = block.querySelector('.' + CLASSES.ROLLOVER_BLOCK);
                    var learnMoreLink = block.querySelector('.' + CLASSES.LINK_LEARN_MORE);
                    var RTELinks = block.querySelectorAll('.' + CLASSES.RTE_LINKS);
                    var links = [learnMoreLink].concat(_toConsumableArray(RTELinks));
                    if (index === 0) {
                        _this22.showForAccessibility(blockContent);
                    }
                    _this22.hideForAccessibility.apply(_this22, _toConsumableArray(RTELinks));
                    _this22.addEventListenerToRolloverBlock(block, rolloverBlock, links);

                    if (_this22.isResponsive) {
                        block.addEventListener('click', function (event) {
                            if (!event.target.className.includes(CLASSES.LINK_LEARN_MORE) && event.target.className !== CLASSES.LINK_LEARN_MORE_ICON) {
                                if (block.classList.contains('active')) {
                                    block.classList.remove('active');
                                    localStorage.removeItem('activeBlock');
                                } else {
                                    block.classList.add('active');
                                }

                                _this22.blocks.forEach(function (el) {
                                    if (el !== block && el.classList.contains('active')) {
                                        el.classList.remove('active');
                                        localStorage.removeItem('activeBlock');
                                    }
                                });
                            } else {
                                localStorage.setItem('activeBlock', index);
                                var blockCoordinates = block.getBoundingClientRect();
                                localStorage.setItem('left', blockCoordinates.left);
                            }
                        });
                    } else {
                        block.addEventListener('mouseover', function () {
                            block.classList.add('active');
                        });

                        block.addEventListener('mouseout', function () {
                            block.classList.remove('active');
                        });
                    }
                });
            }
        }, {
            key: 'addEventListenerToRolloverBlock',
            value: function addEventListenerToRolloverBlock(block, rolloverBlock, links) {
                var _this23 = this;

                rolloverBlock.addEventListener('focus', function () {
                    setTimeout(function () {
                        block.classList.add(CLASSES.FOCUSED_BLOCK);
                        _this23.showForAccessibility.apply(_this23, [rolloverBlock].concat(_toConsumableArray(links)));
                    }, 5);
                });

                rolloverBlock.addEventListener('blur', function () {
                    block.classList.remove(CLASSES.FOCUSED_BLOCK);
                    _this23.hideForAccessibility.apply(_this23, [rolloverBlock].concat(_toConsumableArray(links)));
                });

                links.forEach(function (link) {
                    if (link) {
                        link.addEventListener('focus', function () {
                            block.classList.add(CLASSES.FOCUSED_BLOCK);
                            _this23.showForAccessibility.apply(_this23, [rolloverBlock].concat(_toConsumableArray(links)));
                        });

                        link.addEventListener('blur', function () {
                            block.classList.remove(CLASSES.FOCUSED_BLOCK);
                            _this23.hideForAccessibility.apply(_this23, [rolloverBlock].concat(_toConsumableArray(links)));
                        });
                    }
                });
            }
        }, {
            key: 'showForAccessibility',
            value: function showForAccessibility() {
                for (var _len = arguments.length, arr = Array(_len), _key = 0; _key < _len; _key++) {
                    arr[_key] = arguments[_key];
                }

                arr.forEach(function (el) {
                    if (el) {
                        el.setAttribute('tabindex', 0);
                        el.removeAttribute('aria-hidden');
                    }
                });
            }
        }, {
            key: 'hideForAccessibility',
            value: function hideForAccessibility() {
                for (var _len2 = arguments.length, arr = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    arr[_key2] = arguments[_key2];
                }

                arr.forEach(function (el) {
                    if (el) {
                        el.setAttribute('tabindex', -1);
                        el.setAttribute('aria-hidden', true);
                    }
                });
            }
        }, {
            key: 'addBlocksAnimation',
            value: function addBlocksAnimation() {
                var blocks = document.querySelectorAll('.' + CLASSES.BLOCK);

                window.addEventListener('pageshow', function () {
                    if (blocks.length) {
                        animations.addAppearanceAnimation(blocks, 'animated');
                        animations.disableAnimationInEditMode(blocks, 'animated');
                    }
                });
            }
        }]);

        return Component;
    }();

    Component.selector = '.rollover-blocks-ui-23';
    Component.moduleName = 'Rollover Blocks 23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ScrollingBlocks23', ['SwipeCarousel'], function (SwipeCarousel) {
    'use strict';

    var classes = {
        blocksContainer: '.scrolling-blocks__container',
        scrollContainer: '.scrolling-blocks__scroll-container',
        progressBar: '.scrolling-blocks__progress-bar',
        tabs: 'tabs-23__item',
        active: 'active',
        slider: '.slider'
    };

    function Component($el) {
        this.element = $el[0];
        this.scrollContainer = this.element.querySelector(classes.scrollContainer);
        this.owl = this.element.querySelector(classes.blocksContainer);
        this.slider = this.element.querySelector(classes.slider);
        this.progressBar = this.element.querySelector(classes.progressBar);
        this.inited = false;
        this.handleTabs();
    }

    Component.prototype = new SwipeCarousel();

    Component.prototype.handleTabs = function () {
        var _this24 = this;

        var parBase = this.element.parentElement;
        var parBaseParent = parBase.parentElement;

        if (!parBaseParent.classList.contains(classes.tabs)) {
            this.initCarousel();
            this.inited = true;
            return;
        }

        if (parBaseParent.classList.contains(classes.active)) {
            this.initCarousel();
            this.inited = true;
        }

        var observer = new MutationObserver(function (mutationList) {
            mutationList.forEach(function (mutation) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class' && mutation.target.classList.contains(classes.active)) {
                    if (!_this24.inited) {
                        _this24.initCarousel();
                        _this24.inited = true;
                    } else {
                        _this24.updateCarousel();
                    }
                }
            });
        });
        observer.observe(parBaseParent, {
            attributes: true
        });
    };

    Component.selector = '.scrolling-blocks-ui-23';
    Component.moduleName = 'Scrolling Blocks 23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ScrollingInfographic23', ['utils', 'media', 'gradients'], function (utils, media, gradients) {
    'use strict';

    var CLASSES = {
        item: '.scroll-infographic-ui-23__item',
        title: '.scroll-infographic-ui-23__item-title',
        heading: '.scroll-infographic-ui-23__item-heading',
        transparent: 'transparent',
        continuum: 'ec-mode',
        verticalScroll: 'vertical-scroll',
        scrollableSection: '.scroll-infographic-ui-23__scrollable-section'
    };

    var MAX_ITEMS = 4;
    var N & DS_RIGHT_RATIO = 0.5;
    var N & DS_MIDDLE_RATIO = 1.4;

    var Component = function () {
        function Component($el) {
            _classCallCheck(this, Component);

            this.$el = $el[0];
            this.$items = this.$el.querySelectorAll(CLASSES.item);
            this.$scrollableSection = this.$el.querySelectorAll(CLASSES.scrollableSection)[0];
            this.onLoad = this.onLoad.bind(this);
            this.onResize = this.onResize.bind(this);
            this.isPropsVertical = this.$scrollableSection.dataset.propsVertical === 'true';
            this.size = this.$scrollableSection.dataset.stickyScrollSize;
            this.gradientText = new gradients.GradientText();

            this.init();
        }

        _createClass(Component, [{
            key: 'init',
            value: function init() {
                this.bindEvents();
                this.setTitleHeight();
            }
        }, {
            key: 'onLoad',
            value: function onLoad() {
                var nodes = document.querySelectorAll(CLASSES.heading);
                this.gradientText.init(nodes, { rightRatio: N & DS_RIGHT_RATIO, middleRatio: N & DS_MIDDLE_RATIO });
                this.defineBehaviour();
            }
        }, {
            key: 'onResize',
            value: function onResize() {
                this.setTitleHeight();
                this.defineBehaviour();
            }
        }, {
            key: 'bindEvents',
            value: function bindEvents() {
                window.addEventListener('load', this.onLoad);
                window.addEventListener('resize', utils.debounce(this.onResize, 300));
            }
        }, {
            key: 'setTitleHeight',
            value: function setTitleHeight() {
                var maxTitleHeight = this.getMaxTitleHeight();

                [].concat(_toConsumableArray(this.$items)).forEach(function (item) {
                    var title = item.querySelector(CLASSES.title);
                    if (title && title.offsetHeight < maxTitleHeight) {
                        title.style.height = maxTitleHeight + 'px';
                    }
                });
            }
        }, {
            key: 'getMaxTitleHeight',
            value: function getMaxTitleHeight() {
                return [].concat(_toConsumableArray(this.$items)).reduce(function (maxHeight, item) {
                    var title = item.querySelector(CLASSES.title);
                    return title ? Math.max(maxHeight, title.offsetHeight) : maxHeight;
                }, 0);
            }
        }, {
            key: 'isVertical',
            value: function isVertical() {
                return this.isPropsVertical || this.size < MAX_ITEMS && !this.isPropsVertical && media.currentMode().lessThan(media.modes.Tablet);
            }
        }, {
            key: 'defineBehaviour',
            value: function defineBehaviour() {
                if (this.isVertical()) {
                    this.$scrollableSection.classList.add(CLASSES.verticalScroll);
                    this.$el.classList.add(CLASSES.verticalScroll);
                } else {
                    this.$scrollableSection.classList.remove(CLASSES.verticalScroll);
                    this.$el.classList.remove(CLASSES.verticalScroll);
                }
            }
        }]);

        return Component;
    }();

    Component.selector = '.scroll-infographic-ui-23';
    Component.moduleName = 'Scrolling Infographic 23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('Tabs23', ['TabsUtil', 'utils', 'media', 'constants', 'jquery-plugins'], function (TabsUtil, utils, media, constants) {
    'use strict';

    var $window = $(window);
    var classes = {
        title: '.tabs__title',
        hideDivider: 'tabs__title--no-divider',
        tabsWrapper: '.tabs-23__ul-wrapper',
        tabsTitle: '.tabs-23__title',
        tabsLink: '.tabs-23__link',
        open: 'open',
        slider: '.slider-ui-23',
        sliderWithoutSection: '.tabs-23__item > .slider .slider-ui-23',
        contentContainer: '.content-container',
        contentSection: '.content-container > .section .section__wrapper',
        fullWidthSection: '.section--full-width',
        activeTab: '.tabs-23__item.active'
    };

    /**
     * Tabs component
     * @param { jQuery } $el
     * @constructor
     */
    function Component($el) {
        this.modernEl = $el[0];
        this.tabsWrapper = this.modernEl.querySelector(classes.tabsWrapper);
        TabsUtil.call(this, $el, {
            useHistory: true,
            responsiveView: false,
            scrollToElement: $el,
            responsiveBreakpoint: media.modes.Tablet.end,
            autoWidth: false,
            nav: false,
            dots: false
        });
        this.$titles = this.$el.find(classes.title);

        $window.on('popstate', this.onPopState.bind(this));

        utils.checkDividers(this.$titles, classes.hideDivider);
        utils.redirectToPageAnchor();
        $(window).on('load', this.clearInitialFocus.bind(this));
        $(window).on('click', this.closeTabOnOutsideClick.bind(this));
        $(window).on('resize orientationchange', this.closeDropdownOnResize.bind(this));

        this.adjustSliderWidth();
        $(window).on(constants.Events.tabChanged, this.adjustSliderWidth.bind(this));
        $(window).on('resize', this.adjustSliderWidth.bind(this));
    }

    Component.prototype = Object.create(TabsUtil.prototype);

    /**
     * Open active tab on popstate
     * @param {{ state: State }} event
     */
    Component.prototype.onPopState = function (event) {
        var selector = '[href="' + location.hash + '"]',
            $target = this.$links.filter(selector),
            targetTab = $target.data('item');

        if (!$target.length && event.state) {
            history.back();
        }
        $target.length && this.$el.trigger(TabsUtil.events.tabChange, { tab: targetTab });
    };

    Component.prototype.closeTabOnOutsideClick = function () {
        var isMobile = media.getViewportWidth() < media.modes.Tablet.start;

        if (isMobile && this.tabsWrapper && this.tabsWrapper.classList.contains(classes.open)) {
            this.tabsWrapper.classList.remove(classes.open);
        }
    };

    Component.prototype.clearInitialFocus = function () {
        var list = this.modernEl.querySelectorAll(classes.tabsTitle);

        list.forEach(function (tab) {
            var link = tab.querySelector(classes.tabsLink);
            link.blur();
        });
    };

    Component.prototype.closeDropdownOnResize = function () {
        var isMobile = media.getViewportWidth() < media.modes.Tablet.start;

        if (!isMobile && this.tabsWrapper && this.tabsWrapper.classList.contains(classes.open)) {
            this.tabsWrapper.classList.remove(classes.open);
        }
    };

    Component.prototype.adjustSliderWidth = function () {
        var fullWidth = $(classes.contentContainer).width();
        var contentSectionWidth = $(classes.contentSection).width();
        var additionalMargin = (fullWidth - contentSectionWidth) / 2;

        var $sections = this.$el.find(classes.fullWidthSection);

        function updateElementWidth($element, $slider) {
            var elementWidth = $element.width();

            if (elementWidth > 0 && elementWidth !== fullWidth) {
                requestAnimationFrame(function () {
                    $element.css('margin-right', -additionalMargin);
                    $element.css('margin-left', -additionalMargin);
                });

                if ($slider.parents(classes.activeTab).length) {
                    $(window).trigger(constants.Events.sliderResize, $slider[0]);
                }
            }
        }

        $sections.each(function () {
            var $section = $(this);
            var slider = $section.find(classes.slider)[0];
            if (slider) {
                updateElementWidth($section, $(slider));
            }
        });

        var $sliders = this.$el.find(classes.sliderWithoutSection);
        $sliders.each(function () {
            var $slider = $(this);

            updateElementWidth($slider, $slider);
        });
    };

    Component.moduleName = 'Tabs-23';
    Component.selector = '.tabs-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('UpcomingEvent23', ['utils-env', 'utils-browser'], function (env) {
    'use strict';

    var TABLET_BREAKPOINT = 768;
    var CLASSES = {
        wrapper: '.upcoming-event-ui-23',
        image: '.upcoming-event-ui-23__image img',
        title: '.upcoming-event-ui-23__link',
        arrow: '.upcoming-event-ui-23__arrow-button',
        hovered: 'hovered',
        animated: 'animated'
    };

    var Component = function () {
        function Component($el) {
            _classCallCheck(this, Component);

            this.$wrapper = $el[0];
            this.$image = $el.find(CLASSES.image)[0];
            this.$title = $el.find(CLASSES.title)[0];
            this.$arrow = $el.find(CLASSES.arrow)[0];
            this.bindedAnimateIfInViewPort = this.animateIfInViewPort.bind(this);
            this.init();

            if (env.isEditMode()) {
                this.$wrapper.classList.add(CLASSES.animated);
            }
        }

        _createClass(Component, [{
            key: 'init',
            value: function init() {
                window.addEventListener('scroll', this.bindedAnimateIfInViewPort);

                var self = this;
                window.addEventListener('load', function () {
                    self.animateIfInViewPort();
                });

                if (window.innerWidth >= TABLET_BREAKPOINT) {
                    this.handleImageHover();
                    this.handleTitleHover();
                    this.handleArrowHover();
                }
            }
        }, {
            key: 'handleImageHover',
            value: function handleImageHover() {
                var _this25 = this;

                this.$image.addEventListener('mouseover', function () {
                    _this25.$title.classList.add(CLASSES.hovered);
                    _this25.$arrow.classList.add(CLASSES.hovered);
                });
                this.$image.addEventListener('mouseout', function () {
                    _this25.$title.classList.remove(CLASSES.hovered);
                    _this25.$arrow.classList.remove(CLASSES.hovered);
                });
            }
        }, {
            key: 'handleTitleHover',
            value: function handleTitleHover() {
                var _this26 = this;

                this.$title.addEventListener('mouseover', function () {
                    _this26.$image.classList.add(CLASSES.animated);
                    _this26.$arrow.classList.add(CLASSES.hovered);
                });
                this.$title.addEventListener('mouseout', function () {
                    _this26.$image.classList.remove(CLASSES.animated);
                    _this26.$arrow.classList.remove(CLASSES.hovered);
                });
            }
        }, {
            key: 'handleArrowHover',
            value: function handleArrowHover() {
                var _this27 = this;

                this.$arrow.addEventListener('mouseover', function () {
                    _this27.$image.classList.add(CLASSES.animated);
                    _this27.$title.classList.add(CLASSES.hovered);
                });
                this.$arrow.addEventListener('mouseout', function () {
                    _this27.$image.classList.remove(CLASSES.animated);
                    _this27.$title.classList.remove(CLASSES.hovered);
                });
            }
        }, {
            key: 'animateIfInViewPort',
            value: function animateIfInViewPort() {
                if (!this.$wrapper) {
                    return;
                }

                var screenTopOffset = this.$wrapper.getBoundingClientRect().top;
                var scrollTop = window.scrollY || document.documentElement.scrollTop;
                var topOfElement = scrollTop + screenTopOffset;
                var bottomOfElement = topOfElement + this.$wrapper.offsetHeight;
                var bottomOfScreen = scrollTop + window.innerHeight;
                var topOfScreen = scrollTop;
                var heightWrapper = this.$wrapper.offsetHeight;
                var topOffset = bottomOfScreen - topOfElement;
                var bottomOffset = bottomOfElement - topOfScreen;

                if (topOffset >= heightWrapper / 2 || bottomOffset <= heightWrapper / 2) {
                    this.animateBlock();
                    window.removeEventListener('scroll', this.bindedAnimateIfInViewPort);
                }
            }
        }, {
            key: 'animateBlock',
            value: function animateBlock() {
                var _this28 = this;

                setTimeout(function () {
                    _this28.$wrapper.classList.add(CLASSES.animated);
                }, 150);
            }
        }]);

        return Component;
    }();

    Component.moduleName = 'Upcoming-Event-23';
    Component.selector = '.upcoming-event-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('VideoShowcasesClasses23', [], function () {
    'use strict';

    return {
        PLAYER: 'video-showcase__player-section',
        VIDEO: 'video-showcase__video',
        VIDEO_TITLE: 'video-showcase__title',
        VIDEO_TITLE_ACTIVE: 'video-showcase__title--active',
        OVERLAY_ICONS: 'video-showcase__overlay-icons',
        OVERLAY_PLAY_ACTIVE: 'overlay-play-active',
        OVERLAY_PAUSE_ACTIVE: 'overlay-pause-active',
        PROGRESS_BAR: 'video-showcase__progress-bar',
        DURATION: 'video-showcase__duration',
        TIME_ELAPSED: 'video-showcase__time-elapsed',
        VOLUME_BUTTON: 'video-showcase__volume-button',
        VOLUME_ICONS: 'video-showcase__volume-button svg',
        VOLUME_HIGH: 'volume-high',
        VOLUME_LOW: 'volume-low',
        VOLUME_MUTE: 'volume-mute',
        VOLUME: 'video-showcase__volume',
        FULLSCREEN_BUTTON: 'video-showcase__fullscreen-button',
        PLAY_BUTTON: 'video-showcase__play-button',
        CONTROL_SECTION: 'video-showcase__controls-section',
        SLIDER_IMG_WRAPPER: 'video-showcase__img-wrapper',
        TRAY_SEEK: 'video-showcase__tray-seek',
        DELAY_PLAY: 'video-showcase__delay-play',
        WAIT_FOR_PLAY: 'video-showcase__wait-for-play',
        OWL: 'owl-carousel',
        NEXT_ICON: 'video-showcase__nav-control-next',
        PREV_ICON: 'video-showcase__nav-control-prev',
        BLACK_FRAME: 'video-showcase__black-frame',
        VIDEO_SHOWCASE_PROGRESS_BAR_PROGRESS: 'video-showcase__progress-bar-progress',
        VIDEO_SHOWCASE_PROGRESS_BAR_TRACK: 'video-showcase__progress-bar-track',
        VIDEO_SHOWCASE_PROGRESS_BAR_HIDDEN_AREA: 'video-showcase__progress-bar-hidden-area',

        events: {
            'PLAY_EVENT': 'customPlayEvent',
            'PAUSE_EVENT': 'customPauseEvent',
            'PLAY_FROM_START': 'customPlayFromStartEvent',
            'PLAY_TILE_EVENT': 'customTilePlayEvent',
            'NEW_LOAD_REQUEST': 'customNewLoadEvent'
        }
    };
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */

/* eslint-disable max-params */
define('VideoShowcases23', ['utils-browser', 'utils', 'VideoShowcasePlayerFunctions23', 'VideoShowcasesInitA11Y23', 'VideoShowcasesClasses23', 'utils-env'], function (browser, utils, playerFunctions, a11yInit, classes, utilEnv) {
    'use strict';
    /* eslint-enable */

    var videoWorks = !!document.createElement('video').canPlayType;

    var Component = function () {
        function Component($el) {
            _classCallCheck(this, Component);

            this.$el = $el[0];
            this.isIE = browser.isInternetExplorer();
            this.$player = this.$el.querySelector('.' + classes.PLAYER);
            this.$video = this.$el.querySelector('.' + classes.VIDEO);
            this.$owl = $(this.$el.querySelector('.' + classes.OWL));
            this.$isHideSlider = this.$el.dataset.hideCarousel;
            this.$videoSliderItems = this.$el.querySelectorAll('.' + classes.SLIDER_IMG_WRAPPER);
            this.$videoTitleActive = this.$el.querySelector('.' + classes.VIDEO_TITLE_ACTIVE);
            this.$progressBar = this.$el.querySelector('.' + classes.PROGRESS_BAR);
            this.$controlSection = this.$el.querySelector('.' + classes.CONTROL_SECTION);
            this.$duration = this.$el.querySelector('.' + classes.DURATION);
            this.$timeElapsed = this.$el.querySelector('.' + classes.TIME_ELAPSED);
            this.$overlayIcons = this.$el.querySelector('.' + classes.OVERLAY_ICONS);
            this.$volumeButton = this.$el.querySelector('.' + classes.VOLUME_BUTTON);
            this.$volumeIcons = this.$el.querySelectorAll('.' + classes.VOLUME_ICONS);
            this.$volumeLow = this.$el.querySelector('.video-showcase__volume-button svg:nth-child(2)');
            this.$volumeHigh = this.$el.querySelector('.video-showcase__volume-button svg:nth-child(3)');
            this.$volumeMute = this.$el.querySelector('.video-showcase__volume-button svg:nth-child(1)');
            this.$volume = this.$el.querySelector('.' + classes.VOLUME);
            this.$fullscreenButton = this.$el.querySelector('.' + classes.FULLSCREEN_BUTTON);
            this.$playButton = this.$el.querySelector('.' + classes.PLAY_BUTTON);
            this.$delayPlayContainer = this.$el.querySelector('.' + classes.DELAY_PLAY);
            this.$waitForPlay = this.$el.querySelector('.' + classes.WAIT_FOR_PLAY);
            this.nextIcon = this.$el.querySelector('.' + classes.NEXT_ICON);
            this.prevIcon = this.$el.querySelector('.' + classes.PREV_ICON);
            this.blackFrame = this.$el.querySelector('.' + classes.BLACK_FRAME);
            this.$videoProgressBar = this.$el.querySelector('.' + classes.VIDEO_SHOWCASE_PROGRESS_BAR_PROGRESS);
            this.$videoProgressBarTrack = this.$el.querySelector('.' + classes.VIDEO_SHOWCASE_PROGRESS_BAR_TRACK);
            this.$videoProgressBarHiddenArea = this.$el.querySelector('.' + classes.VIDEO_SHOWCASE_PROGRESS_BAR_HIDDEN_AREA);

            this.isFirstPlay = true;
            this.isOverlayRemoved = false;
            this.activeVideoIndex = 0;
            this.userClick = false;
            this.delayPlayRemoved = true;
            this.activeIndex = [];
            this.owlItems = [];
            this.fromStart = false;
            this.promisePending = false;
            this.publishMode = !utilEnv.isEditMode();

            this.customPlayEvent = document.createEvent('Event');
            this.customPauseEvent = document.createEvent('Event');
            this.customPlayFromStartEvent = document.createEvent('Event');
            this.customTilePlayEvent = document.createEvent('Event');
            this.customNewLoadRequestEvent = document.createEvent('Event');
            this.customPlayEvent.initEvent(classes.events.PLAY_EVENT, true, true);
            this.customPauseEvent.initEvent(classes.events.PAUSE_EVENT, true, true);
            this.customPlayFromStartEvent.initEvent(classes.events.PLAY_FROM_START, true, true);
            this.customTilePlayEvent.initEvent(classes.events.PLAY_TILE_EVENT, true, true);
            this.customNewLoadRequestEvent.initEvent(classes.events.NEW_LOAD_REQUEST, true, true);

            this.init();
        }

        _createClass(Component, [{
            key: 'init',
            value: function init() {
                this.setDefaultVideo();
                this.setVideoIndex();
                this.initOwlCarousel();

                if (this.publishMode) {
                    this.setDefaultVideo();
                    this.initEventsHandlers(this);
                    this.initOwlCarousel();
                    a11yInit.loadDelayPlayIconAnimation.call(this);
                    this.activeTraySeek();

                    if (this.isIE || browser.detectIOSDevice()) {
                        playerFunctions.removeVideoOverlay.call(this);
                    } else {
                        a11yInit.loadWaitAnimation.call(this);
                        this.isSupportPlayer();
                        this.customVideoEvents();
                    }

                    if (browser.isSafari() && !browser.isIOS()) {
                        this.fixWebSafariVideoControls();
                    }
                }
            }
        }, {
            key: 'setVideoIndex',
            value: function setVideoIndex() {
                Array.prototype.forEach.call(this.$videoSliderItems, function (item, index) {
                    item.setAttribute('data-index', index);
                });
            }
        }, {
            key: 'initOwlCarousel',
            value: function initOwlCarousel() {
                if (this.$isHideSlider === '1') {
                    this.$el.querySelector('.video-showcase__slider-section').classList.add('hidden');
                    return;
                }
                var additionOpt = this.$videoSliderItems.length > 3;
                var itemCount = this.$videoSliderItems.length > 3 ? 3 : this.$videoSliderItems.length;

                this.$owl.on('initialized.owl.carousel', function () {
                    if (this.publishMode) {
                        a11yInit.initA11y.call(this);
                        a11yInit.stopVideoBySpaceA11y.call(this);
                    }

                    this.$owl.on('refreshed.owl.carousel', function () {
                        this.removeOwlAriaAttr();
                        a11yInit.reInitA11yAttr.call(this);
                    }.bind(this));

                    this.nextIcon.addEventListener('click', function () {
                        this.activeTraySeek.call(this);
                        playerFunctions.updateTrayProgress.call(this);
                    }.bind(this));
                    this.prevIcon.addEventListener('click', function () {
                        this.activeTraySeek.call(this);
                        playerFunctions.updateTrayProgress.call(this);
                    }.bind(this));
                }.bind(this));

                this.$owl.addClass('owl-item-count-' + itemCount);
                this.$owl.owlCarousel({
                    nav: true,
                    dots: false,
                    items: itemCount,
                    responsive: false,
                    mouseDrag: additionOpt,
                    loop: additionOpt,
                    navText: [this.prevIcon, this.nextIcon],
                    navElement: 'div'
                });

                this.$owl[0].removeAttribute('style');
            }
        }, {
            key: 'isSupportPlayer',
            value: function isSupportPlayer() {
                if (videoWorks) {
                    this.$video.controls = false;
                    this.$controlSection.classList.remove('hidden');
                    playerFunctions.updateVolumeIcon.call(this);
                    this.$normalProgressbarLength = this.$videoProgressBar.getBoundingClientRect().width;
                    this.$videoProgressBarLen = function () {
                        return this.getBoundingClientRect().width;
                    }.bind(this.$videoProgressBar);
                }
            }
        }, {
            key: 'setDefaultVideo',
            value: function setDefaultVideo(source) {
                var defaultVideo = source ? source : this.$videoSliderItems[0];

                if (defaultVideo) {
                    this.changeActiveVideo(this.getVideoDataFromItem(defaultVideo));
                    this.$video.load();
                }
            }
        }, {
            key: 'delayPlayHandler',
            value: function delayPlayHandler() {
                this.blackFrame.classList.add('hidden');
                playerFunctions.removeDelayPlay.call(this);
                playerFunctions.togglePlay.call(this);
            }
        }, {
            key: 'sliderClickHandler',
            value: function sliderClickHandler(_ref3) {
                var target = _ref3.target;

                var TABLET_START_BREAKPOINT = 768;

                if (this.isIE || target.tagName === 'svg' || target.tagName === 'use' || $(target).hasClass('video-showcase__img-wrapper-overlay') || $(target).hasClass('video-showcase__tray-text') || $(window).width() < TABLET_START_BREAKPOINT) {
                    var item = $(target).closest('.' + classes.SLIDER_IMG_WRAPPER);

                    if (item.length !== 0) {
                        this.videoSlideClick(item.data().index, item[0]);
                    }
                }
            }
        }, {
            key: 'videoSlideClick',
            value: function videoSlideClick(index, item) {
                this.tileState = $(item).hasClass('active') || $(item).hasClass('pause');
                !this.isFirstPlay && playerFunctions.saveVideoProgress.call(this);
                this.activeVideoIndex = index;
                this.activeItem = item;
                this.fixPlayerHeight();
                this.$video.classList.add('video-showcase__invincible');
                this.changeActiveTile(item, index);
                this.changeActiveVideo(this.getVideoDataFromItem(item));
                this.$video.dispatchEvent(this.customNewLoadRequestEvent);
            }
        }, {
            key: 'clearPlayerStyleProperties',
            value: function clearPlayerStyleProperties() {
                this.$video.classList.remove('video-showcase__invincible');
                this.$player.removeAttribute('style');
            }
        }, {
            key: 'changeActiveTile',
            value: function changeActiveTile(item, index) {
                var activeItems = this.$el.querySelectorAll('.' + classes.SLIDER_IMG_WRAPPER);
                for (var i = 0; i < activeItems.length; i++) {
                    activeItems[i].classList.remove('active');
                    activeItems[i].classList.remove('pause');
                }

                var newActiveItems = this.$el.querySelectorAll('[data-index="' + index + '"]');
                for (var _i3 = 0; _i3 < newActiveItems.length; _i3++) {
                    newActiveItems[_i3].classList.add('active');
                }
            }
        }, {
            key: 'getVideoDataFromItem',
            value: function getVideoDataFromItem(item) {
                return item ? {
                    sources: item.querySelector('img').getAttribute('data-source'),
                    poster: item.querySelector('img').getAttribute('poster-source'),
                    title: item.dataset.title
                } : null;
            }
        }, {
            key: 'changeActiveVideo',
            value: function changeActiveVideo(_ref4) {
                var _this29 = this;

                var sources = _ref4.sources,
                    poster = _ref4.poster,
                    title = _ref4.title;

                this.$video.innerHTML = '';
                if (this.isFirstPlay) {
                    this.$video.poster = poster;
                }

                JSON.parse(sources).forEach(function (_ref5) {
                    var type = _ref5.type,
                        src = _ref5.src;

                    var source = document.createElement('source');
                    source.setAttribute('type', type);
                    source.setAttribute('src', src);
                    _this29.$video.appendChild(source);
                });

                if (!title) {
                    this.$videoTitleActive.classList.add('hidden');
                } else {
                    this.$videoTitleActive.classList.remove('hidden');
                    if (this.$videoTitleActive) {
                        this.$videoTitleActive.textContent = title;
                    }
                }
            }
        }, {
            key: 'initializeVideo',
            value: function initializeVideo() {
                var self = this;
                this.videoDuration = Math.floor(this.$video.duration);
                var time = playerFunctions.formatTime(this.videoDuration);
                this.$duration.innerText = time.minutes + ':' + time.seconds;
                this.$duration.setAttribute('datetime', time.minutes + 'm ' + time.seconds + 's');

                if (this.traySeek !== undefined) {
                    this.traySeek.setAttribute('max', this.videoDuration);
                }

                if (this.clonedTraySeekStart !== undefined) {
                    this.clonedTraySeekStart.setAttribute('max', this.videoDuration);
                }

                if (this.clonedTraySeekEnd !== undefined) {
                    this.clonedTraySeekEnd.setAttribute('max', this.videoDuration);
                }

                if (!this.isFirstPlay && !this.fromStart) {
                    playerFunctions.applyVideoProgress.call(this);
                }

                this.fromStart = false;
                $.each(this.activeIndex, function (index, itemIndex) {
                    $(self.owlItems[itemIndex]).removeClass('hide-tray-seek');
                });
            }
        }, {
            key: 'loadMetadataCallback',
            value: function loadMetadataCallback() {
                this.initializeVideo();
                this.clearPlayerStyleProperties();
            }
        }, {
            key: 'updatePlayButton',
            value: function updatePlayButton() {
                this.$playButton.classList.toggle('play');
            }
        }, {
            key: 'updateFullscreenButton',
            value: function updateFullscreenButton() {
                this.$fullscreenButton.classList.toggle('fullscreen');
            }
        }, {
            key: 'videoBorderTracker',
            value: function videoBorderTracker() {
                var videoTopCoord = this.$el.getBoundingClientRect().top;
                var screenScroll = window.pageYOffset || document.documentElement.scrollTop;
                var videoTopOffset = screenScroll + videoTopCoord;
                var videoBottomOffset = screenScroll + videoTopCoord + this.$video.offsetHeight;
                var screenTopOffset = screenScroll;
                var screenBottomOffset = screenTopOffset + window.innerHeight;
                var pauseVideo = function () {
                    if (!this.$video.paused) {
                        playerFunctions.togglePlay.call(this);
                    }
                }.bind(this);

                if (screenTopOffset > videoBottomOffset) {
                    pauseVideo();
                    return;
                }

                if (screenBottomOffset < videoTopOffset) {
                    pauseVideo();
                    return;
                }
            }
        }, {
            key: 'activeTraySeek',
            value: function activeTraySeek() {
                this.activeIndex = [];
                this.owlItems = $(this.$el).find('.owl-item');

                $.each(this.owlItems, function (index, item) {
                    var title = $(item).find('.' + classes.VIDEO_TITLE)[0];

                    if (title) {
                        item.dataset.title = title.textContent;
                    }

                    var isActive = $(item).find('[data-index="' + this.activeVideoIndex + '"]');
                    if (isActive.length !== 0) {
                        this.activeIndex.push(index);
                    } else {
                        $(item).addClass('hide-tray-seek');
                        item.querySelector('.' + classes.TRAY_SEEK).value = 0;
                    }
                }.bind(this));

                if (this.owlItems[this.activeIndex[0]] !== undefined) {
                    this.traySeek = this.owlItems[this.activeIndex[0]].querySelector('.' + classes.TRAY_SEEK);
                }
                if (this.owlItems[this.activeIndex[1]] !== undefined) {
                    this.clonedTraySeekStart = this.owlItems[this.activeIndex[1]].querySelector('.' + classes.TRAY_SEEK);
                }

                if (this.owlItems[this.activeIndex[2]] !== undefined) {
                    this.clonedTraySeekEnd = this.owlItems[this.activeIndex[2]].querySelector('.' + classes.TRAY_SEEK);
                }
            }
        }, {
            key: 'mouseMove',
            value: function mouseMove() {
                this.$player.classList.add('mouse-move');

                if (this.setTimeoutId !== undefined || this.setTimeoutId !== null) {
                    clearTimeout(this.setTimeoutId);
                }

                this.setTimeoutId = setTimeout(function () {
                    this.$player.classList.remove('mouse-move');
                    this.setTimeoutId = null;
                }.bind(this), 15000);
            }
        }, {
            key: 'fixPlayerHeight',
            value: function fixPlayerHeight() {
                var rect = this.$player.getBoundingClientRect();
                this.$player.setAttribute('style', 'height:' + rect.height + 'px');
            }
        }, {
            key: 'resizeEventHandler',
            value: function resizeEventHandler() {
                this.$owl.trigger('refresh.owl.carousel');
            }
        }, {
            key: 'fullscreenchangeEventHandler',
            value: function fullscreenchangeEventHandler(event) {
                if (event.target === this.$player) {
                    playerFunctions.updateFullscreenButtonsAriaLabel.call(this);
                }
            }
        }, {
            key: 'iosEventHandler',
            value: function iosEventHandler(e) {
                if (e.type === 'play') {
                    playerFunctions.activeCarouselSlide.call(this, 'add');
                } else {
                    playerFunctions.activeCarouselSlide.call(this, 'remove');
                }
            }
        }, {
            key: 'removeOwlAriaAttr',
            value: function removeOwlAriaAttr() {
                var owlItems = this.$el.querySelectorAll('[role="tab"]');
                for (var i = 0; i < owlItems.length; i++) {
                    owlItems[i].removeAttribute('tabindex');
                    owlItems[i].removeAttribute('aria-selected');
                    owlItems[i].removeAttribute('role');
                }
            }
        }, {
            key: 'customVideoEvents',
            value: function customVideoEvents() {
                this.$video.addEventListener('timeupdate', playerFunctions.timeUpdate.bind(this));
                this.$volume.addEventListener('input', playerFunctions.updateVolume.bind(this));
                this.$video.addEventListener('volumechange', playerFunctions.updateVolumeIcon.bind(this));
                this.$player.addEventListener('click', playerFunctions.playerClick.bind(this));
                this.$player.addEventListener('fullscreenchange', this.updateFullscreenButton.bind(this));
                this.$player.addEventListener('mousemove', utils.debounceExtend(this.mouseMove.bind(this), 100));
            }
        }, {
            key: 'initEventsHandlers',
            value: function initEventsHandlers() {
                this.$video.addEventListener('timeupdate', playerFunctions.updateTrayProgress.bind(this));
                this.$video.addEventListener('ended', playerFunctions.videoEnded.bind(this));
                this.$video.addEventListener('loadedmetadata', this.loadMetadataCallback.bind(this));
                this.$video.addEventListener('canplay', playerFunctions.videoCanPlayEvent.bind(this));
                this.$video.addEventListener('waiting', playerFunctions.videoWaitEvent.bind(this));
                if (browser.detectIOSDevice()) {
                    //IOS video player ignores custom events
                    this.$video.addEventListener('play', this.iosEventHandler.bind(this));
                    this.$video.addEventListener('pause', this.iosEventHandler.bind(this));
                }
                this.$video.addEventListener(classes.events.PLAY_EVENT, playerFunctions.handlePlayEvent.bind(this));
                this.$video.addEventListener(classes.events.PAUSE_EVENT, playerFunctions.handlePauseEvent.bind(this));
                this.$video.addEventListener(classes.events.PLAY_FROM_START, playerFunctions.handlePlayFromStartEvent.bind(this));
                this.$video.addEventListener(classes.events.PLAY_TILE_EVENT, playerFunctions.handlePLayTileEvent.bind(this));
                this.$video.addEventListener(classes.events.NEW_LOAD_REQUEST, playerFunctions.handleNewLoadEvent.bind(this));
                this.$videoProgressBarHiddenArea.addEventListener('click', playerFunctions.progressBarClickHandler.bind(this));
                this.$owl[0].addEventListener('click', this.sliderClickHandler.bind(this));
                window.addEventListener('scroll', utils.debounceExtend(this.videoBorderTracker.bind(this), 100));
                window.addEventListener('resize', utils.debounceExtend(this.resizeEventHandler.bind(this), 300));
                window.addEventListener('fullscreenchange', this.fullscreenchangeEventHandler.bind(this));
                this.initMouseMoveEvents();
            }
        }, {
            key: 'initMouseMoveEvents',
            value: function initMouseMoveEvents() {
                this.$videoProgressBarHiddenArea.addEventListener('mousedown', playerFunctions.changeMouseState.bind(this, true));
                this.$videoProgressBarHiddenArea.addEventListener('mouseup', playerFunctions.changeMouseState.bind(this, false));
                this.$videoProgressBarHiddenArea.addEventListener('mouseleave', playerFunctions.changeMouseState.bind(this, false));
                this.$videoProgressBarHiddenArea.addEventListener('mousemove', playerFunctions.mouseMoveEventHandler.bind(this));
                this.$videoProgressBarHiddenArea.addEventListener('touchmove', playerFunctions.mouseMoveEventHandler.bind(this));
                this.$videoProgressBarHiddenArea.addEventListener('touchstart', playerFunctions.changeMouseState.bind(this, true));
                this.$videoProgressBarHiddenArea.addEventListener('touchend', playerFunctions.changeMouseState.bind(this, false));
            }

            // native safari video controls overlapping the custom ones

        }, {
            key: 'fixWebSafariVideoControls',
            value: function fixWebSafariVideoControls() {
                this.$player.classList.add('safari-web');
            }
        }]);

        return Component;
    }();

    Component.moduleName = 'Video Showcases 23';
    Component.selector = '.video-showcase-ui-23';

    return Component;
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('VideoShowcasesInitA11Y23', ['utils', 'VideoShowcasePlayerFunctions23', 'VideoShowcaseA11y23'], function (utils, playerFunctions, a11y) {
    'use strict';

    function movementCallback(f) {
        if (this.$videoSliderItems.length > 3) {
            f(this);
            this.$owl.trigger('to.owl.carousel', [this.currentSlide, 0]);
        }
    }

    function a11yForwardCallback() {
        movementCallback.call(this, function () {
            if (this.$videoSliderItems.length - 1 >= this.currentSlideindex) {
                this.currentSlideindex = 0;
            }
        }.bind(this));
    }

    function a11yDownwardCallback() {
        movementCallback.call(this, function () {
            this.currentSlideindex--;
            if (this.currentSlideindex <= 0) {
                this.currentSlideindex = this.$videoSliderItems.length - 1;
            }
        }.bind(this));
    }

    function a11yEnterClickCallback(target) {
        var index = Number(target.querySelector('.video-showcase__img-wrapper').dataset.index);
        if (this.activeVideoIndex === index) {
            playerFunctions.togglePlay.call(this);
            return;
        }
        this.fixPlayerHeight();
        this.videoSlideClick(index, target);
    }

    function initA11y() {
        $(this.$el).find('.owl-stage').addClass('a11y-navigation-panel');
        a11y.init.call(this, {
            'list-item': 'owl-item:not(.cloned)',
            'move-forward-callback': a11yForwardCallback.bind(this),
            'move-downward-callback': a11yDownwardCallback.bind(this),
            'enter-action': a11yEnterClickCallback.bind(this)
        });
    }

    function reInitA11yAttr() {
        a11y.setSpecialAttribute.call(this);
    }

    function loadWaitAnimation() {
        utils.loadLottieFile({
            container: this.$waitForPlay,
            loop: true,
            autoplay: true,
            path: '/etc/designs/epam-com/json-animations/loading-balls.js'
        });
    }

    function loadDelayPlayIconAnimation() {
        this.delayAnimation = utils.loadLottieFile({
            container: this.$delayPlayContainer,
            loop: false,
            autoplay: false,
            path: '/etc/designs/epam-com/json-animations/delay-play.js'
        });

        this.delayAnimation.addEventListener('complete', this.delayPlayHandler.bind(this));
    }

    function stopVideoBySpaceA11y() {
        var _this30 = this;

        var timeLine = this.$el.querySelector('.video-showcase__video-progress');

        timeLine.addEventListener('keydown', function (_ref6) {
            var keyCode = _ref6.keyCode;

            if (keyCode === 32) {
                playerFunctions.togglePlay.call(_this30);
            }
        });
    }

    return {
        loadWaitAnimation: loadWaitAnimation,
        loadDelayPlayIconAnimation: loadDelayPlayIconAnimation,
        initA11y: initA11y,
        reInitA11yAttr: reInitA11yAttr,
        stopVideoBySpaceA11y: stopVideoBySpaceA11y
    };
});
/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('VideoShowcasePlayerFunctions23', ['VideoShowcasesClasses23'], function (classes) {
    'use strict';

    function togglePlay() {
        if (this.$video.paused || this.$video.ended) {
            this.$video.dispatchEvent(this.customPlayEvent);
        } else {
            this.$video.dispatchEvent(this.customPauseEvent);
        }
    }

    function handlePlayEvent() {
        this.$video.play();
        removeVideoOverlay.call(this);
        updatePlayButton.call(this);
        updateButtonsAriaLabel(this.$playButton, 'Play (k)', 'Pause (k)');
        activeCarouselSlide.call(this, 'add');
        changeOverlayState.call(this, classes.OVERLAY_PAUSE_ACTIVE, classes.OVERLAY_PLAY_ACTIVE);
    }

    function handleNewLoadEvent() {
        var _this31 = this;

        if (!this.promisePending) {
            var playPromise = this.$video.play();
            this.promisePending = true;
            if (playPromise !== undefined) {
                playPromise.then(function () {
                    _this31.promisePending = false;
                    _this31.$video.load();
                    _this31.tileState ? _this31.$video.dispatchEvent(_this31.customPlayFromStartEvent) : _this31.$video.dispatchEvent(_this31.customTilePlayEvent);
                    _this31.isFirstPlay = false;
                });
            }
        }
    }

    function handlePLayTileEvent() {
        this.activeTraySeek();
        this.$video.play();
        removeVideoOverlay.call(this);
        removeDelayPlay.call(this);
        updatePlayButton.call(this, 'play');
        updateButtonsAriaLabel(this.$playButton, 'Play (k)', 'Pause (k)');
        activeCarouselSlide.call(this, 'add');
    }

    function handlePlayFromStartEvent() {
        this.fromStart = true;
        this.$video.play();
    }

    function activeCarouselSlide(action) {
        this.$el.querySelectorAll('[data-index="' + this.activeVideoIndex + '"]').forEach(function (item) {
            action === 'add' ? item.classList.add('active') : item.classList.remove('active');
        });
    }

    function handlePauseEvent() {
        var _this32 = this;

        if (!this.promisePending) {
            var playPromise = this.$video.play();
            this.promisePending = true;
            if (playPromise !== undefined) {
                playPromise.then(function () {
                    _this32.$video.pause();
                    _this32.promisePending = false;
                    updatePlayButton.call(_this32);
                    changeOverlayState.call(_this32, classes.OVERLAY_PLAY_ACTIVE, classes.OVERLAY_PAUSE_ACTIVE);
                    updateButtonsAriaLabel(_this32.$playButton, 'Play (k)', 'Pause (k)');
                    activeCarouselSlide.call(_this32, 'remove');
                });
            }
        }
    }

    function changeOverlayState(removedClass, addedClass) {
        var _this33 = this;

        this.overlayTimerId && clearTimeout(this.overlayTimerId);
        this.$overlayIcons.classList.remove('hidden');
        this.$player.classList.remove(removedClass);
        this.$player.classList.add(addedClass);
        this.overlayTimerId = setTimeout(function () {
            _this33.$overlayIcons.classList.add('hidden');
        }, 1000);
    }

    function updateButtonsAriaLabel(element, defValue, altValue) {
        var title = element.getAttribute('title');
        var newTitle = title === defValue ? altValue : defValue;
        element.setAttribute('title', newTitle);
    }

    function updateFullscreenButtonsAriaLabel() {
        updateButtonsAriaLabel(this.$fullscreenButton, 'Full screen (f)', 'Exit full screen (f)');
    }

    function wipeVideoProgress() {
        sessionStorage.removeItem('track' + this.activeVideoIndex);
    }

    function toggleMute() {
        this.$video.muted = !this.$video.muted;

        if (this.$video.muted) {
            this.$volume.setAttribute('data-volume', this.$volume.value);
            this.$volume.value = 0;
        } else {
            this.$volume.value = this.$volume.dataset.volume;
        }
    }

    function updateVolume(event) {
        if (this.$video.muted) {
            this.$video.muted = false;
        }

        this.$video.volume = this.$volume.value;
        event.stopPropagation();
    }

    function formatTime(timeInSeconds) {
        if (!isNaN(timeInSeconds)) {
            var result = new Date(timeInSeconds * 1000).toISOString().substr(11, 8);
            return {
                minutes: result.substr(3, 2),
                seconds: result.substr(6, 2)
            };
        }
    }

    function updateTimeElapsed() {
        var time = formatTime(Math.floor(this.$video.currentTime));
        this.$timeElapsed.innerText = time.minutes + ':' + time.seconds;
        this.$timeElapsed.setAttribute('datetime', time.minutes + 'm ' + time.seconds + 's');
    }

    function updateProgress() {
        if (this.videoDuration && this.$videoProgressBarLen()) {
            var currentVideoTime = getVideoCurTime.call(this);
            this.videoCurPosPercent = Math.round(currentVideoTime / this.videoDuration * 100);
            var videoProgressTrackLen = this.$videoProgressBarLen() * this.videoCurPosPercent / 100;
            this.$videoProgressBarTrack.style.width = videoProgressTrackLen + 'px';
        }
    }

    function adjustProgressAfterFullScreenMode() {
        var videoProgressTrackLen = this.$normalProgressbarLength * this.videoCurPosPercent / 100;
        this.$videoProgressBarTrack.style.width = videoProgressTrackLen + 'px';
    }

    function timeUpdate() {
        updateTimeElapsed.call(this);
        updateProgress.call(this);
    }

    function getVideoCurTime() {
        return this.$video ? Math.floor(this.$video.currentTime) : null;
    }

    function updateTrayProgress() {
        var currentVideoTime = getVideoCurTime.call(this);

        if (this.traySeek !== undefined) {
            this.traySeek.value = currentVideoTime;
        }
        if (this.clonedTraySeekEnd !== undefined) {
            this.clonedTraySeekEnd.value = currentVideoTime;
        }
        if (this.clonedTraySeekStart !== undefined) {
            this.clonedTraySeekStart.value = currentVideoTime;
        }
    }

    function toggleFullScreen() {
        if (document.fullscreenElement) {
            adjustProgressAfterFullScreenMode.call(this);
            document.exitFullscreen();
        } else if (document.webkitFullscreenElement) {
            adjustProgressAfterFullScreenMode.call(this);
            document.webkitExitFullscreen();
        } else if (this.$player.requestFullscreen) {
            this.$player.requestFullscreen();
        } else if (this.$player.webkitRequestFullscreen) {
            this.$player.webkitRequestFullscreen();
        } else if (this.$player.mozRequestFullScreen) {
            this.$player.mozRequestFullScreen();
        } else if (this.$player.msRequestFullscreen) {
            this.$player.msRequestFullscreen();
        }
    }

    function clearTimer() {
        if (this.timerId) {
            clearTimeout(this.timerId);
        }
    }

    function videoCanPlayEvent() {
        clearTimer.call(this);
        this.$waitForPlay.classList.add('hidden');
    }

    function videoWaitEvent() {
        var _this34 = this;

        clearTimer.call(this);
        this.timerId = setTimeout(function () {
            _this34.$waitForPlay.classList.remove('hidden');
        }, 1000);
    }

    function updateVolumeIcon() {
        this.$volumeIcons.forEach(function (icon) {
            icon.classList.add('hidden');
        });

        this.$volumeButton.setAttribute('data-title', 'Mute (m)');

        if (this.$video.muted || this.$video.volume === 0) {
            this.$volumeMute.classList.remove('hidden');
            this.$volumeButton.setAttribute('data-title', 'Unmute (m)');
        } else if (this.$video.volume > 0 && this.$video.volume <= 0.5) {
            this.$volumeLow.classList.remove('hidden');
        } else {
            this.$volumeHigh.classList.remove('hidden');
        }

        this.$volume.setAttribute('aria-valuetext', this.$video.volume * 100 + '% volume');
    }

    function videoEnded() {
        this.blackFrame.classList.remove('hidden');
        this.fromStart = true;
        updatePlayButton.call(this);
        updateButtonsAriaLabel(this.$playButton, 'Play (k)', 'Pause (k)');
        wipeVideoProgress.call(this);
        this.activeVideoIndex === this.$videoSliderItems.length - 1 ? this.activeVideoIndex = 0 : this.activeVideoIndex += 1;
        var nextVideo = this.$videoSliderItems[this.activeVideoIndex];
        var nextVideoPoster = nextVideo.querySelector('img').getAttribute('poster-source');
        imageLoader.call(this, nextVideoPoster);
        this.changeActiveVideo(this.getVideoDataFromItem(nextVideo));
        this.$video.load();
        this.changeActiveTile(this.$videoSliderItems[this.activeVideoIndex], this.activeVideoIndex);
        autoMove.call(this);
        this.$player.classList.add('delay-overlay');
        this.$delayPlayContainer.classList.remove('hidden');
        this.delayAnimation.goToAndPlay(0);
    }

    function autoMove() {
        this.$owl.trigger('next.owl.carousel');
        this.activeTraySeek();
    }

    function saveVideoProgress() {
        if (this.$video.ended) {
            return;
        }
        sessionStorage.setItem('track' + this.activeVideoIndex, this.$video.currentTime);
    }

    function applyVideoProgress() {
        var time = sessionStorage.getItem('track' + this.activeVideoIndex);

        if (time) {
            this.$video.currentTime = time;
        }
    }

    function removeVideoOverlay() {
        if (!this.isOverlayRemoved) {
            this.$player.classList.remove('overlay');
            this.$overlayIcons.classList.add('hidden');
            this.isOverlayRemoved = true;
        }
    }

    function playerClick(_ref7) {
        var target = _ref7.target,
            tagName = _ref7.target.tagName;

        var targetId = target.getAttribute('id');
        var targetEl = target;
        var elTagName = tagName;
        if ($(targetEl).hasClass('overlay') || elTagName === 'VIDEO' || targetId === 'play') {
            togglePlay.call(this);
            return;
        }

        if (targetId === 'volume-button') {
            toggleMute.call(this);
            updateButtonsAriaLabel(this.$volumeButton, 'Mute (m)', 'Unmute (m)');
            return;
        }

        if (targetId === 'fullscreen-button') {
            toggleFullScreen.call(this);
            return;
        }

        if ($(targetEl).hasClass('delay-overlay')) {
            removeDelayPlay.call(this);
            togglePlay.call(this);
            return;
        }

        if (elTagName === 'use') {
            elTagName = 'svg';
            targetEl = $(targetEl).parent()[0];
        }

        if (elTagName === 'svg') {
            var parent = $(targetEl).parent();
            var parentType = parent.attr('id');

            if (parentType === 'play' || parentType === 'pause' || parentType === 'overlay' || parentType === 'play-overlay') {
                togglePlay.call(this);
            }

            if (parentType === 'fullscreen-button') {
                toggleFullScreen.call(this);
            }

            if (parentType === 'volume-button') {
                toggleMute.call(this);
                updateButtonsAriaLabel(this.$volumeButton, 'Mute (m)', 'Unmute (m)');
            }
        }
    }

    function updatePlayButton(className) {
        className ? this.$playButton.classList.add('play') : this.$playButton.classList.toggle('play');
    }

    function removeDelayPlay() {
        this.delayAnimation.stop();
        this.$delayPlayContainer.classList.add('hidden');
        this.$player.classList.remove('delay-overlay');
    }

    function imageLoader(src) {
        var _this35 = this;

        var img = new Image();
        img.onload = function () {
            _this35.blackFrame.classList.add('hidden');
            _this35.$video.poster = src;
        };
        img.src = src;
    }

    function getCursorPosition(el, event) {
        var ev = event;
        if (ev.touches) {
            ev = ev.touches[0];
        }

        var x = Math.round(ev.pageX - el.getBoundingClientRect().left);
        var y = Math.round(ev.pageY - el.getBoundingClientRect().left);
        return { x: x, y: y };
    }

    function setProgress(val) {
        this.$videoProgressBarTrack.style.width = val + 'px';
        this.trackValue = val;
    }

    function updateProgressBarValue() {
        var progressBarDurationPercent = Math.round(this.trackValue / this.$videoProgressBarLen() * 100);
        var videoDurationPercent = this.videoDuration * progressBarDurationPercent / 100;
        this.$video.currentTime = videoDurationPercent;
    }

    /**
     *
     * @param event
     * progressBarDurationPercent - current progress bar percentage value
     * videoDurationPercent - new video position based on current progress bar value percentage
     */
    function progressBarClickHandler(event) {
        var _getCursorPosition = getCursorPosition(this.$videoProgressBar, event),
            x = _getCursorPosition.x;

        setProgress.call(this, x);
        updateProgressBarValue.call(this);
    }

    function mouseMoveEventHandler(event) {
        if (this.mousePressed) {
            var _getCursorPosition2 = getCursorPosition(this.$videoProgressBar, event),
                x = _getCursorPosition2.x;

            setProgress.call(this, x);
            updateProgressBarValue.call(this);
        }
    }

    function changeMouseState(state) {
        this.mousePressed = state;
    }

    return {
        togglePlay: togglePlay,
        wipeVideoProgress: wipeVideoProgress,
        toggleMute: toggleMute,
        updateVolume: updateVolume,
        timeUpdate: timeUpdate,
        updateTrayProgress: updateTrayProgress,
        toggleFullScreen: toggleFullScreen,
        formatTime: formatTime,
        videoCanPlayEvent: videoCanPlayEvent,
        videoWaitEvent: videoWaitEvent,
        updateVolumeIcon: updateVolumeIcon,
        videoEnded: videoEnded,
        saveVideoProgress: saveVideoProgress,
        applyVideoProgress: applyVideoProgress,
        handlePlayEvent: handlePlayEvent,
        handlePauseEvent: handlePauseEvent,
        removeVideoOverlay: removeVideoOverlay,
        playerClick: playerClick,
        handlePlayFromStartEvent: handlePlayFromStartEvent,
        handlePLayTileEvent: handlePLayTileEvent,
        removeDelayPlay: removeDelayPlay,
        imageLoader: imageLoader,
        handleNewLoadEvent: handleNewLoadEvent,
        progressBarClickHandler: progressBarClickHandler,
        mouseMoveEventHandler: mouseMoveEventHandler,
        changeMouseState: changeMouseState,
        updateFullscreenButtonsAriaLabel: updateFullscreenButtonsAriaLabel,
        activeCarouselSlide: activeCarouselSlide
    };
});

/*
 * All Rights Reserved. All information contained herein is, and remains the property of N & DS Consultancy.
 * and/or its suppliers and is protected by international intellectual property law. Dissemination of this
 * information or reproduction of this material is strictly forbidden, unless prior written permission is
 * obtained from N & DS Consultancy
 */
define('ExperienceFragmentGDPRConsent', ['constants'], function (constants) {
    'use strict';

    var segmentsPath = '/conf/nds/settings/wcm/segments/',
        variationContentSuffix = '.content.html',
        variationChooseStrategy = 'first',
        gdprSegment = 'gdprSegment';

    var Component = function Component($el) {
        _classCallCheck(this, Component);

        this.$el = $el;
        this.$form = $el.closest('form');
        if (window.ContextHub && ContextHub.SegmentEngine) {
            this.id = $el.attr('id');
            var mappings = $el.data('mappings');
            var defaultVariant = $el.data('defaultVariation');
            if (mappings && defaultVariant) {
                this.variants = buildVariants(mappings, defaultVariant);
                ContextHubJQ(mapToEvent.bind(this));
                return;
            }
        }
        makeVisible.apply(this);
    };

    function buildVariants(mappings, defaultVariant) {
        var variants = [];
        for (var audience in mappings) {
            if (Object.prototype.hasOwnProperty.call(mappings, audience)) {
                var variant = Object.create(null);
                variant.title = audience;
                variant.url = mappings[audience] + variationContentSuffix;
                variant.segments = [segmentsPath + audience.toLowerCase()];
                variant.segmentPath = segmentsPath + audience;
                variants.push(variant);
            }
        }
        variants.push({
            title: 'Default',
            url: defaultVariant + variationContentSuffix
        });
        return variants;
    }

    function mapToEvent() {
        ContextHub.eventing.on(ContextHub.Constants.EVENT_TEASER_LOADED, onTeaserLoaded.bind(this));
        ContextHub.SegmentEngine.PageInteraction.Teaser({
            locationId: this.id,
            variants: this.variants,
            strategy: variationChooseStrategy,
            trackingURL: null
        });
        setTimeout(function () {
            makeVisible.apply(this);
        }.bind(this), 5000);
    }

    function onTeaserLoaded(event, data) {
        var _this36 = this;

        var id = this.id;
        data.data.forEach(function (evData) {
            if (evData.key === id) {
                makeVisible.apply(_this36);
            }
        });
        updateHiddenField.call(this, gdprSegment, getSegmentResolved(event, data));
        triggerFormInitEvent.call(this);
    }

    function triggerFormInitEvent() {
        var form = this.$el.closest('form');
        form.trigger(constants.Events.initConsent);
    }

    function makeVisible() {
        this.$el.removeClass('hidden');
    }

    function getSegmentResolved(event, data) {
        try {
            var teaser = data.data[0].teaser;
            var currentlyLoadedUrl = teaser.currentlyLoaded.url;
            var variants = teaser.details.variants;
            var segmentResolved = variants.find(function (elem) {
                return currentlyLoadedUrl.startsWith(elem.url);
            });
            return segmentResolved.segmentPath;
        } catch (e) {
            return '';
        }
    }

    function updateHiddenField(name, value) {
        var $field = this.$form.find('input[name=' + name + ']');
        if ($field.length) {
            $field.first().val(value);
        }
    }

    Component.moduleName = 'Experience Fragment Give GDPR Consent';
    Component.selector = '.epam-experience-fragment-ui';

    return Component;
});
/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.13.3
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 20.07.2022
 */
/* eslint-disable */

(function (global, factory) {
    if (typeof define === 'function'){
        define(['jquery'], function (framework) { return factory(global, global.document, undefined, framework); });
    }
    else if (typeof module === 'object' && typeof module.exports === 'object')
        module.exports = factory(global, global.document, undefined, require('jquery'));
    else
        factory(global, global.document, undefined, global.jQuery);
}(typeof window !== 'undefined' ? window : this,
    function (window, document, undefined, framework) {
        'use strict';
        var PLUGINNAME = 'OverlayScrollbars';
        var TYPES = {
            o: 'object',
            f: 'function',
            a: 'array',
            s: 'string',
            b: 'boolean',
            n: 'number',
            u: 'undefined',
            z: 'null'
            //d : 'date',
            //e : 'error',
            //r : 'regexp',
            //y : 'symbol'
        };
        var LEXICON = {
            c: 'class',
            s: 'style',
            i: 'id',
            l: 'length',
            p: 'prototype',
            ti: 'tabindex',
            oH: 'offsetHeight',
            cH: 'clientHeight',
            sH: 'scrollHeight',
            oW: 'offsetWidth',
            cW: 'clientWidth',
            sW: 'scrollWidth',
            hOP: 'hasOwnProperty',
            bCR: 'getBoundingClientRect'
        };
        var VENDORS = (function () {
            //https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix
            var jsCache = {};
            var cssCache = {};
            var cssPrefixes = ['-webkit-', '-moz-', '-o-', '-ms-'];
            var jsPrefixes = ['WebKit', 'Moz', 'O', 'MS'];
            function firstLetterToUpper(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            }

            return {
                _cssPrefixes: cssPrefixes,
                _jsPrefixes: jsPrefixes,
                _cssProperty: function (name) {
                    var result = cssCache[name];

                    if (cssCache[LEXICON.hOP](name))
                        return result;

                    var uppercasedName = firstLetterToUpper(name);
                    var elmStyle = document.createElement('div')[LEXICON.s];
                    var resultPossibilities;
                    var i = 0;
                    var v;
                    var currVendorWithoutDashes;

                    for (; i < cssPrefixes.length; i++) {
                        currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, '');
                        resultPossibilities = [
                            name, //transition
                            cssPrefixes[i] + name, //-webkit-transition
                            currVendorWithoutDashes + uppercasedName, //webkitTransition
                            firstLetterToUpper(currVendorWithoutDashes) + uppercasedName //WebkitTransition
                        ];
                        for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {
                            if (elmStyle[resultPossibilities[v]] !== undefined) {
                                result = resultPossibilities[v];
                                break;
                            }
                        }
                    }

                    cssCache[name] = result;
                    return result;
                },
                _cssPropertyValue: function (property, values, suffix) {
                    var name = property + ' ' + values;
                    var result = cssCache[name];

                    if (cssCache[LEXICON.hOP](name))
                        return result;

                    var dummyStyle = document.createElement('div')[LEXICON.s];
                    var possbleValues = values.split(' ');
                    var preparedSuffix = suffix || '';
                    var i = 0;
                    var v = -1;
                    var prop;

                    for (; i < possbleValues[LEXICON.l]; i++) {
                        for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {
                            prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i];
                            dummyStyle.cssText = property + ':' + prop + preparedSuffix;
                            if (dummyStyle[LEXICON.l]) {
                                result = prop;
                                break;
                            }
                        }
                    }

                    cssCache[name] = result;
                    return result;
                },
                _jsAPI: function (name, isInterface, fallback) {
                    var i = 0;
                    var result = jsCache[name];

                    if (!jsCache[LEXICON.hOP](name)) {
                        result = window[name];
                        for (; i < jsPrefixes[LEXICON.l]; i++)
                            result = result || window[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];
                        jsCache[name] = result;
                    }
                    return result || fallback;
                }
            }
        })();
        var COMPATIBILITY = (function () {
            function windowSize(x) {
                return x ? window.innerWidth || document.documentElement[LEXICON.cW] || document.body[LEXICON.cW] : window.innerHeight || document.documentElement[LEXICON.cH] || document.body[LEXICON.cH];
            }
            function bind(func, thisObj) {
                if (typeof func != TYPES.f) {
                    throw "Can't bind function!";
                    // closest thing possible to the ECMAScript 5
                    // internal IsCallable function
                    //throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
                }
                var proto = LEXICON.p;
                var aArgs = Array[proto].slice.call(arguments, 2);
                var fNOP = function () { };
                var fBound = function () { return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments))); };

                if (func[proto])
                    fNOP[proto] = func[proto]; // Function.prototype doesn't have a prototype property
                fBound[proto] = new fNOP();

                return fBound;
            }

            return {
                /**
                 * Gets the current window width.
                 * @returns {Number|number} The current window width in pixel.
                 */
                wW: bind(windowSize, 0, true),

                /**
                 * Gets the current window height.
                 * @returns {Number|number} The current window height in pixel.
                 */
                wH: bind(windowSize, 0),

                /**
                 * Gets the MutationObserver Object or undefined if not supported.
                 * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.
                 */
                mO: bind(VENDORS._jsAPI, 0, 'MutationObserver', true),

                /**
                 * Gets the ResizeObserver Object or undefined if not supported.
                 * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.
                 */
                rO: bind(VENDORS._jsAPI, 0, 'ResizeObserver', true),

                /**
                 * Gets the RequestAnimationFrame method or it's corresponding polyfill.
                 * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.
                 */
                rAF: bind(VENDORS._jsAPI, 0, 'requestAnimationFrame', false, function (func) { return window.setTimeout(func, 1000 / 60); }),

                /**
                 * Gets the CancelAnimationFrame method or it's corresponding polyfill.
                 * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.
                 */
                cAF: bind(VENDORS._jsAPI, 0, 'cancelAnimationFrame', false, function (id) { return window.clearTimeout(id); }),

                /**
                 * Gets the current time.
                 * @returns {number} The current time.
                 */
                now: function () {
                    return Date.now && Date.now() || new Date().getTime();
                },

                /**
                 * Stops the propagation of the given event.
                 * @param event The event of which the propagation shall be stoped.
                 */
                stpP: function (event) {
                    if (event.stopPropagation)
                        event.stopPropagation();
                    else
                        event.cancelBubble = true;
                },

                /**
                 * Prevents the default action of the given event.
                 * @param event The event of which the default action shall be prevented.
                 */
                prvD: function (event) {
                    if (event.preventDefault && event.cancelable)
                        event.preventDefault();
                    else
                        event.returnValue = false;
                },

                /**
                 * Gets the pageX and pageY values of the given mouse event.
                 * @param event The mouse event of which the pageX and pageX shall be got.
                 * @returns {{x: number, y: number}} x = pageX value, y = pageY value.
                 */
                page: function (event) {
                    event = event.originalEvent || event;

                    var strPage = 'page';
                    var strClient = 'client';
                    var strX = 'X';
                    var strY = 'Y';
                    var target = event.target || event.srcElement || document;
                    var eventDoc = target.ownerDocument || document;
                    var doc = eventDoc.documentElement;
                    var body = eventDoc.body;

                    //if touch event return return pageX/Y of it
                    if (event.touches !== undefined) {
                        var touch = event.touches[0];
                        return {
                            x: touch[strPage + strX],
                            y: touch[strPage + strY]
                        }
                    }

                    // Calculate pageX/Y if not native supported
                    if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {

                        return {
                            x: event[strClient + strX] +
                                (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                                (doc && doc.clientLeft || body && body.clientLeft || 0),
                            y: event[strClient + strY] +
                                (doc && doc.scrollTop || body && body.scrollTop || 0) -
                                (doc && doc.clientTop || body && body.clientTop || 0)
                        }
                    }
                    return {
                        x: event[strPage + strX],
                        y: event[strPage + strY]
                    };
                },

                /**
                 * Gets the clicked mouse button of the given mouse event.
                 * @param event The mouse event of which the clicked button shal be got.
                 * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)
                 */
                mBtn: function (event) {
                    var button = event.button;
                    if (!event.which && button !== undefined)
                        return (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                    else
                        return event.which;
                },

                /**
                 * Checks whether a item is in the given array and returns its index.
                 * @param item The item of which the position in the array shall be determined.
                 * @param arr The array.
                 * @returns {number} The zero based index of the item or -1 if the item isn't in the array.
                 */
                inA: function (item, arr) {
                    for (var i = 0; i < arr[LEXICON.l]; i++)
                        //Sometiems in IE a "SCRIPT70" Permission denied error occurs if HTML elements in a iFrame are compared
                        try {
                            if (arr[i] === item)
                                return i;
                        }
                        catch (e) { }
                    return -1;
                },

                /**
                 * Returns true if the given value is a array.
                 * @param arr The potential array.
                 * @returns {boolean} True if the given value is a array, false otherwise.
                 */
                isA: function (arr) {
                    var def = Array.isArray;
                    return def ? def(arr) : this.type(arr) == TYPES.a;
                },

                /**
                 * Determine the internal JavaScript [[Class]] of the given object.
                 * @param obj The object of which the type shall be determined.
                 * @returns {string} The type of the given object.
                 */
                type: function (obj) {
                    if (obj === undefined)
                        return obj + '';
                    if (obj === null)
                        return obj + '';
                    return Object[LEXICON.p].toString.call(obj).replace(/^\[object (.+)\]$/, '$1').toLowerCase();
                },


                bind: bind

                /**
                 * Gets the vendor-prefixed CSS property by the given name.
                 * For example the given name is "transform" and you're using a old Firefox browser then the returned value would be "-moz-transform".
                 * If the browser doesn't need a vendor-prefix, then the returned string is the given name.
                 * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.
                 * @param propName The unprefixed CSS property name.
                 * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.

                cssProp: function(propName) {
                    return VENDORS._cssProperty(propName);
                }
                */
            }
        })();

        var MATH = Math;
        var JQUERY = framework;
        var EASING = framework.easing;
        var FRAMEWORK = framework;
        var INSTANCES = (function () {
            var _targets = [];
            var _instancePropertyString = '__overlayScrollbars__';

            /**
             * Register, unregister or get a certain (or all) instances.
             * Register: Pass the target and the instance.
             * Unregister: Pass the target and null.
             * Get Instance: Pass the target from which the instance shall be got.
             * Get Targets: Pass no arguments.
             * @param target The target to which the instance shall be registered / from which the instance shall be unregistered / the instance shall be got
             * @param instance The instance.
             * @returns {*|void} Returns the instance from the given target.
             */
            return function (target, instance) {
                var argLen = arguments[LEXICON.l];
                if (argLen < 1) {
                    //return all targets
                    return _targets;
                }
                else {
                    if (instance) {
                        //register instance
                        target[_instancePropertyString] = instance;
                        _targets.push(target);
                    }
                    else {
                        var index = COMPATIBILITY.inA(target, _targets);
                        if (index > -1) {
                            if (argLen > 1) {
                                //unregister instance
                                delete target[_instancePropertyString];
                                _targets.splice(index, 1);
                            }
                            else {
                                //get instance from target
                                return _targets[index][_instancePropertyString];
                            }
                        }
                    }
                }
            }
        })();
        var PLUGIN = (function () {
            var _plugin;
            var _pluginsGlobals;
            var _pluginsAutoUpdateLoop;
            var _pluginsExtensions = [];
            var _pluginsOptions = (function () {
                var type = COMPATIBILITY.type;
                var possibleTemplateTypes = [
                    TYPES.b, //boolean
                    TYPES.n, //number
                    TYPES.s, //string
                    TYPES.a, //array
                    TYPES.o, //object
                    TYPES.f, //function
                    TYPES.z  //null
                ];
                var restrictedStringsSplit = ' ';
                var restrictedStringsPossibilitiesSplit = ':';
                var classNameAllowedValues = [TYPES.z, TYPES.s];
                var numberAllowedValues = TYPES.n;
                var booleanNullAllowedValues = [TYPES.z, TYPES.b];
                var booleanTrueTemplate = [true, TYPES.b];
                var booleanFalseTemplate = [false, TYPES.b];
                var callbackTemplate = [null, [TYPES.z, TYPES.f]];
                var updateOnLoadTemplate = [['img'], [TYPES.s, TYPES.a, TYPES.z]];
                var inheritedAttrsTemplate = [['style', 'class'], [TYPES.s, TYPES.a, TYPES.z]];
                var resizeAllowedValues = 'n:none b:both h:horizontal v:vertical';
                var overflowBehaviorAllowedValues = 'v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden';
                var scrollbarsVisibilityAllowedValues = 'v:visible h:hidden a:auto';
                var scrollbarsAutoHideAllowedValues = 'n:never s:scroll l:leave m:move';
                var optionsDefaultsAndTemplate = {
                    className: ['os-theme-dark', classNameAllowedValues],                //null || string
                    resize: ['none', resizeAllowedValues],                               //none || both  || horizontal || vertical || n || b || h || v
                    sizeAutoCapable: booleanTrueTemplate,                                //true || false
                    clipAlways: booleanTrueTemplate,                                     //true || false
                    normalizeRTL: booleanTrueTemplate,                                   //true || false
                    paddingAbsolute: booleanFalseTemplate,                               //true || false
                    autoUpdate: [null, booleanNullAllowedValues],                        //true || false || null
                    autoUpdateInterval: [33, numberAllowedValues],                       //number
                    updateOnLoad: updateOnLoadTemplate,                                  //string || array || null
                    nativeScrollbarsOverlaid: {
                        showNativeScrollbars: booleanFalseTemplate,                      //true || false
                        initialize: booleanTrueTemplate                                  //true || false
                    },
                    overflowBehavior: {
                        x: ['scroll', overflowBehaviorAllowedValues],                    //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                        y: ['scroll', overflowBehaviorAllowedValues]                     //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                    },
                    scrollbars: {
                        visibility: ['auto', scrollbarsVisibilityAllowedValues],         //visible || hidden || auto || v || h || a
                        autoHide: ['never', scrollbarsAutoHideAllowedValues],            //never || scroll || leave || move || n || s || l || m
                        autoHideDelay: [800, numberAllowedValues],                       //number
                        dragScrolling: booleanTrueTemplate,                              //true || false
                        clickScrolling: booleanFalseTemplate,                            //true || false
                        touchSupport: booleanTrueTemplate,                               //true || false
                        snapHandle: booleanFalseTemplate                                 //true || false
                    },
                    textarea: {
                        dynWidth: booleanFalseTemplate,                                  //true || false
                        dynHeight: booleanFalseTemplate,                                 //true || false
                        inheritedAttrs: inheritedAttrsTemplate                           //string || array || null
                    },
                    callbacks: {
                        onInitialized: callbackTemplate,                                 //null || function
                        onInitializationWithdrawn: callbackTemplate,                     //null || function
                        onDestroyed: callbackTemplate,                                   //null || function
                        onScrollStart: callbackTemplate,                                 //null || function
                        onScroll: callbackTemplate,                                      //null || function
                        onScrollStop: callbackTemplate,                                  //null || function
                        onOverflowChanged: callbackTemplate,                             //null || function
                        onOverflowAmountChanged: callbackTemplate,                       //null || function
                        onDirectionChanged: callbackTemplate,                            //null || function
                        onContentSizeChanged: callbackTemplate,                          //null || function
                        onHostSizeChanged: callbackTemplate,                             //null || function
                        onUpdated: callbackTemplate                                      //null || function
                    }
                };
                var convert = function (template) {
                    var recursive = function (obj) {
                        var key;
                        var val;
                        var valType;
                        for (key in obj) {
                            if (!obj[LEXICON.hOP](key))
                                continue;
                            val = obj[key];
                            valType = type(val);
                            if (valType == TYPES.a)
                                obj[key] = val[template ? 1 : 0];
                            else if (valType == TYPES.o)
                                obj[key] = recursive(val);
                        }
                        return obj;
                    };
                    return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));
                };

                return {
                    _defaults: convert(),

                    _template: convert(true),

                    /**
                     * Validates the passed object by the passed template.
                     * @param obj The object which shall be validated.
                     * @param template The template which defines the allowed values and types.
                     * @param writeErrors True if errors shall be logged to the console.
                     * @param diffObj If a object is passed then only valid differences to this object will be returned.
                     * @returns {{}} A object which contains two objects called "default" and "prepared" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.
                     */
                    _validate: function (obj, template, writeErrors, diffObj) {
                        var validatedOptions = {};
                        var validatedOptionsPrepared = {};
                        var objectCopy = FRAMEWORK.extend(true, {}, obj);
                        var inArray = FRAMEWORK.inArray;
                        var isEmptyObj = FRAMEWORK.isEmptyObject;
                        var checkObjectProps = function (data, template, diffData, validatedOptions, validatedOptionsPrepared, prevPropName) {
                            for (var prop in template) {
                                if (template[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {
                                    var isValid = false;
                                    var isDiff = false;
                                    var templateValue = template[prop];
                                    var templateValueType = type(templateValue);
                                    var templateIsComplex = templateValueType == TYPES.o;
                                    var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;
                                    var dataDiffValue = diffData[prop];
                                    var dataValue = data[prop];
                                    var dataValueType = type(dataValue);
                                    var propPrefix = prevPropName ? prevPropName + '.' : '';
                                    var error = "The option \"" + propPrefix + prop + "\" wasn't set, because";
                                    var errorPossibleTypes = [];
                                    var errorRestrictedStrings = [];
                                    var restrictedStringValuesSplit;
                                    var restrictedStringValuesPossibilitiesSplit;
                                    var isRestrictedValue;
                                    var mainPossibility;
                                    var currType;
                                    var i;
                                    var v;
                                    var j;

                                    dataDiffValue = dataDiffValue === undefined ? {} : dataDiffValue;

                                    //if the template has a object as value, it means that the options are complex (verschachtelt)
                                    if (templateIsComplex && dataValueType == TYPES.o) {
                                        validatedOptions[prop] = {};
                                        validatedOptionsPrepared[prop] = {};
                                        checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions[prop], validatedOptionsPrepared[prop], propPrefix + prop);
                                        FRAMEWORK.each([data, validatedOptions, validatedOptionsPrepared], function (index, value) {
                                            if (isEmptyObj(value[prop])) {
                                                delete value[prop];
                                            }
                                        });
                                    }
                                    else if (!templateIsComplex) {
                                        for (i = 0; i < templateTypes[LEXICON.l]; i++) {
                                            currType = templateTypes[i];
                                            templateValueType = type(currType);
                                            //if currtype is string and starts with restrictedStringPrefix and end with restrictedStringSuffix
                                            isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;
                                            if (isRestrictedValue) {
                                                errorPossibleTypes.push(TYPES.s);

                                                //split it into a array which contains all possible values for example: ["y:yes", "n:no", "m:maybe"]
                                                restrictedStringValuesSplit = currType.split(restrictedStringsSplit);
                                                errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);
                                                for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {
                                                    //split the possible values into their possibiliteis for example: ["y", "yes"] -> the first is always the mainPossibility
                                                    restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);
                                                    mainPossibility = restrictedStringValuesPossibilitiesSplit[0];
                                                    for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {
                                                        //if any possibility matches with the dataValue, its valid
                                                        if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {
                                                            isValid = true;
                                                            break;
                                                        }
                                                    }
                                                    if (isValid)
                                                        break;
                                                }
                                            }
                                            else {
                                                errorPossibleTypes.push(currType);

                                                if (dataValueType === currType) {
                                                    isValid = true;
                                                    break;
                                                }
                                            }
                                        }

                                        if (isValid) {
                                            isDiff = dataValue !== dataDiffValue;

                                            if (isDiff)
                                                validatedOptions[prop] = dataValue;

                                            if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff)
                                                validatedOptionsPrepared[prop] = isRestrictedValue ? mainPossibility : dataValue;
                                        }
                                        else if (writeErrors) {
                                            console.warn(error + " it doesn't accept the type [ " + dataValueType.toUpperCase() + " ] with the value of \"" + dataValue + "\".\r\n" +
                                                "Accepted types are: [ " + errorPossibleTypes.join(', ').toUpperCase() + " ]." +
                                                (errorRestrictedStrings[length] > 0 ? "\r\nValid strings are: [ " + errorRestrictedStrings.join(', ').split(restrictedStringsPossibilitiesSplit).join(', ') + " ]." : ''));
                                        }
                                        delete data[prop];
                                    }
                                }
                            }
                        };
                        checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared);

                        //add values which aren't specified in the template to the finished validated object to prevent them from being discarded
                        /*
                        if(keepForeignProps) {
                            FRAMEWORK.extend(true, validatedOptions, objectCopy);
                            FRAMEWORK.extend(true, validatedOptionsPrepared, objectCopy);
                        }
                        */

                        if (!isEmptyObj(objectCopy) && writeErrors)
                            console.warn('The following options are discarded due to invalidity:\r\n' + window.JSON.stringify(objectCopy, null, 2));

                        return {
                            _default: validatedOptions,
                            _prepared: validatedOptionsPrepared
                        };
                    }
                }
            }());

            /**
             * Initializes the object which contains global information about the plugin and each instance of it.
             */
            function initOverlayScrollbarsStatics() {
                if (!_pluginsGlobals)
                    _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);
                if (!_pluginsAutoUpdateLoop)
                    _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);
            }

            /**
             * The global object for the OverlayScrollbars objects. It contains resources which every OverlayScrollbars object needs. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
             * @param defaultOptions
             * @constructor
             */
            function OverlayScrollbarsGlobals(defaultOptions) {
                var _base = this;
                var strOverflow = 'overflow';
                var strHidden = 'hidden';
                var strScroll = 'scroll';
                var bodyElement = FRAMEWORK('body');
                var scrollbarDummyElement = FRAMEWORK('<div id="os-dummy-scrollbar-size"><div></div></div>');
                var scrollbarDummyElement0 = scrollbarDummyElement[0];
                var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children('div').eq(0));

                bodyElement.append(scrollbarDummyElement);
                scrollbarDummyElement.hide().show(); //fix IE8 bug (incorrect measuring)

                var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);
                var nativeScrollbarIsOverlaid = {
                    x: nativeScrollbarSize.x === 0,
                    y: nativeScrollbarSize.y === 0
                };
                var msie = (function () {
                    var ua = window.navigator.userAgent;
                    var strIndexOf = 'indexOf';
                    var strSubString = 'substring';
                    var msie = ua[strIndexOf]('MSIE ');
                    var trident = ua[strIndexOf]('Trident/');
                    var edge = ua[strIndexOf]('Edge/');
                    var rv = ua[strIndexOf]('rv:');
                    var result;
                    var parseIntFunc = parseInt;

                    // IE 10 or older => return version number
                    if (msie > 0)
                        result = parseIntFunc(ua[strSubString](msie + 5, ua[strIndexOf]('.', msie)), 10);

                    // IE 11 => return version number
                    else if (trident > 0)
                        result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf]('.', rv)), 10);

                    // Edge (IE 12+) => return version number
                    else if (edge > 0)
                        result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf]('.', edge)), 10);

                    // other browser
                    return result;
                })();

                FRAMEWORK.extend(_base, {
                    defaultOptions: defaultOptions,
                    msie: msie,
                    autoUpdateLoop: false,
                    autoUpdateRecommended: !COMPATIBILITY.mO(),
                    nativeScrollbarSize: nativeScrollbarSize,
                    nativeScrollbarIsOverlaid: nativeScrollbarIsOverlaid,
                    nativeScrollbarStyling: (function () {
                        var result = false;
                        scrollbarDummyElement.addClass('os-viewport-native-scrollbars-invisible');
                        try {
                            result = (scrollbarDummyElement.css('scrollbar-width') === 'none' && (msie > 9 || !msie)) || window.getComputedStyle(scrollbarDummyElement0, '::-webkit-scrollbar').getPropertyValue('display') === 'none';
                        } catch (ex) { }

                        //fix opera bug: scrollbar styles will only appear if overflow value is scroll or auto during the activation of the style.
                        //and set overflow to scroll
                        //scrollbarDummyElement.css(strOverflow, strHidden).hide().css(strOverflow, strScroll).show();
                        //return (scrollbarDummyElement0[LEXICON.oH] - scrollbarDummyElement0[LEXICON.cH]) === 0 && (scrollbarDummyElement0[LEXICON.oW] - scrollbarDummyElement0[LEXICON.cW]) === 0;

                        return result;
                    })(),
                    overlayScrollbarDummySize: { x: 30, y: 30 },
                    cssCalc: VENDORS._cssPropertyValue('width', 'calc', '(1px)') || null,
                    restrictedMeasuring: (function () {
                        //https://bugzilla.mozilla.org/show_bug.cgi?id=1439305
                        //since 1.11.0 always false -> fixed via CSS (hopefully)
                        scrollbarDummyElement.css(strOverflow, strHidden);
                        var scrollSize = {
                            w: scrollbarDummyElement0[LEXICON.sW],
                            h: scrollbarDummyElement0[LEXICON.sH]
                        };
                        scrollbarDummyElement.css(strOverflow, 'visible');
                        var scrollSize2 = {
                            w: scrollbarDummyElement0[LEXICON.sW],
                            h: scrollbarDummyElement0[LEXICON.sH]
                        };
                        return (scrollSize.w - scrollSize2.w) !== 0 || (scrollSize.h - scrollSize2.h) !== 0;
                    })(),
                    rtlScrollBehavior: (function () {
                        scrollbarDummyElement.css({ 'overflow-y': strHidden, 'overflow-x': strScroll, 'direction': 'rtl' }).scrollLeft(0);
                        var dummyContainerOffset = scrollbarDummyElement.offset();
                        var dummyContainerChildOffset = dummyContainerChild.offset();
                        //https://github.com/KingSora/OverlayScrollbars/issues/187
                        scrollbarDummyElement.scrollLeft(-999);
                        var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();
                        return {
                            //origin direction = determines if the zero scroll position is on the left or right side
                            //'i' means 'invert' (i === true means that the axis must be inverted to be correct)
                            //true = on the left side
                            //false = on the right side
                            i: dummyContainerOffset.left === dummyContainerChildOffset.left,
                            //negative = determines if the maximum scroll is positive or negative
                            //'n' means 'negate' (n === true means that the axis must be negated to be correct)
                            //true = negative
                            //false = positive
                            n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left
                        };
                    })(),
                    supportTransform: !!VENDORS._cssProperty('transform'),
                    supportTransition: !!VENDORS._cssProperty('transition'),
                    supportPassiveEvents: (function () {
                        var supportsPassive = false;
                        try {
                            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
                                get: function () {
                                    supportsPassive = true;
                                }
                            }));
                        } catch (e) { }
                        return supportsPassive;
                    })(),
                    supportResizeObserver: !!COMPATIBILITY.rO(),
                    supportMutationObserver: !!COMPATIBILITY.mO()
                });

                scrollbarDummyElement.removeAttr(LEXICON.s).remove();

                //Catch zoom event:
                (function () {
                    if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y)
                        return;

                    var abs = MATH.abs;
                    var windowWidth = COMPATIBILITY.wW();
                    var windowHeight = COMPATIBILITY.wH();
                    var windowDpr = getWindowDPR();
                    var onResize = function () {
                        if (INSTANCES().length > 0) {
                            var newW = COMPATIBILITY.wW();
                            var newH = COMPATIBILITY.wH();
                            var deltaW = newW - windowWidth;
                            var deltaH = newH - windowHeight;

                            if (deltaW === 0 && deltaH === 0)
                                return;

                            var deltaWRatio = MATH.round(newW / (windowWidth / 100.0));
                            var deltaHRatio = MATH.round(newH / (windowHeight / 100.0));
                            var absDeltaW = abs(deltaW);
                            var absDeltaH = abs(deltaH);
                            var absDeltaWRatio = abs(deltaWRatio);
                            var absDeltaHRatio = abs(deltaHRatio);
                            var newDPR = getWindowDPR();

                            var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;
                            var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);
                            var dprChanged = newDPR !== windowDpr && windowDpr > 0;
                            var isZoom = deltaIsBigger && difference && dprChanged;
                            var oldScrollbarSize = _base.nativeScrollbarSize;
                            var newScrollbarSize;

                            if (isZoom) {
                                bodyElement.append(scrollbarDummyElement);
                                newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);
                                scrollbarDummyElement.remove();
                                if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {
                                    FRAMEWORK.each(INSTANCES(), function () {
                                        if (INSTANCES(this))
                                            INSTANCES(this).update('zoom');
                                    });
                                }
                            }

                            windowWidth = newW;
                            windowHeight = newH;
                            windowDpr = newDPR;
                        }
                    };

                    function differenceIsBiggerThanOne(valOne, valTwo) {
                        var absValOne = abs(valOne);
                        var absValTwo = abs(valTwo);
                        return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);
                    }

                    function getWindowDPR() {
                        var dDPI = window.screen.deviceXDPI || 0;
                        var sDPI = window.screen.logicalXDPI || 1;
                        return window.devicePixelRatio || (dDPI / sDPI);
                    }

                    FRAMEWORK(window).on('resize', onResize);
                })();

                function calcNativeScrollbarSize(measureElement) {
                    return {
                        x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],
                        y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]
                    };
                }
            }

            /**
             * The object which manages the auto update loop for all OverlayScrollbars objects. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
             * @constructor
             */
            function OverlayScrollbarsAutoUpdateLoop(globals) {
                var _base = this;
                var _inArray = FRAMEWORK.inArray;
                var _getNow = COMPATIBILITY.now;
                var _strAutoUpdate = 'autoUpdate';
                var _strAutoUpdateInterval = _strAutoUpdate + 'Interval';
                var _strLength = LEXICON.l;
                var _loopingInstances = [];
                var _loopingInstancesIntervalCache = [];
                var _loopIsActive = false;
                var _loopIntervalDefault = 33;
                var _loopInterval = _loopIntervalDefault;
                var _loopTimeOld = _getNow();
                var _loopID;


                /**
                 * The auto update loop which will run every 50 milliseconds or less if the update interval of a instance is lower than 50 milliseconds.
                 */
                var loop = function () {
                    if (_loopingInstances[_strLength] > 0 && _loopIsActive) {
                        _loopID = COMPATIBILITY.rAF()(function () {
                            loop();
                        });
                        var timeNew = _getNow();
                        var timeDelta = timeNew - _loopTimeOld;
                        var lowestInterval;
                        var instance;
                        var instanceOptions;
                        var instanceAutoUpdateAllowed;
                        var instanceAutoUpdateInterval;
                        var now;

                        if (timeDelta > _loopInterval) {
                            _loopTimeOld = timeNew - (timeDelta % _loopInterval);
                            lowestInterval = _loopIntervalDefault;
                            for (var i = 0; i < _loopingInstances[_strLength]; i++) {
                                instance = _loopingInstances[i];
                                if (instance !== undefined) {
                                    instanceOptions = instance.options();
                                    instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];
                                    instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);
                                    now = _getNow();

                                    if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && (now - _loopingInstancesIntervalCache[i]) > instanceAutoUpdateInterval) {
                                        instance.update('auto');
                                        _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval);
                                    }

                                    lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));
                                }
                            }
                            _loopInterval = lowestInterval;
                        }
                    } else {
                        _loopInterval = _loopIntervalDefault;
                    }
                };

                /**
                 * Add OverlayScrollbars instance to the auto update loop. Only successful if the instance isn't already added.
                 * @param instance The instance which shall be updated in a loop automatically.
                 */
                _base.add = function (instance) {
                    if (_inArray(instance, _loopingInstances) === -1) {
                        _loopingInstances.push(instance);
                        _loopingInstancesIntervalCache.push(_getNow());
                        if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {
                            _loopIsActive = true;
                            globals.autoUpdateLoop = _loopIsActive;
                            loop();
                        }
                    }
                };

                /**
                 * Remove OverlayScrollbars instance from the auto update loop. Only successful if the instance was added before.
                 * @param instance The instance which shall be updated in a loop automatically.
                 */
                _base.remove = function (instance) {
                    var index = _inArray(instance, _loopingInstances);
                    if (index > -1) {
                        //remove from loopingInstances list
                        _loopingInstancesIntervalCache.splice(index, 1);
                        _loopingInstances.splice(index, 1);

                        //correct update loop behavior
                        if (_loopingInstances[_strLength] === 0 && _loopIsActive) {
                            _loopIsActive = false;
                            globals.autoUpdateLoop = _loopIsActive;
                            if (_loopID !== undefined) {
                                COMPATIBILITY.cAF()(_loopID);
                                _loopID = -1;
                            }
                        }
                    }
                };
            }

            /**
             * A object which manages the scrollbars visibility of the target element.
             * @param pluginTargetElement The element from which the scrollbars shall be hidden.
             * @param options The custom options.
             * @param extensions The custom extensions.
             * @param globals
             * @param autoUpdateLoop
             * @returns {*}
             * @constructor
             */
            function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {
                //shortcuts
                var type = COMPATIBILITY.type;
                var inArray = FRAMEWORK.inArray;
                var each = FRAMEWORK.each;

                //make correct instanceof
                var _base = new _plugin();
                var _frameworkProto = FRAMEWORK[LEXICON.p];

                //if passed element is no HTML element: skip and return
                if (!isHTMLElement(pluginTargetElement))
                    return;

                //if passed element is already initialized: set passed options if there are any and return its instance
                if (INSTANCES(pluginTargetElement)) {
                    var inst = INSTANCES(pluginTargetElement);
                    inst.options(options);
                    return inst;
                }

                //globals:
                var _nativeScrollbarIsOverlaid;
                var _overlayScrollbarDummySize;
                var _rtlScrollBehavior;
                var _autoUpdateRecommended;
                var _msieVersion;
                var _nativeScrollbarStyling;
                var _cssCalc;
                var _nativeScrollbarSize;
                var _supportTransition;
                var _supportTransform;
                var _supportPassiveEvents;
                var _supportResizeObserver;
                var _supportMutationObserver;
                var _restrictedMeasuring;

                //general readonly:
                var _initialized;
                var _destroyed;
                var _isTextarea;
                var _isBody;
                var _documentMixed;
                var _domExists;

                //general:
                var _isBorderBox;
                var _sizeAutoObserverAdded;
                var _paddingX;
                var _paddingY;
                var _borderX;
                var _borderY;
                var _marginX;
                var _marginY;
                var _isRTL;
                var _sleeping;
                var _contentBorderSize = {};
                var _scrollHorizontalInfo = {};
                var _scrollVerticalInfo = {};
                var _viewportSize = {};
                var _nativeScrollbarMinSize = {};

                //naming:
                var _strMinusHidden = '-hidden';
                var _strMarginMinus = 'margin-';
                var _strPaddingMinus = 'padding-';
                var _strBorderMinus = 'border-';
                var _strTop = 'top';
                var _strRight = 'right';
                var _strBottom = 'bottom';
                var _strLeft = 'left';
                var _strMinMinus = 'min-';
                var _strMaxMinus = 'max-';
                var _strWidth = 'width';
                var _strHeight = 'height';
                var _strFloat = 'float';
                var _strEmpty = '';
                var _strAuto = 'auto';
                var _strSync = 'sync';
                var _strScroll = 'scroll';
                var _strHundredPercent = '100%';
                var _strX = 'x';
                var _strY = 'y';
                var _strDot = '.';
                var _strSpace = ' ';
                var _strScrollbar = 'scrollbar';
                var _strMinusHorizontal = '-horizontal';
                var _strMinusVertical = '-vertical';
                var _strScrollLeft = _strScroll + 'Left';
                var _strScrollTop = _strScroll + 'Top';
                var _strMouseTouchDownEvent = 'mousedown touchstart';
                var _strMouseTouchUpEvent = 'mouseup touchend touchcancel';
                var _strMouseTouchMoveEvent = 'mousemove touchmove';
                var _strMouseEnter = 'mouseenter';
                var _strMouseLeave = 'mouseleave';
                var _strKeyDownEvent = 'keydown';
                var _strKeyUpEvent = 'keyup';
                var _strSelectStartEvent = 'selectstart';
                var _strTransitionEndEvent = 'transitionend webkitTransitionEnd oTransitionEnd';
                var _strResizeObserverProperty = '__overlayScrollbarsRO__';

                //class names:
                var _cassNamesPrefix = 'os-';
                var _classNameHTMLElement = _cassNamesPrefix + 'html';
                var _classNameHostElement = _cassNamesPrefix + 'host';
                var _classNameHostElementForeign = _classNameHostElement + '-foreign';
                var _classNameHostTextareaElement = _classNameHostElement + '-textarea';
                var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusHorizontal + _strMinusHidden;
                var _classNameHostScrollbarVerticalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusVertical + _strMinusHidden;
                var _classNameHostTransition = _classNameHostElement + '-transition';
                var _classNameHostRTL = _classNameHostElement + '-rtl';
                var _classNameHostResizeDisabled = _classNameHostElement + '-resize-disabled';
                var _classNameHostScrolling = _classNameHostElement + '-scrolling';
                var _classNameHostOverflow = _classNameHostElement + '-overflow';
                var _classNameHostOverflow = _classNameHostElement + '-overflow';
                var _classNameHostOverflowX = _classNameHostOverflow + '-x';
                var _classNameHostOverflowY = _classNameHostOverflow + '-y';
                var _classNameTextareaElement = _cassNamesPrefix + 'textarea';
                var _classNameTextareaCoverElement = _classNameTextareaElement + '-cover';
                var _classNamePaddingElement = _cassNamesPrefix + 'padding';
                var _classNameViewportElement = _cassNamesPrefix + 'viewport';
                var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + '-native-scrollbars-invisible';
                var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + '-native-scrollbars-overlaid';
                var _classNameContentElement = _cassNamesPrefix + 'content';
                var _classNameContentArrangeElement = _cassNamesPrefix + 'content-arrange';
                var _classNameContentGlueElement = _cassNamesPrefix + 'content-glue';
                var _classNameSizeAutoObserverElement = _cassNamesPrefix + 'size-auto-observer';
                var _classNameResizeObserverElement = _cassNamesPrefix + 'resize-observer';
                var _classNameResizeObserverItemElement = _cassNamesPrefix + 'resize-observer-item';
                var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + '-final';
                var _classNameTextInherit = _cassNamesPrefix + 'text-inherit';
                var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;
                var _classNameScrollbarTrack = _classNameScrollbar + '-track';
                var _classNameScrollbarTrackOff = _classNameScrollbarTrack + '-off';
                var _classNameScrollbarHandle = _classNameScrollbar + '-handle';
                var _classNameScrollbarHandleOff = _classNameScrollbarHandle + '-off';
                var _classNameScrollbarUnusable = _classNameScrollbar + '-unusable';
                var _classNameScrollbarAutoHidden = _classNameScrollbar + '-' + _strAuto + _strMinusHidden;
                var _classNameScrollbarCorner = _classNameScrollbar + '-corner';
                var _classNameScrollbarCornerResize = _classNameScrollbarCorner + '-resize';
                var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + '-both';
                var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;
                var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;
                var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;
                var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;
                var _classNameDragging = _cassNamesPrefix + 'dragging';
                var _classNameThemeNone = _cassNamesPrefix + 'theme-none';
                var _classNamesDynamicDestroy = [
                    _classNameViewportNativeScrollbarsInvisible,
                    _classNameViewportNativeScrollbarsOverlaid,
                    _classNameScrollbarTrackOff,
                    _classNameScrollbarHandleOff,
                    _classNameScrollbarUnusable,
                    _classNameScrollbarAutoHidden,
                    _classNameScrollbarCornerResize,
                    _classNameScrollbarCornerResizeB,
                    _classNameScrollbarCornerResizeH,
                    _classNameScrollbarCornerResizeV,
                    _classNameDragging].join(_strSpace);

                //callbacks:
                var _callbacksInitQeueue = [];

                //attrs viewport shall inherit from target
                var _viewportAttrsFromTarget = [LEXICON.ti];

                //options:
                var _defaultOptions;
                var _currentOptions;
                var _currentPreparedOptions;

                //extensions:
                var _extensions = {};
                var _extensionsPrivateMethods = 'added removed on contract';

                //update
                var _lastUpdateTime;
                var _swallowedUpdateHints = {};
                var _swallowedUpdateTimeout;
                var _swallowUpdateLag = 42;
                var _updateOnLoadEventName = 'load';
                var _updateOnLoadElms = [];

                //DOM elements:
                var _windowElement;
                var _documentElement;
                var _htmlElement;
                var _bodyElement;
                var _targetElement;                     //the target element of this OverlayScrollbars object
                var _hostElement;                       //the host element of this OverlayScrollbars object -> may be the same as targetElement
                var _sizeAutoObserverElement;           //observes size auto changes
                var _sizeObserverElement;               //observes size and padding changes
                var _paddingElement;                    //manages the padding
                var _viewportElement;                   //is the viewport of our scrollbar model
                var _contentElement;                    //the element which holds the content
                var _contentArrangeElement;             //is needed for correct sizing of the content element (only if native scrollbars are overlays)
                var _contentGlueElement;                //has always the size of the content element
                var _textareaCoverElement;              //only applied if target is a textarea element. Used for correct size calculation and for prevention of uncontrolled scrolling
                var _scrollbarCornerElement;
                var _scrollbarHorizontalElement;
                var _scrollbarHorizontalTrackElement;
                var _scrollbarHorizontalHandleElement;
                var _scrollbarVerticalElement;
                var _scrollbarVerticalTrackElement;
                var _scrollbarVerticalHandleElement;
                var _windowElementNative;
                var _documentElementNative;
                var _targetElementNative;
                var _hostElementNative;
                var _sizeAutoObserverElementNative;
                var _sizeObserverElementNative;
                var _paddingElementNative;
                var _viewportElementNative;
                var _contentElementNative;

                //Cache:
                var _hostSizeCache;
                var _contentScrollSizeCache;
                var _arrangeContentSizeCache;
                var _hasOverflowCache;
                var _hideOverflowCache;
                var _widthAutoCache;
                var _heightAutoCache;
                var _cssBoxSizingCache;
                var _cssPaddingCache;
                var _cssBorderCache;
                var _cssMarginCache;
                var _cssDirectionCache;
                var _cssDirectionDetectedCache;
                var _paddingAbsoluteCache;
                var _clipAlwaysCache;
                var _contentGlueSizeCache;
                var _overflowBehaviorCache;
                var _overflowAmountCache;
                var _ignoreOverlayScrollbarHidingCache;
                var _autoUpdateCache;
                var _sizeAutoCapableCache;
                var _contentElementScrollSizeChangeDetectedCache;
                var _hostElementSizeChangeDetectedCache;
                var _scrollbarsVisibilityCache;
                var _scrollbarsAutoHideCache;
                var _scrollbarsClickScrollingCache;
                var _scrollbarsDragScrollingCache;
                var _resizeCache;
                var _normalizeRTLCache;
                var _classNameCache;
                var _oldClassName;
                var _textareaAutoWrappingCache;
                var _textareaInfoCache;
                var _textareaSizeCache;
                var _textareaDynHeightCache;
                var _textareaDynWidthCache;
                var _bodyMinSizeCache;
                var _updateAutoCache = {};

                //MutationObserver:
                var _mutationObserverHost;
                var _mutationObserverContent;
                var _mutationObserverHostCallback;
                var _mutationObserverContentCallback;
                var _mutationObserversConnected;
                var _mutationObserverAttrsTextarea = ['wrap', 'cols', 'rows'];
                var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, 'open'].concat(_viewportAttrsFromTarget);

                //events:
                var _destroyEvents = [];

                //textarea:
                var _textareaHasFocus;

                //scrollbars:
                var _scrollbarsAutoHideTimeoutId;
                var _scrollbarsAutoHideMoveTimeoutId;
                var _scrollbarsAutoHideDelay;
                var _scrollbarsAutoHideNever;
                var _scrollbarsAutoHideScroll;
                var _scrollbarsAutoHideMove;
                var _scrollbarsAutoHideLeave;
                var _scrollbarsHandleHovered;
                var _scrollbarsHandlesDefineScrollPos;

                //resize
                var _resizeNone;
                var _resizeBoth;
                var _resizeHorizontal;
                var _resizeVertical;


                //==== Event Listener ====//

                /**
                 * Adds or removes a event listener from the given element.
                 * @param element The element to which the event listener shall be applied or removed.
                 * @param eventNames The name(s) of the events.
                 * @param listener The method which shall be called.
                 * @param remove True if the handler shall be removed, false or undefined if the handler shall be added.
                 * @param passiveOrOptions The options for the event.
                 */
                function setupResponsiveEventListener(element, eventNames, listener, remove, passiveOrOptions) {
                    var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);
                    var method = remove ? 'removeEventListener' : 'addEventListener';
                    var onOff = remove ? 'off' : 'on';
                    var events = collected ? false : eventNames.split(_strSpace)
                    var i = 0;

                    var passiveOrOptionsIsObj = FRAMEWORK.isPlainObject(passiveOrOptions);
                    var passive = (_supportPassiveEvents && (passiveOrOptionsIsObj ? (passiveOrOptions._passive) : passiveOrOptions)) || false;
                    var capture = passiveOrOptionsIsObj && (passiveOrOptions._capture || false);
                    var nativeParam = _supportPassiveEvents ? {
                        passive: passive,
                        capture: capture,
                    } : capture;

                    if (collected) {
                        for (; i < eventNames[LEXICON.l]; i++)
                            setupResponsiveEventListener(element, eventNames[i], listener[i], remove, passiveOrOptions);
                    }
                    else {
                        for (; i < events[LEXICON.l]; i++) {
                            if(_supportPassiveEvents) {
                                element[0][method](events[i], listener, nativeParam);
                            }
                            else {
                                element[onOff](events[i], listener);
                            }
                        }
                    }
                }


                function addDestroyEventListener(element, eventNames, listener, passive) {
                    setupResponsiveEventListener(element, eventNames, listener, false, passive);
                    _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));
                }

                //==== Resize Observer ====//

                /**
                 * Adds or removes a resize observer from the given element.
                 * @param targetElement The element to which the resize observer shall be added or removed.
                 * @param onElementResizedCallback The callback which is fired every time the resize observer registers a size change or false / undefined if the resizeObserver shall be removed.
                 */
                function setupResizeObserver(targetElement, onElementResizedCallback) {
                    if (targetElement) {
                        var resizeObserver = COMPATIBILITY.rO();
                        var strAnimationStartEvent = 'animationstart mozAnimationStart webkitAnimationStart MSAnimationStart';
                        var strChildNodes = 'childNodes';
                        var constScroll = 3333333;
                        var callback = function () {
                            targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);
                            onElementResizedCallback();
                        };
                        //add resize observer:
                        if (onElementResizedCallback) {
                            if (_supportResizeObserver) {
                                var element = targetElement.addClass('observed').append(generateDiv(_classNameResizeObserverElement)).contents()[0];
                                var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);
                                observer.observe(element);
                            }
                            else {
                                if (_msieVersion > 9 || !_autoUpdateRecommended) {
                                    targetElement.prepend(
                                        generateDiv(_classNameResizeObserverElement,
                                            generateDiv({ c: _classNameResizeObserverItemElement, dir: 'ltr' },
                                                generateDiv(_classNameResizeObserverItemElement,
                                                    generateDiv(_classNameResizeObserverItemFinalElement)
                                                ) +
                                                generateDiv(_classNameResizeObserverItemElement,
                                                    generateDiv({ c: _classNameResizeObserverItemFinalElement, style: 'width: 200%; height: 200%' })
                                                )
                                            )
                                        )
                                    );

                                    var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];
                                    var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);
                                    var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);
                                    var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);
                                    var widthCache = observerElement[LEXICON.oW];
                                    var heightCache = observerElement[LEXICON.oH];
                                    var isDirty;
                                    var rAFId;
                                    var currWidth;
                                    var currHeight;
                                    var factor = 2;
                                    var nativeScrollbarSize = globals.nativeScrollbarSize; //care don't make changes to this object!!!
                                    var reset = function () {
                                        /*
                                         var sizeResetWidth = observerElement[LEXICON.oW] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                                         var sizeResetHeight = observerElement[LEXICON.oH] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                                         var expandChildCSS = {};
                                         expandChildCSS[_strWidth] = sizeResetWidth;
                                         expandChildCSS[_strHeight] = sizeResetHeight;
                                         expandElementChild.css(expandChildCSS);


                                         expandElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                                         shrinkElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                                         */
                                        expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                                        shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                                    };
                                    var onResized = function () {
                                        rAFId = 0;
                                        if (!isDirty)
                                            return;

                                        widthCache = currWidth;
                                        heightCache = currHeight;
                                        callback();
                                    };
                                    var onScroll = function (event) {
                                        currWidth = observerElement[LEXICON.oW];
                                        currHeight = observerElement[LEXICON.oH];
                                        isDirty = currWidth != widthCache || currHeight != heightCache;

                                        if (event && isDirty && !rAFId) {
                                            COMPATIBILITY.cAF()(rAFId);
                                            rAFId = COMPATIBILITY.rAF()(onResized);
                                        }
                                        else if (!event)
                                            onResized();

                                        reset();
                                        if (event) {
                                            COMPATIBILITY.prvD(event);
                                            COMPATIBILITY.stpP(event);
                                        }
                                        return false;
                                    };
                                    var expandChildCSS = {};
                                    var observerElementCSS = {};

                                    setTopRightBottomLeft(observerElementCSS, _strEmpty, [
                                        -((nativeScrollbarSize.y + 1) * factor),
                                        nativeScrollbarSize.x * -factor,
                                        nativeScrollbarSize.y * -factor,
                                        -((nativeScrollbarSize.x + 1) * factor)
                                    ]);

                                    FRAMEWORK(observerElement).css(observerElementCSS);
                                    expandElement.on(_strScroll, onScroll);
                                    shrinkElement.on(_strScroll, onScroll);
                                    targetElement.on(strAnimationStartEvent, function () {
                                        onScroll(false);
                                    });
                                    //lets assume that the divs will never be that large and a constant value is enough
                                    expandChildCSS[_strWidth] = constScroll;
                                    expandChildCSS[_strHeight] = constScroll;
                                    expandElementChild.css(expandChildCSS);

                                    reset();
                                }
                                else {
                                    var attachEvent = _documentElementNative.attachEvent;
                                    var isIE = _msieVersion !== undefined;
                                    if (attachEvent) {
                                        targetElement.prepend(generateDiv(_classNameResizeObserverElement));
                                        findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent('onresize', callback);
                                    }
                                    else {
                                        var obj = _documentElementNative.createElement(TYPES.o);
                                        obj.setAttribute(LEXICON.ti, '-1');
                                        obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);
                                        obj.onload = function () {
                                            var wnd = this.contentDocument.defaultView;
                                            wnd.addEventListener('resize', callback);
                                            wnd.document.documentElement.style.display = 'none';
                                        };
                                        obj.type = 'text/html';
                                        if (isIE)
                                            targetElement.prepend(obj);
                                        obj.data = 'about:blank';
                                        if (!isIE)
                                            targetElement.prepend(obj);
                                        targetElement.on(strAnimationStartEvent, callback);
                                    }
                                }
                            }

                            if (targetElement[0] === _sizeObserverElementNative) {
                                var directionChanged = function () {
                                    var dir = _hostElement.css('direction');
                                    var css = {};
                                    var scrollLeftValue = 0;
                                    var result = false;
                                    if (dir !== _cssDirectionDetectedCache) {
                                        if (dir === 'ltr') {
                                            css[_strLeft] = 0;
                                            css[_strRight] = _strAuto;
                                            scrollLeftValue = constScroll;
                                        }
                                        else {
                                            css[_strLeft] = _strAuto;
                                            css[_strRight] = 0;
                                            scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;
                                        }
                                        //execution order is important for IE!!!
                                        _sizeObserverElement.children().eq(0).css(css);
                                        _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);
                                        _cssDirectionDetectedCache = dir;
                                        result = true;
                                    }
                                    return result;
                                };
                                directionChanged();
                                addDestroyEventListener(targetElement, _strScroll, function (event) {
                                    if (directionChanged())
                                        update();
                                    COMPATIBILITY.prvD(event);
                                    COMPATIBILITY.stpP(event);
                                    return false;
                                });
                            }
                        }
                        //remove resize observer:
                        else {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                var resizeObserverObj = element[_strResizeObserverProperty];
                                if (resizeObserverObj) {
                                    resizeObserverObj.disconnect();
                                    delete element[_strResizeObserverProperty];
                                }
                            }
                            else {
                                remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));
                            }
                        }
                    }
                }

                /**
                 * Freezes or unfreezes the given resize observer.
                 * @param targetElement The element to which the target resize observer is applied.
                 * @param freeze True if the resize observer shall be frozen, false otherwise.

                function freezeResizeObserver(targetElement, freeze) {
                    if (targetElement !== undefined) {
                        if(freeze) {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                element[_strResizeObserverProperty].unobserve(element);
                            }
                            else {
                                targetElement = targetElement.children(_strDot + _classNameResizeObserverElement).eq(0);
                                var w = targetElement.css(_strWidth);
                                var h = targetElement.css(_strHeight);
                                var css = {};
                                css[_strWidth] = w;
                                css[_strHeight] = h;
                                targetElement.css(css);
                            }
                        }
                        else {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                element[_strResizeObserverProperty].observe(element);
                            }
                            else {
                                var css = { };
                                css[_strHeight] = _strEmpty;
                                css[_strWidth] = _strEmpty;
                                targetElement.children(_strDot + _classNameResizeObserverElement).eq(0).css(css);
                            }
                        }
                    }
                }
                */


                //==== Mutation Observers ====//

                /**
                 * Creates MutationObservers for the host and content Element if they are supported.
                 */
                function createMutationObservers() {
                    if (_supportMutationObserver) {
                        var mutationObserverContentLag = 11;
                        var mutationObserver = COMPATIBILITY.mO();
                        var contentLastUpdate = COMPATIBILITY.now();
                        var mutationTarget;
                        var mutationAttrName;
                        var mutationIsClass;
                        var oldMutationVal;
                        var newClassVal;
                        var hostClassNameRegex;
                        var contentTimeout;
                        var now;
                        var sizeAuto;
                        var action;

                        _mutationObserverHostCallback = function (mutations) {

                            var doUpdate = false;
                            var doUpdateForce = false;
                            var mutation;
                            var mutatedAttrs = [];

                            if (_initialized && !_sleeping) {
                                each(mutations, function () {
                                    mutation = this;
                                    mutationTarget = mutation.target;
                                    mutationAttrName = mutation.attributeName;
                                    mutationIsClass = mutationAttrName === LEXICON.c;
                                    oldMutationVal = mutation.oldValue;
                                    newClassVal = mutationTarget.className;

                                    if (_domExists && mutationIsClass && !doUpdateForce) {
                                        // if old class value contains _classNameHostElementForeign and new class value doesn't
                                        if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {
                                            hostClassNameRegex = createHostClassNameRegExp(true);
                                            _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function (name) {
                                                return name.match(hostClassNameRegex);
                                            })).join(_strSpace);
                                            doUpdate = doUpdateForce = true;
                                        }
                                    }

                                    if (!doUpdate) {
                                        doUpdate = mutationIsClass
                                            ? hostClassNamesChanged(oldMutationVal, newClassVal)
                                            : mutationAttrName === LEXICON.s
                                                ? oldMutationVal !== mutationTarget[LEXICON.s].cssText
                                                : true;
                                    }

                                    mutatedAttrs.push(mutationAttrName);
                                });

                                updateViewportAttrsFromTarget(mutatedAttrs);

                                if (doUpdate)
                                    _base.update(doUpdateForce || _strAuto);
                            }
                            return doUpdate;
                        };
                        _mutationObserverContentCallback = function (mutations) {
                            var doUpdate = false;
                            var mutation;

                            if (_initialized && !_sleeping) {
                                each(mutations, function () {
                                    mutation = this;
                                    doUpdate = isUnknownMutation(mutation);
                                    return !doUpdate;
                                });

                                if (doUpdate) {
                                    now = COMPATIBILITY.now();
                                    sizeAuto = (_heightAutoCache || _widthAutoCache);
                                    action = function () {
                                        if (!_destroyed) {
                                            contentLastUpdate = now;

                                            //if cols, rows or wrap attr was changed
                                            if (_isTextarea)
                                                textareaUpdate();

                                            if (sizeAuto)
                                                update();
                                            else
                                                _base.update(_strAuto);
                                        }
                                    };
                                    clearTimeout(contentTimeout);
                                    if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto)
                                        action();
                                    else
                                        contentTimeout = setTimeout(action, mutationObserverContentLag);
                                }
                            }
                            return doUpdate;
                        }

                        _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);
                        _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);
                    }
                }

                /**
                 * Connects the MutationObservers if they are supported.
                 */
                function connectMutationObservers() {
                    if (_supportMutationObserver && !_mutationObserversConnected) {
                        _mutationObserverHost.observe(_hostElementNative, {
                            attributes: true,
                            attributeOldValue: true,
                            attributeFilter: _mutationObserverAttrsHost
                        });

                        _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {
                            attributes: true,
                            attributeOldValue: true,
                            subtree: !_isTextarea,
                            childList: !_isTextarea,
                            characterData: !_isTextarea,
                            attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost
                        });

                        _mutationObserversConnected = true;
                    }
                }

                /**
                 * Disconnects the MutationObservers if they are supported.
                 */
                function disconnectMutationObservers() {
                    if (_supportMutationObserver && _mutationObserversConnected) {
                        _mutationObserverHost.disconnect();
                        _mutationObserverContent.disconnect();

                        _mutationObserversConnected = false;
                    }
                }


                //==== Events of elements ====//

                /**
                 * This method gets called every time the host element gets resized. IMPORTANT: Padding changes are detected too!!
                 * It refreshes the hostResizedEventArgs and the hostSizeResizeCache.
                 * If there are any size changes, the update method gets called.
                 */
                function hostOnResized() {
                    if (!_sleeping) {
                        var changed;
                        var hostSize = {
                            w: _sizeObserverElementNative[LEXICON.sW],
                            h: _sizeObserverElementNative[LEXICON.sH]
                        };

                        changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);
                        _hostElementSizeChangeDetectedCache = hostSize;
                        if (changed)
                            update({ _hostSizeChanged: true });
                    }
                }

                /**
                 * The mouse enter event of the host element. This event is only needed for the autoHide feature.
                 */
                function hostOnMouseEnter() {
                    if (_scrollbarsAutoHideLeave)
                        refreshScrollbarsAutoHide(true);
                }

                /**
                 * The mouse leave event of the host element. This event is only needed for the autoHide feature.
                 */
                function hostOnMouseLeave() {
                    if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging))
                        refreshScrollbarsAutoHide(false);
                }

                /**
                 * The mouse move event of the host element. This event is only needed for the autoHide "move" feature.
                 */
                function hostOnMouseMove() {
                    if (_scrollbarsAutoHideMove) {
                        refreshScrollbarsAutoHide(true);
                        clearTimeout(_scrollbarsAutoHideMoveTimeoutId);
                        _scrollbarsAutoHideMoveTimeoutId = setTimeout(function () {
                            if (_scrollbarsAutoHideMove && !_destroyed)
                                refreshScrollbarsAutoHide(false);
                        }, 100);
                    }
                }

                /**
                 * Prevents text from deselection if attached to the document element on the mousedown event of a DOM element.
                 * @param event The select start event.
                 */
                function documentOnSelectStart(event) {
                    COMPATIBILITY.prvD(event);
                    return false;
                }

                /**
                 * A callback which will be called after a element has loaded.
                 */
                function updateOnLoadCallback(event) {
					if (!_destroyed) {
						var target = event.target;
						var elm = FRAMEWORK(event.target);
						var index = FRAMEWORK.inArray(target, _updateOnLoadElms);
						if (index > -1) {
							_updateOnLoadElms.splice(index, 1);
						}

						eachUpdateOnLoad(function (i, updateOnLoadSelector) {
							if (elm.is(updateOnLoadSelector)) {
								update({ _contentSizeChanged: true });
							}
						});
					}
                }

                /**
                * Adds or removes mouse & touch events of the host element. (for handling auto-hiding of the scrollbars)
                * @param destroy Indicates whether the events shall be added or removed.
                */
                function setupHostMouseTouchEvents(destroy) {
                    if (!destroy)
                        setupHostMouseTouchEvents(true);

                    setupResponsiveEventListener(_hostElement,
                        _strMouseTouchMoveEvent.split(_strSpace)[0],
                        hostOnMouseMove,
                        (!_scrollbarsAutoHideMove || destroy), true);
                    setupResponsiveEventListener(_hostElement,
                        [_strMouseEnter, _strMouseLeave],
                        [hostOnMouseEnter, hostOnMouseLeave],
                        (!_scrollbarsAutoHideLeave || destroy), true);

                    //if the plugin is initialized and the mouse is over the host element, make the scrollbars visible
                    if (!_initialized && !destroy)
                        _hostElement.one('mouseover', hostOnMouseEnter);
                }


                //==== Update Detection ====//

                /**
                 * Measures the min width and min height of the body element and refreshes the related cache.
                 * @returns {boolean} True if the min width or min height has changed, false otherwise.
                 */
                function bodyMinSizeChanged() {
                    var bodyMinSize = {};
                    if (_isBody && _contentArrangeElement) {
                        bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));
                        bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));
                        bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);
                        bodyMinSize.f = true; //flag for "measured at least once"
                    }
                    _bodyMinSizeCache = bodyMinSize;
                    return !!bodyMinSize.c;
                }

                /**
                 * Returns true if the class names really changed (new class without plugin host prefix)
                 * @param oldClassNames The old ClassName string or array.
                 * @param newClassNames The new ClassName string or array.
                 * @returns {boolean} True if the class names has really changed, false otherwise.
                 */
                function hostClassNamesChanged(oldClassNames, newClassNames) {
                    var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];
                    var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];
                    var diff = getArrayDifferences(oldClasses, currClasses);

                    // remove none theme from diff list to prevent update
                    var idx = inArray(_classNameThemeNone, diff);
                    var i;
                    var regex;

                    if (idx > -1)
                        diff.splice(idx, 1);

                    if (diff[LEXICON.l] > 0) {
                        regex = createHostClassNameRegExp(true, true);
                        for (i = 0; i < diff.length; i++) {
                            if (!diff[i].match(regex)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }

                /**
                 * Returns true if the given mutation is not from a from the plugin generated element. If the target element is a textarea the mutation is always unknown.
                 * @param mutation The mutation which shall be checked.
                 * @returns {boolean} True if the mutation is from a unknown element, false otherwise.
                 */
                function isUnknownMutation(mutation) {
                    var attributeName = mutation.attributeName;
                    var mutationTarget = mutation.target;
                    var mutationType = mutation.type;
                    var strClosest = 'closest';

                    if (mutationTarget === _contentElementNative)
                        return attributeName === null;
                    if (mutationType === 'attributes' && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {
                        //ignore className changes by the plugin
                        if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))
                            return hostClassNamesChanged(mutation.oldValue, mutationTarget.className);

                        //only do it of browser support it natively
                        if (typeof mutationTarget[strClosest] != TYPES.f)
                            return true;
                        if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null ||
                            mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null ||
                            mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null)
                            return false;
                    }
                    return true;
                }

                /**
                 * Returns true if the content size was changed since the last time this method was called.
                 * @returns {boolean} True if the content size was changed, false otherwise.
                 */
                function updateAutoContentSizeChanged() {
                    if (_sleeping)
                        return false;

                    var contentMeasureElement = getContentMeasureElement();
                    var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;
                    var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;
                    var css = {};
                    var float;
                    var bodyMinSizeC;
                    var changed;
                    var contentElementScrollSize;

                    if (setCSS) {
                        float = _contentElement.css(_strFloat);
                        css[_strFloat] = _isRTL ? _strRight : _strLeft;
                        css[_strWidth] = _strAuto;
                        _contentElement.css(css);
                    }
                    contentElementScrollSize = {
                        w: contentMeasureElement[LEXICON.sW] + textareaValueLength,
                        h: contentMeasureElement[LEXICON.sH] + textareaValueLength
                    };
                    if (setCSS) {
                        css[_strFloat] = float;
                        css[_strWidth] = _strHundredPercent;
                        _contentElement.css(css);
                    }

                    bodyMinSizeC = bodyMinSizeChanged();
                    changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);

                    _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;

                    return changed || bodyMinSizeC;
                }

                /**
                 * Returns true when a attribute which the MutationObserver would observe has changed.
                 * @returns {boolean} True if one of the attributes which a MutationObserver would observe has changed, false or undefined otherwise.
                 */
                function meaningfulAttrsChanged() {
                    if (_sleeping || _mutationObserversConnected)
                        return;

                    var elem;
                    var curr;
                    var cache;
                    var changedAttrs = [];
                    var checks = [
                        {
                            _elem: _hostElement,
                            _attrs: _mutationObserverAttrsHost.concat(':visible')
                        },
                        {
                            _elem: _isTextarea ? _targetElement : undefined,
                            _attrs: _mutationObserverAttrsTextarea
                        }
                    ];

                    each(checks, function (index, check) {
                        elem = check._elem;
                        if (elem) {
                            each(check._attrs, function (index, attr) {
                                curr = attr.charAt(0) === ':' ? elem.is(attr) : elem.attr(attr);
                                cache = _updateAutoCache[attr];

                                if (checkCache(curr, cache)) {
                                    changedAttrs.push(attr);
                                }

                                _updateAutoCache[attr] = curr;
                            });
                        }
                    });

                    updateViewportAttrsFromTarget(changedAttrs);

                    return changedAttrs[LEXICON.l] > 0;
                }

                /**
                 * Checks is a CSS Property of a child element is affecting the scroll size of the content.
                 * @param propertyName The CSS property name.
                 * @returns {boolean} True if the property is affecting the content scroll size, false otherwise.
                 */
                function isSizeAffectingCSSProperty(propertyName) {
                    if (!_initialized)
                        return true;
                    var flexGrow = 'flex-grow';
                    var flexShrink = 'flex-shrink';
                    var flexBasis = 'flex-basis';
                    var affectingPropsX = [
                        _strWidth,
                        _strMinMinus + _strWidth,
                        _strMaxMinus + _strWidth,
                        _strMarginMinus + _strLeft,
                        _strMarginMinus + _strRight,
                        _strLeft,
                        _strRight,
                        'font-weight',
                        'word-spacing',
                        flexGrow,
                        flexShrink,
                        flexBasis
                    ];
                    var affectingPropsXContentBox = [
                        _strPaddingMinus + _strLeft,
                        _strPaddingMinus + _strRight,
                        _strBorderMinus + _strLeft + _strWidth,
                        _strBorderMinus + _strRight + _strWidth
                    ];
                    var affectingPropsY = [
                        _strHeight,
                        _strMinMinus + _strHeight,
                        _strMaxMinus + _strHeight,
                        _strMarginMinus + _strTop,
                        _strMarginMinus + _strBottom,
                        _strTop,
                        _strBottom,
                        'line-height',
                        flexGrow,
                        flexShrink,
                        flexBasis
                    ];
                    var affectingPropsYContentBox = [
                        _strPaddingMinus + _strTop,
                        _strPaddingMinus + _strBottom,
                        _strBorderMinus + _strTop + _strWidth,
                        _strBorderMinus + _strBottom + _strWidth
                    ];
                    var _strS = 's';
                    var _strVS = 'v-s';
                    var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;
                    var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;
                    var sizeIsAffected = false;
                    var checkPropertyName = function (arr, name) {
                        for (var i = 0; i < arr[LEXICON.l]; i++) {
                            if (arr[i] === name)
                                return true;
                        }
                        return false;
                    };

                    if (checkY) {
                        sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);
                        if (!sizeIsAffected && !_isBorderBox)
                            sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);
                    }
                    if (checkX && !sizeIsAffected) {
                        sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);
                        if (!sizeIsAffected && !_isBorderBox)
                            sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);
                    }
                    return sizeIsAffected;
                }


                //==== Update ====//

                /**
                 * Sets the attribute values of the viewport element to the values from the target element.
                 * The value of a attribute is only set if the attribute is whitelisted.
                 * @attrs attrs The array of attributes which shall be set or undefined if all whitelisted shall be set.
                 */
                function updateViewportAttrsFromTarget(attrs) {
                    attrs = attrs || _viewportAttrsFromTarget;
                    each(attrs, function (index, attr) {
                        if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {
                            var targetAttr = _targetElement.attr(attr);
                            if (type(targetAttr) == TYPES.s) {
                                _viewportElement.attr(attr, targetAttr);
                            }
                            else {
                                _viewportElement.removeAttr(attr);
                            }
                        }
                    });
                }

                /**
                 * Updates the variables and size of the textarea element, and manages the scroll on new line or new character.
                 */
                function textareaUpdate() {
                    if (!_sleeping) {
                        var wrapAttrOff = !_textareaAutoWrappingCache;
                        var minWidth = _viewportSize.w;
                        var minHeight = _viewportSize.h;
                        var css = {};
                        var doMeasure = _widthAutoCache || wrapAttrOff;
                        var origWidth;
                        var width;
                        var origHeight;
                        var height;

                        //reset min size
                        css[_strMinMinus + _strWidth] = _strEmpty;
                        css[_strMinMinus + _strHeight] = _strEmpty;

                        //set width auto
                        css[_strWidth] = _strAuto;
                        _targetElement.css(css);

                        //measure width
                        origWidth = _targetElementNative[LEXICON.oW];
                        width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;
                        /*width += (_widthAutoCache ? _marginX + (!_isBorderBox ? wrapAttrOff ? 0 : _paddingX + _borderX : 0) : 0);*/

                        //set measured width
                        css[_strWidth] = _widthAutoCache ? _strAuto /*width*/ : _strHundredPercent;
                        css[_strMinMinus + _strWidth] = _strHundredPercent;

                        //set height auto
                        css[_strHeight] = _strAuto;
                        _targetElement.css(css);

                        //measure height
                        origHeight = _targetElementNative[LEXICON.oH];
                        height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1);

                        //append correct size values
                        css[_strWidth] = width;
                        css[_strHeight] = height;
                        _textareaCoverElement.css(css);

                        //apply min width / min height to prevent textarea collapsing
                        css[_strMinMinus + _strWidth] = minWidth /*+ (!_isBorderBox && _widthAutoCache ? _paddingX + _borderX : 0)*/;
                        css[_strMinMinus + _strHeight] = minHeight /*+ (!_isBorderBox && _heightAutoCache ? _paddingY + _borderY : 0)*/;
                        _targetElement.css(css);

                        return {
                            _originalWidth: origWidth,
                            _originalHeight: origHeight,
                            _dynamicWidth: width,
                            _dynamicHeight: height
                        };
                    }
                }

                /**
                 * Updates the plugin and DOM to the current options.
                 * This method should only be called if a update is 100% required.
                 * @param updateHints A objects which contains hints for this update:
                 * {
                 *   _hostSizeChanged : boolean,
                 *   _contentSizeChanged : boolean,
                 *   _force : boolean,                             == preventSwallowing
                 *   _changedOptions : { },                        == preventSwallowing && preventSleep
                *  }
                 */
                function update(updateHints) {
                    clearTimeout(_swallowedUpdateTimeout);
                    updateHints = updateHints || {};
                    _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;
                    _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;
                    _swallowedUpdateHints._force |= updateHints._force;

                    var now = COMPATIBILITY.now();
                    var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;
                    var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;
                    var force = !!_swallowedUpdateHints._force;
                    var changedOptions = updateHints._changedOptions;
                    var swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && (now - _lastUpdateTime) < _swallowUpdateLag && (!_heightAutoCache && !_widthAutoCache);
                    var displayIsHidden;

                    if (swallow)
                        _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag);

                    //abort update due to:
                    //destroyed
                    //swallowing
                    //sleeping
                    //host is hidden or has false display
                    if (_destroyed || swallow || (_sleeping && !changedOptions) || (_initialized && !force && (displayIsHidden = _hostElement.is(':hidden'))) || _hostElement.css('display') === 'inline')
                        return;

                    _lastUpdateTime = now;
                    _swallowedUpdateHints = {};

                    //if scrollbar styling is possible and native scrollbars aren't overlaid the scrollbar styling will be applied which hides the native scrollbars completely.
                    if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                        //native scrollbars are hidden, so change the values to zero
                        _nativeScrollbarSize.x = 0;
                        _nativeScrollbarSize.y = 0;
                    }
                    else {
                        //refresh native scrollbar size (in case of zoom)
                        _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                    }

                    // Scrollbar padding is needed for firefox, because firefox hides scrollbar automatically if the size of the div is too small.
                    // The calculation: [scrollbar size +3 *3]
                    // (+3 because of possible decoration e.g. borders, margins etc., but only if native scrollbar is NOT a overlaid scrollbar)
                    // (*3 because (1)increase / (2)decrease -button and (3)resize handle)
                    _nativeScrollbarMinSize = {
                        x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,
                        y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3
                    };

                    changedOptions = changedOptions || {};
                    //freezeResizeObserver(_sizeObserverElement, true);
                    //freezeResizeObserver(_sizeAutoObserverElement, true);

                    var checkCacheAutoForce = function () {
                        return checkCache.apply(this, [].slice.call(arguments).concat([force]));
                    };

                    //save current scroll offset
                    var currScroll = {
                        x: _viewportElement[_strScrollLeft](),
                        y: _viewportElement[_strScrollTop]()
                    };

                    var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;
                    var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea;

                    //scrollbars visibility:
                    var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;
                    var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache);

                    //scrollbars autoHide:
                    var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;
                    var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache);

                    //scrollbars click scrolling
                    var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;
                    var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache);

                    //scrollbars drag scrolling
                    var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;
                    var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache);

                    //className
                    var className = _currentPreparedOptions.className;
                    var classNameChanged = checkCacheAutoForce(className, _classNameCache);

                    //resize
                    var resize = _currentPreparedOptions.resize;
                    var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody; //body can't be resized since the window itself acts as resize possibility.

                    //paddingAbsolute
                    var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;
                    var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache);

                    //clipAlways
                    var clipAlways = _currentPreparedOptions.clipAlways;
                    var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache);

                    //sizeAutoCapable
                    var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody; //body can never be size auto, because it shall be always as big as the viewport.
                    var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache);

                    //showNativeScrollbars
                    var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;
                    var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache);

                    //autoUpdate
                    var autoUpdate = _currentPreparedOptions.autoUpdate;
                    var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache);

                    //overflowBehavior
                    var overflowBehavior = _currentPreparedOptions.overflowBehavior;
                    var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force);

                    //dynWidth:
                    var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;
                    var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth);

                    //dynHeight:
                    var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;
                    var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight);

                    //scrollbars visibility
                    _scrollbarsAutoHideNever = scrollbarsAutoHide === 'n';
                    _scrollbarsAutoHideScroll = scrollbarsAutoHide === 's';
                    _scrollbarsAutoHideMove = scrollbarsAutoHide === 'm';
                    _scrollbarsAutoHideLeave = scrollbarsAutoHide === 'l';

                    //scrollbars autoHideDelay
                    _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay;

                    //old className
                    _oldClassName = _classNameCache;

                    //resize
                    _resizeNone = resize === 'n';
                    _resizeBoth = resize === 'b';
                    _resizeHorizontal = resize === 'h';
                    _resizeVertical = resize === 'v';

                    //normalizeRTL
                    _normalizeRTLCache = _currentPreparedOptions.normalizeRTL;

                    //ignore overlay scrollbar hiding
                    ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);

                    //refresh options cache
                    _scrollbarsVisibilityCache = scrollbarsVisibility;
                    _scrollbarsAutoHideCache = scrollbarsAutoHide;
                    _scrollbarsClickScrollingCache = scrollbarsClickScrolling;
                    _scrollbarsDragScrollingCache = scrollbarsDragScrolling;
                    _classNameCache = className;
                    _resizeCache = resize;
                    _paddingAbsoluteCache = paddingAbsolute;
                    _clipAlwaysCache = clipAlways;
                    _sizeAutoCapableCache = sizeAutoCapable;
                    _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;
                    _autoUpdateCache = autoUpdate;
                    _overflowBehaviorCache = extendDeep({}, overflowBehavior);
                    _textareaDynWidthCache = textareaDynWidth;
                    _textareaDynHeightCache = textareaDynHeight;
                    _hasOverflowCache = _hasOverflowCache || { x: false, y: false };

                    //set correct class name to the host element
                    if (classNameChanged) {
                        removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);
                        addClass(_hostElement, className !== undefined && className !== null && className.length > 0 ? className : _classNameThemeNone);
                    }

                    //set correct auto Update
                    if (autoUpdateChanged) {
                        if (autoUpdate === true || (autoUpdate === null && _autoUpdateRecommended)) {
                            disconnectMutationObservers();
                            autoUpdateLoop.add(_base);
                        }
                        else {
                            autoUpdateLoop.remove(_base);
                            connectMutationObservers();
                        }
                    }

                    //activate or deactivate size auto capability
                    if (sizeAutoCapableChanged) {
                        if (sizeAutoCapable) {
                            if (_contentGlueElement) {
                                _contentGlueElement.show();
                            }
                            else {
                                _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));
                                _paddingElement.before(_contentGlueElement);
                            }
                            if (_sizeAutoObserverAdded) {
                                _sizeAutoObserverElement.show();
                            }
                            else {
                                _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));
                                _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];

                                _contentGlueElement.before(_sizeAutoObserverElement);
                                var oldSize = { w: -1, h: -1 };
                                setupResizeObserver(_sizeAutoObserverElement, function () {
                                    var newSize = {
                                        w: _sizeAutoObserverElementNative[LEXICON.oW],
                                        h: _sizeAutoObserverElementNative[LEXICON.oH]
                                    };
                                    if (checkCache(newSize, oldSize)) {
                                        if (_initialized && (_heightAutoCache && newSize.h > 0) || (_widthAutoCache && newSize.w > 0)) {
                                            update();
                                        }
                                        else if (_initialized && (!_heightAutoCache && newSize.h === 0) || (!_widthAutoCache && newSize.w === 0)) {
                                            update();
                                        }
                                    }
                                    oldSize = newSize;
                                });
                                _sizeAutoObserverAdded = true;
                                //fix heightAuto detector bug if height is fixed but contentHeight is 0.
                                //the probability this bug will ever happen is very very low, thats why its ok if we use calc which isn't supported in IE8.
                                if (_cssCalc !== null)
                                    _sizeAutoObserverElement.css(_strHeight, _cssCalc + '(100% + 1px)');
                            }
                        }
                        else {
                            if (_sizeAutoObserverAdded)
                                _sizeAutoObserverElement.hide();
                            if (_contentGlueElement)
                                _contentGlueElement.hide();
                        }
                    }

                    //if force, update all resizeObservers too
                    if (force) {
                        _sizeObserverElement.find('*').trigger(_strScroll);
                        if (_sizeAutoObserverAdded)
                            _sizeAutoObserverElement.find('*').trigger(_strScroll);
                    }

                    //display hidden:
                    displayIsHidden = displayIsHidden === undefined ? _hostElement.is(':hidden') : displayIsHidden;

                    //textarea AutoWrapping:
                    var textareaAutoWrapping = _isTextarea ? _targetElement.attr('wrap') !== 'off' : false;
                    var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache);

                    //detect direction:
                    var cssDirection = _hostElement.css('direction');
                    var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache);

                    //detect box-sizing:
                    var boxSizing = _hostElement.css('box-sizing');
                    var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache);

                    //detect padding:
                    var padding = getTopRightBottomLeftHost(_strPaddingMinus);

                    //width + height auto detecting var:
                    var sizeAutoObserverElementBCRect;
                    //exception occurs in IE8 sometimes (unknown exception)
                    try {
                        sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;
                    } catch (ex) {
                        return;
                    }

                    _isRTL = cssDirection === 'rtl';
                    _isBorderBox = (boxSizing === 'border-box');
                    var isRTLLeft = _isRTL ? _strLeft : _strRight;
                    var isRTLRight = _isRTL ? _strRight : _strLeft;

                    //detect width auto:
                    var widthAutoResizeDetection = false;
                    var widthAutoObserverDetection = (_sizeAutoObserverAdded && (_hostElement.css(_strFloat) !== 'none' /*|| _isTextarea */)) ? (MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0) && (!paddingAbsolute ? (_hostElementNative[LEXICON.cW] - _paddingX) > 0 : true) : false;
                    if (sizeAutoCapable && !widthAutoObserverDetection) {
                        var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];
                        var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);
                        _contentGlueElement.css(_strWidth, _strAuto);

                        var tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                        _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                        widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                        if (!widthAutoResizeDetection) {
                            _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);
                            tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                            _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                            widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                        }
                    }
                    var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;
                    var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);
                    var wasWidthAuto = !widthAuto && _widthAutoCache;

                    //detect height auto:
                    var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? (MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0) /* && (!paddingAbsolute && (_msieVersion > 9 || !_msieVersion) ? true : true) */ : false;
                    var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);
                    var wasHeightAuto = !heightAuto && _heightAutoCache;

                    //detect border:
                    //we need the border only if border box and auto size
                    var updateBorderX = (widthAuto && _isBorderBox) || !_isBorderBox;
                    var updateBorderY = (heightAuto && _isBorderBox) || !_isBorderBox;
                    var border = getTopRightBottomLeftHost(_strBorderMinus, '-' + _strWidth, !updateBorderX, !updateBorderY)

                    //detect margin:
                    var margin = getTopRightBottomLeftHost(_strMarginMinus);

                    //vars to apply correct css
                    var contentElementCSS = {};
                    var contentGlueElementCSS = {};

                    //funcs
                    var getHostSize = function () {
                        //has to be clientSize because offsetSize respect borders
                        return {
                            w: _hostElementNative[LEXICON.cW],
                            h: _hostElementNative[LEXICON.cH]
                        };
                    };
                    var getViewportSize = function () {
                        //viewport size is padding container because it never has padding, margin and a border
                        //determine zoom rounding error -> sometimes scrollWidth/Height is smaller than clientWidth/Height
                        //if this happens add the difference to the viewportSize to compensate the rounding error
                        return {
                            w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),
                            h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])
                        };
                    };

                    //set info for padding
                    var paddingAbsoluteX = _paddingX = padding.l + padding.r;
                    var paddingAbsoluteY = _paddingY = padding.t + padding.b;
                    paddingAbsoluteX *= paddingAbsolute ? 1 : 0;
                    paddingAbsoluteY *= paddingAbsolute ? 1 : 0;
                    padding.c = checkCacheAutoForce(padding, _cssPaddingCache);

                    //set info for border
                    _borderX = border.l + border.r;
                    _borderY = border.t + border.b;
                    border.c = checkCacheAutoForce(border, _cssBorderCache);

                    //set info for margin
                    _marginX = margin.l + margin.r;
                    _marginY = margin.t + margin.b;
                    margin.c = checkCacheAutoForce(margin, _cssMarginCache);

                    //refresh cache
                    _textareaAutoWrappingCache = textareaAutoWrapping;
                    _cssDirectionCache = cssDirection;
                    _cssBoxSizingCache = boxSizing;
                    _widthAutoCache = widthAuto;
                    _heightAutoCache = heightAuto;
                    _cssPaddingCache = padding;
                    _cssBorderCache = border;
                    _cssMarginCache = margin;

                    //IEFix direction changed
                    if (cssDirectionChanged && _sizeAutoObserverAdded)
                        _sizeAutoObserverElement.css(_strFloat, isRTLRight);

                    //apply padding:
                    if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {
                        var paddingElementCSS = {};
                        var textareaCSS = {};
                        var paddingValues = [padding.t, padding.r, padding.b, padding.l];

                        setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);
                        if (paddingAbsolute) {
                            setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);
                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);
                        }
                        else {
                            setTopRightBottomLeft(paddingElementCSS, _strEmpty);
                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);
                        }

                        _paddingElement.css(paddingElementCSS);
                        _targetElement.css(textareaCSS);
                    }

                    //viewport size is padding container because it never has padding, margin and a border.
                    _viewportSize = getViewportSize();

                    //update Textarea
                    var textareaSize = _isTextarea ? textareaUpdate() : false;
                    var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);
                    var textareaDynOrigSize = _isTextarea && textareaSize ? {
                        w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,
                        h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight
                    } : {};
                    _textareaSizeCache = textareaSize;

                    //fix height auto / width auto in cooperation with current padding & boxSizing behavior:
                    if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {
                        contentElementCSS[_strHeight] = _strAuto;
                    }
                    else if (heightAutoChanged || paddingAbsoluteChanged) {
                        contentElementCSS[_strHeight] = _strHundredPercent;
                    }
                    if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {
                        contentElementCSS[_strWidth] = _strAuto;
                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent; //IE Fix
                    }
                    else if (widthAutoChanged || paddingAbsoluteChanged) {
                        contentElementCSS[_strWidth] = _strHundredPercent;
                        contentElementCSS[_strFloat] = _strEmpty;
                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty; //IE Fix
                    }
                    if (widthAuto) {
                        //textareaDynOrigSize.w || _strAuto :: doesnt works because applied margin will shift width
                        contentGlueElementCSS[_strWidth] = _strAuto;

                        contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, 'max-content intrinsic') || _strAuto;
                        contentElementCSS[_strFloat] = isRTLRight;
                    }
                    else {
                        contentGlueElementCSS[_strWidth] = _strEmpty;
                    }
                    if (heightAuto) {
                        //textareaDynOrigSize.h || _contentElementNative[LEXICON.cH] :: use for anti scroll jumping
                        contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];
                    }
                    else {
                        contentGlueElementCSS[_strHeight] = _strEmpty;
                    }
                    if (sizeAutoCapable)
                        _contentGlueElement.css(contentGlueElementCSS);
                    _contentElement.css(contentElementCSS);

                    //CHECKPOINT HERE ~
                    contentElementCSS = {};
                    contentGlueElementCSS = {};

                    //if [content(host) client / scroll size, or target element direction, or content(host) max-sizes] changed, or force is true
                    if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {
                        var strOverflow = 'overflow';
                        var strOverflowX = strOverflow + '-x';
                        var strOverflowY = strOverflow + '-y';
                        var strHidden = 'hidden';
                        var strVisible = 'visible';

                        //Reset the viewport (very important for natively overlaid scrollbars and zoom change
                        //don't change the overflow prop as it is very expensive and affects performance !A LOT!
                        if (!_nativeScrollbarStyling) {
                            var viewportElementResetCSS = {};
                            var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y) : 0;
                            var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x) : 0;
                            setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);
                            _viewportElement.css(viewportElementResetCSS);
                        }

                        //measure several sizes:
                        var contentMeasureElement = getContentMeasureElement();
                        //in Firefox content element has to have overflow hidden, else element margins aren't calculated properly, this element prevents this bug, but only if scrollbars aren't overlaid
                        var contentSize = {
                            //use clientSize because natively overlaidScrollbars add borders
                            w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],
                            h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]
                        };
                        var scrollSize = {
                            w: contentMeasureElement[LEXICON.sW],
                            h: contentMeasureElement[LEXICON.sH]
                        };

                        //apply the correct viewport style and measure viewport size
                        if (!_nativeScrollbarStyling) {
                            viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;
                            viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;
                            _viewportElement.css(viewportElementResetCSS);
                        }
                        _viewportSize = getViewportSize();

                        //measure and correct several sizes
                        var hostSize = getHostSize();
                        var hostAbsoluteRectSize = {
                            w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),
                            h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)
                        };
                        var contentGlueSize = {
                            //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually
                            //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding
                            w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),
                            h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)
                        };
                        contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);
                        _contentGlueSizeCache = contentGlueSize;

                        //apply correct contentGlue size
                        if (sizeAutoCapable) {
                            //size contentGlue correctly to make sure the element has correct size if the sizing switches to auto
                            if (contentGlueSize.c || (heightAuto || widthAuto)) {
                                contentGlueElementCSS[_strWidth] = contentGlueSize.w;
                                contentGlueElementCSS[_strHeight] = contentGlueSize.h;

                                //textarea-sizes are already calculated correctly at this point
                                if (!_isTextarea) {
                                    contentSize = {
                                        //use clientSize because natively overlaidScrollbars add borders
                                        w: contentMeasureElement[LEXICON.cW],
                                        h: contentMeasureElement[LEXICON.cH]
                                    };
                                }
                            }
                            var textareaCoverCSS = {};
                            var setContentGlueElementCSSfunction = function (horizontal) {
                                var scrollbarVars = getScrollbarVars(horizontal);
                                var wh = scrollbarVars._w_h;
                                var strWH = scrollbarVars._width_height;
                                var autoSize = horizontal ? widthAuto : heightAuto;
                                var borderSize = horizontal ? _borderX : _borderY;
                                var paddingSize = horizontal ? _paddingX : _paddingY;
                                var marginSize = horizontal ? _marginX : _marginY;
                                var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize);

                                //make contentGlue size -1 if element is not auto sized, to make sure that a resize event happens when the element shrinks
                                if (!autoSize || (!autoSize && border.c))
                                    contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1;

                                //if size is auto and host is smaller than size as min size, make content glue size -1 to make sure size changes will be detected (this is only needed if padding is 0)
                                if (autoSize && (contentSize[wh] < viewportSize) && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {
                                    if (_isTextarea)
                                        textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;
                                    contentGlueElementCSS[strWH] -= 1;
                                }

                                //make sure content glue size is at least 1
                                if (contentSize[wh] > 0)
                                    contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);
                            };
                            setContentGlueElementCSSfunction(true);
                            setContentGlueElementCSSfunction(false);

                            if (_isTextarea)
                                _textareaCoverElement.css(textareaCoverCSS);
                            _contentGlueElement.css(contentGlueElementCSS);
                        }
                        if (widthAuto)
                            contentElementCSS[_strWidth] = _strHundredPercent;
                        if (widthAuto && !_isBorderBox && !_mutationObserversConnected)
                            contentElementCSS[_strFloat] = 'none';

                        //apply and reset content style
                        _contentElement.css(contentElementCSS);
                        contentElementCSS = {};

                        //measure again, but this time all correct sizes:
                        var contentScrollSize = {
                            w: contentMeasureElement[LEXICON.sW],
                            h: contentMeasureElement[LEXICON.sH],
                        };
                        contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);
                        _contentScrollSizeCache = contentScrollSize;

                        //refresh viewport size after correct measuring
                        _viewportSize = getViewportSize();

                        hostSize = getHostSize();
                        hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);
                        _hostSizeCache = hostSize;

                        var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);
                        var previousOverflowAmount = _overflowAmountCache;
                        var overflowBehaviorIsVS = {};
                        var overflowBehaviorIsVH = {};
                        var overflowBehaviorIsS = {};
                        var overflowAmount = {};
                        var hasOverflow = {};
                        var hideOverflow = {};
                        var canScroll = {};
                        var viewportRect = _paddingElementNative[LEXICON.bCR]();
                        var setOverflowVariables = function (horizontal) {
                            var scrollbarVars = getScrollbarVars(horizontal);
                            var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                            var xyI = scrollbarVarsInverted._x_y;
                            var xy = scrollbarVars._x_y;
                            var wh = scrollbarVars._w_h;
                            var widthHeight = scrollbarVars._width_height;
                            var scrollMax = _strScroll + scrollbarVars._Left_Top + 'Max';
                            var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;
                            var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;
                            overflowBehaviorIsVS[xy] = overflowBehavior[xy] === 'v-s';
                            overflowBehaviorIsVH[xy] = overflowBehavior[xy] === 'v-h';
                            overflowBehaviorIsS[xy] = overflowBehavior[xy] === 's';
                            overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);
                            overflowAmount[xy] *= (hideOverflowForceTextarea || (checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1)) ? 0 : 1;
                            hasOverflow[xy] = overflowAmount[xy] > 0;

                            //hideOverflow:
                            //x || y : true === overflow is hidden by "overflow: scroll" OR "overflow: hidden"
                            //xs || ys : true === overflow is hidden by "overflow: scroll"
                            hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? (hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI]) : hasOverflow[xy];
                            hideOverflow[xy + 's'] = hideOverflow[xy] ? (overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy]) : false;

                            canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + 's'];
                        };
                        setOverflowVariables(true);
                        setOverflowVariables(false);

                        overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);
                        _overflowAmountCache = overflowAmount;
                        hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);
                        _hasOverflowCache = hasOverflow;
                        hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);
                        _hideOverflowCache = hideOverflow;

                        //if native scrollbar is overlay at x OR y axis, prepare DOM
                        if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {
                            var borderDesign = 'px solid transparent';
                            var contentArrangeElementCSS = {};
                            var arrangeContent = {};
                            var arrangeChanged = force;
                            var setContentElementCSS;

                            if (hasOverflow.x || hasOverflow.y) {
                                arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;
                                arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;
                                arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);
                                _arrangeContentSizeCache = arrangeContent;
                            }

                            if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {
                                contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;
                                setContentElementCSS = function (horizontal) {
                                    var scrollbarVars = getScrollbarVars(horizontal);
                                    var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                                    var xy = scrollbarVars._x_y;
                                    var strDirection = horizontal ? _strBottom : isRTLLeft;
                                    var invertedAutoSize = horizontal ? heightAuto : widthAuto;

                                    if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + 's']) {
                                        contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? (ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy]) : _strEmpty;
                                        contentElementCSS[_strBorderMinus + strDirection] = ((horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding) ? (_overlayScrollbarDummySize[xy] + borderDesign) : _strEmpty;
                                    }
                                    else {
                                        arrangeContent[scrollbarVarsInverted._w_h] =
                                            contentElementCSS[_strMarginMinus + strDirection] =
                                            contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;
                                        arrangeChanged = true;
                                    }
                                };

                                if (_nativeScrollbarStyling) {
                                    addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding)
                                }
                                else {
                                    setContentElementCSS(true);
                                    setContentElementCSS(false);
                                }
                            }
                            if (ignoreOverlayScrollbarHiding) {
                                arrangeContent.w = arrangeContent.h = _strEmpty;
                                arrangeChanged = true;
                            }
                            if (arrangeChanged && !_nativeScrollbarStyling) {
                                contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;
                                contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;

                                if (!_contentArrangeElement) {
                                    _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));
                                    _viewportElement.prepend(_contentArrangeElement);
                                }
                                _contentArrangeElement.css(contentArrangeElementCSS);
                            }
                            _contentElement.css(contentElementCSS);
                        }

                        var viewportElementCSS = {};
                        var paddingElementCSS = {};
                        var setViewportCSS;
                        if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {
                            viewportElementCSS[isRTLRight] = _strEmpty;
                            setViewportCSS = function (horizontal) {
                                var scrollbarVars = getScrollbarVars(horizontal);
                                var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                                var xy = scrollbarVars._x_y;
                                var XY = scrollbarVars._X_Y;
                                var strDirection = horizontal ? _strBottom : isRTLLeft;

                                var reset = function () {
                                    viewportElementCSS[strDirection] = _strEmpty;
                                    _contentBorderSize[scrollbarVarsInverted._w_h] = 0;
                                };
                                if (hasOverflow[xy] && hideOverflow[xy + 's']) {
                                    viewportElementCSS[strOverflow + XY] = _strScroll;
                                    if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {
                                        reset();
                                    }
                                    else {
                                        viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);
                                        _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;
                                    }
                                } else {
                                    viewportElementCSS[strOverflow + XY] = _strEmpty;
                                    reset();
                                }
                            };
                            setViewportCSS(true);
                            setViewportCSS(false);

                            // if the scroll container is too small and if there is any overflow with no overlay scrollbar (and scrollbar styling isn't possible),
                            // make viewport element greater in size (Firefox hide Scrollbars fix)
                            // because firefox starts hiding scrollbars on too small elements
                            // with this behavior the overflow calculation may be incorrect or the scrollbars would appear suddenly
                            // https://bugzilla.mozilla.org/show_bug.cgi?id=292284
                            if (!_nativeScrollbarStyling
                                && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y)
                                && ((hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x) || (hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y))) {
                                viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;
                                viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;

                                viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;
                                viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;
                            }
                            else {
                                viewportElementCSS[_strPaddingMinus + _strTop] =
                                    viewportElementCSS[_strMarginMinus + _strTop] =
                                    viewportElementCSS[_strPaddingMinus + isRTLRight] =
                                    viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;
                            }
                            viewportElementCSS[_strPaddingMinus + isRTLLeft] =
                                viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty;

                            //if there is any overflow (x OR y axis) and this overflow shall be hidden, make overflow hidden, else overflow visible
                            if ((hasOverflow.x && hideOverflow.x) || (hasOverflow.y && hideOverflow.y) || hideOverflowForceTextarea) {
                                //only hide if is Textarea
                                if (_isTextarea && hideOverflowForceTextarea) {
                                    paddingElementCSS[strOverflowX] =
                                        paddingElementCSS[strOverflowY] = strHidden;
                                }
                            }
                            else {
                                if (!clipAlways || (overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y)) {
                                    //only un-hide if Textarea
                                    if (_isTextarea) {
                                        paddingElementCSS[strOverflowX] =
                                            paddingElementCSS[strOverflowY] = _strEmpty;
                                    }
                                    viewportElementCSS[strOverflowX] =
                                        viewportElementCSS[strOverflowY] = strVisible;
                                }
                            }

                            _paddingElement.css(paddingElementCSS);
                            _viewportElement.css(viewportElementCSS);
                            viewportElementCSS = {};

                            //force soft redraw in webkit because without the scrollbars will may appear because DOM wont be redrawn under special conditions
                            if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                                var elementStyle = _contentElementNative[LEXICON.s];
                                var dump;
                                elementStyle.webkitTransform = 'scale(1)';
                                elementStyle.display = 'run-in';
                                dump = _contentElementNative[LEXICON.oH];
                                elementStyle.display = _strEmpty; //|| dump; //use dump to prevent it from deletion if minify
                                elementStyle.webkitTransform = _strEmpty;
                            }
                            /*
                            //force hard redraw in webkit if native overlaid scrollbars shall appear
                            if (ignoreOverlayScrollbarHidingChanged && ignoreOverlayScrollbarHiding) {
                                _hostElement.hide();
                                var dump = _hostElementNative[LEXICON.oH];
                                _hostElement.show();
                            }
                            */
                        }

                        //change to direction RTL and width auto Bugfix in Webkit
                        //without this fix, the DOM still thinks the scrollbar is LTR and thus the content is shifted to the left
                        contentElementCSS = {};
                        if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {
                            if (_isRTL && widthAuto) {
                                var floatTmp = _contentElement.css(_strFloat);
                                var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);
                                _contentElement.css(_strFloat, floatTmp);
                                var posLeftWithFloat = MATH.round(_contentElement.position().left);

                                if (posLeftWithoutFloat !== posLeftWithFloat)
                                    contentElementCSS[_strLeft] = posLeftWithoutFloat;
                            }
                            else {
                                contentElementCSS[_strLeft] = _strEmpty;
                            }
                        }
                        _contentElement.css(contentElementCSS);

                        //handle scroll position
                        if (_isTextarea && contentSizeChanged) {
                            var textareaInfo = getTextareaInfo();
                            if (textareaInfo) {
                                var textareaRowsChanged = _textareaInfoCache === undefined ? true : textareaInfo._rows !== _textareaInfoCache._rows;
                                var cursorRow = textareaInfo._cursorRow;
                                var cursorCol = textareaInfo._cursorColumn;
                                var widestRow = textareaInfo._widestRow;
                                var lastRow = textareaInfo._rows;
                                var lastCol = textareaInfo._columns;
                                var cursorPos = textareaInfo._cursorPosition;
                                var cursorMax = textareaInfo._cursorMax;
                                var cursorIsLastPosition = (cursorPos >= cursorMax && _textareaHasFocus);
                                var textareaScrollAmount = {
                                    x: (!textareaAutoWrapping && (cursorCol === lastCol && cursorRow === widestRow)) ? _overflowAmountCache.x : -1,
                                    y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? (currScroll.y === previousOverflowAmount.y) : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1
                                };
                                currScroll.x = textareaScrollAmount.x > -1 ? (_isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x) : currScroll.x; //if inverted, scroll to 0 -> normalized this means to max scroll offset.
                                currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;
                            }
                            _textareaInfoCache = textareaInfo;
                        }
                        if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache)
                            currScroll.x += _contentBorderSize.w || 0;
                        if (widthAuto)
                            _hostElement[_strScrollLeft](0);
                        if (heightAuto)
                            _hostElement[_strScrollTop](0);
                        _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y);

                        //scrollbars management:
                        var scrollbarsVisibilityVisible = scrollbarsVisibility === 'v';
                        var scrollbarsVisibilityHidden = scrollbarsVisibility === 'h';
                        var scrollbarsVisibilityAuto = scrollbarsVisibility === 'a';
                        var refreshScrollbarsVisibility = function (showX, showY) {
                            showY = showY === undefined ? showX : showY;
                            refreshScrollbarAppearance(true, showX, canScroll.x)
                            refreshScrollbarAppearance(false, showY, canScroll.y)
                        };

                        //manage class name which indicates scrollable overflow
                        addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);
                        addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);
                        addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y);

                        //add or remove rtl class name for styling purposes except when its body, then the scrollbar stays
                        if (cssDirectionChanged && !_isBody) {
                            addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);
                        }

                        //manage the resize feature (CSS3 resize "polyfill" for this plugin)
                        if (_isBody)
                            addClass(_hostElement, _classNameHostResizeDisabled);
                        if (resizeChanged) {
                            addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);
                        }

                        //manage the scrollbars general visibility + the scrollbar interactivity (unusable class name)
                        if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {
                            if (ignoreOverlayScrollbarHiding) {
                                if (ignoreOverlayScrollbarHidingChanged) {
                                    removeClass(_hostElement, _classNameHostScrolling);
                                    if (ignoreOverlayScrollbarHiding) {
                                        refreshScrollbarsVisibility(false);
                                    }
                                }
                            }
                            else if (scrollbarsVisibilityAuto) {
                                refreshScrollbarsVisibility(canScroll.x, canScroll.y);
                            }
                            else if (scrollbarsVisibilityVisible) {
                                refreshScrollbarsVisibility(true);
                            }
                            else if (scrollbarsVisibilityHidden) {
                                refreshScrollbarsVisibility(false);
                            }
                        }

                        //manage the scrollbars auto hide feature (auto hide them after specific actions)
                        if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {
                            setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);
                            refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);
                        }

                        //manage scrollbars handle length & offset - don't remove!
                        if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {
                            refreshScrollbarHandleLength(true);
                            refreshScrollbarHandleOffset(true);
                            refreshScrollbarHandleLength(false);
                            refreshScrollbarHandleOffset(false);
                        }

                        //manage interactivity
                        if (scrollbarsClickScrollingChanged)
                            refreshScrollbarsInteractive(true, scrollbarsClickScrolling);
                        if (scrollbarsDragScrollingChanged)
                            refreshScrollbarsInteractive(false, scrollbarsDragScrolling);

                        //callbacks:
                        dispatchCallback('onDirectionChanged', {
                            isRTL: _isRTL,
                            dir: cssDirection
                        }, cssDirectionChanged);
                        dispatchCallback('onHostSizeChanged', {
                            width: _hostSizeCache.w,
                            height: _hostSizeCache.h
                        }, hostSizeChanged);
                        dispatchCallback('onContentSizeChanged', {
                            width: _contentScrollSizeCache.w,
                            height: _contentScrollSizeCache.h
                        }, contentSizeChanged);
                        dispatchCallback('onOverflowChanged', {
                            x: hasOverflow.x,
                            y: hasOverflow.y,
                            xScrollable: hideOverflow.xs,
                            yScrollable: hideOverflow.ys,
                            clipped: hideOverflow.x || hideOverflow.y
                        }, hasOverflow.c || hideOverflow.c);
                        dispatchCallback('onOverflowAmountChanged', {
                            x: overflowAmount.x,
                            y: overflowAmount.y
                        }, overflowAmount.c);
                    }

                    //fix body min size
                    if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {
                        //its possible that no min size was measured until now, because the content arrange element was just added now, in this case, measure now the min size.
                        if (!_bodyMinSizeCache.f)
                            bodyMinSizeChanged();
                        if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x)
                            _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);
                        if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y)
                            _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);
                        _bodyMinSizeCache.c = false;
                    }

                    if (_initialized && changedOptions.updateOnLoad) {
                        updateElementsOnLoad();
                    }

                    //freezeResizeObserver(_sizeObserverElement, false);
                    //freezeResizeObserver(_sizeAutoObserverElement, false);

                    dispatchCallback('onUpdated', { forced: force });
                }

                /**
                 * Updates the found elements of which the load event shall be handled.
                 */
                function updateElementsOnLoad() {
                    if (!_isTextarea) {
                        eachUpdateOnLoad(function (i, updateOnLoadSelector) {
                            _contentElement.find(updateOnLoadSelector).each(function (i, el) {
                                // if element doesn't have a updateOnLoadCallback applied
                                if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {
                                    _updateOnLoadElms.push(el);
                                    FRAMEWORK(el)
                                        .off(_updateOnLoadEventName, updateOnLoadCallback)
                                        .on(_updateOnLoadEventName, updateOnLoadCallback);
                                }
                            });
                        });
                    }
                }

                //==== Options ====//

                /**
                 * Sets new options but doesn't call the update method.
                 * @param newOptions The object which contains the new options.
                 * @returns {*} A object which contains the changed options.
                 */
                function setOptions(newOptions) {
                    var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions)

                    _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);
                    _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);

                    return validatedOpts._prepared;
                }


                //==== Structure ====//

                /**
                 * Builds or destroys the wrapper and helper DOM elements.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                /**
                 * Builds or destroys the wrapper and helper DOM elements.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupStructureDOM(destroy) {
                    var strParent = 'parent';
                    var classNameResizeObserverHost = 'os-resize-observer-host';
                    var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;
                    var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;
                    var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;
                    var adoptAttrsMap = {};
                    var applyAdoptedAttrs = function () {
                        var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;
                        each(adoptAttrsMap, function (key, value) {
                            if (type(value) == TYPES.s) {
                                if (key == LEXICON.c)
                                    applyAdoptedAttrsElm.addClass(value);
                                else
                                    applyAdoptedAttrsElm.attr(key, value);
                            }
                        });
                    };
                    var hostElementClassNames = [
                        _classNameHostElement,
                        _classNameHostElementForeign,
                        _classNameHostTextareaElement,
                        _classNameHostResizeDisabled,
                        _classNameHostRTL,
                        _classNameHostScrollbarHorizontalHidden,
                        _classNameHostScrollbarVerticalHidden,
                        _classNameHostTransition,
                        _classNameHostScrolling,
                        _classNameHostOverflow,
                        _classNameHostOverflowX,
                        _classNameHostOverflowY,
                        _classNameThemeNone,
                        _classNameTextareaElement,
                        _classNameTextInherit,
                        _classNameCache].join(_strSpace);
                    var hostElementCSS = {};

                    //get host element as first element, because that's the most upper element and required for the other elements
                    _hostElement = _hostElement || (_isTextarea ? (_domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement))) : _targetElement);
                    _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);
                    _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);
                    _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);
                    _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);
                    _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined);

                    //add this class to workaround class changing issues with UI frameworks especially Vue
                    if (_domExists)
                        addClass(_hostElement, _classNameHostElementForeign);

                    //on destroy, remove all generated class names from the host element before collecting the adopted attributes
                    //to prevent adopting generated class names
                    if (destroy)
                        removeClass(_hostElement, hostElementClassNames);

                    //collect all adopted attributes
                    adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;
                    if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {
                        each(adoptAttrs, function (i, v) {
                            if (type(v) == TYPES.s) {
                                adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);
                            }
                        });
                    }

                    if (!destroy) {
                        if (_isTextarea) {
                            if (!_currentPreparedOptions.sizeAutoCapable) {
                                hostElementCSS[_strWidth] = _targetElement.css(_strWidth);
                                hostElementCSS[_strHeight] = _targetElement.css(_strHeight);
                            }

                            if (!_domExists)
                                _targetElement.addClass(_classNameTextInherit).wrap(_hostElement);

                            //jQuery clones elements in wrap functions, so we have to select them again
                            _hostElement = _targetElement[strParent]().css(hostElementCSS);
                        }

                        if (!_domExists) {
                            //add the correct class to the target element
                            addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement);

                            //wrap the content into the generated elements to create the required DOM
                            _hostElement.wrapInner(_contentElement)
                                .wrapInner(_viewportElement)
                                .wrapInner(_paddingElement)
                                .prepend(_sizeObserverElement);

                            //jQuery clones elements in wrap functions, so we have to select them again
                            _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);
                            _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);
                            _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);

                            if (_isTextarea) {
                                _contentElement.prepend(_textareaCoverElement);
                                applyAdoptedAttrs();
                            }
                        }

                        if (_nativeScrollbarStyling)
                            addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
                        if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)
                            addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);
                        if (_isBody)
                            addClass(_htmlElement, _classNameHTMLElement);

                        _sizeObserverElementNative = _sizeObserverElement[0];
                        _hostElementNative = _hostElement[0];
                        _paddingElementNative = _paddingElement[0];
                        _viewportElementNative = _viewportElement[0];
                        _contentElementNative = _contentElement[0];

                        updateViewportAttrsFromTarget();
                    }
                    else {
                        if (_domExists && _initialized) {
                            //clear size observer
                            _sizeObserverElement.children().remove();

                            //remove the style property and classes from already generated elements
                            each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function (i, elm) {
                                if (elm) {
                                    removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                                }
                            });

                            //add classes to the host element which was removed previously to match the expected DOM
                            addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);
                        }
                        else {
                            //remove size observer
                            remove(_sizeObserverElement);

                            //unwrap the content to restore DOM
                            _contentElement.contents()
                                .unwrap()
                                .unwrap()
                                .unwrap();

                            if (_isTextarea) {
                                _targetElement.unwrap();
                                remove(_hostElement);
                                remove(_textareaCoverElement);
                                applyAdoptedAttrs();
                            }
                        }

                        if (_isTextarea)
                            _targetElement.removeAttr(LEXICON.s);

                        if (_isBody)
                            removeClass(_htmlElement, _classNameHTMLElement);
                    }
                }

                /**
                 * Adds or removes all wrapper elements interactivity events.
                 * @param destroy Indicates whether the Events shall be added or removed.
                 */
                function setupStructureEvents() {
                    var textareaKeyDownRestrictedKeyCodes = [
                        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123,    //F1 to F12
                        33, 34,                                                   //page up, page down
                        37, 38, 39, 40,                                           //left, up, right, down arrows
                        16, 17, 18, 19, 20, 144                                   //Shift, Ctrl, Alt, Pause, CapsLock, NumLock
                    ];
                    var textareaKeyDownKeyCodesList = [];
                    var textareaUpdateIntervalID;
                    var scrollStopTimeoutId;
                    var scrollStopDelay = 175;
                    var strFocus = 'focus';

                    function updateTextarea(doClearInterval) {
                        textareaUpdate();
                        _base.update(_strAuto);
                        if (doClearInterval && _autoUpdateRecommended)
                            clearInterval(textareaUpdateIntervalID);
                    }
                    function textareaOnScroll(event) {
                        _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);
                        _targetElement[_strScrollTop](0);
                        COMPATIBILITY.prvD(event);
                        COMPATIBILITY.stpP(event);
                        return false;
                    }
                    function textareaOnDrop(event) {
                        setTimeout(function () {
                            if (!_destroyed)
                                updateTextarea();
                        }, 50);
                    }
                    function textareaOnFocus() {
                        _textareaHasFocus = true;
                        addClass(_hostElement, strFocus);
                    }
                    function textareaOnFocusout() {
                        _textareaHasFocus = false;
                        textareaKeyDownKeyCodesList = [];
                        removeClass(_hostElement, strFocus);
                        updateTextarea(true);
                    }
                    function textareaOnKeyDown(event) {
                        var keyCode = event.keyCode;

                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                            if (!textareaKeyDownKeyCodesList[LEXICON.l]) {
                                updateTextarea();
                                textareaUpdateIntervalID = setInterval(updateTextarea, 1000 / 60);
                            }
                            if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0)
                                textareaKeyDownKeyCodesList.push(keyCode);
                        }
                    }
                    function textareaOnKeyUp(event) {
                        var keyCode = event.keyCode;
                        var index = inArray(keyCode, textareaKeyDownKeyCodesList);

                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                            if (index > -1)
                                textareaKeyDownKeyCodesList.splice(index, 1);
                            if (!textareaKeyDownKeyCodesList[LEXICON.l])
                                updateTextarea(true);
                        }
                    }
                    function contentOnTransitionEnd(event) {
                        if (_autoUpdateCache === true)
                            return;
                        event = event.originalEvent || event;
                        if (isSizeAffectingCSSProperty(event.propertyName))
                            _base.update(_strAuto);
                    }
                    function viewportOnScroll(event) {
                        if (!_sleeping) {
                            if (scrollStopTimeoutId !== undefined)
                                clearTimeout(scrollStopTimeoutId);
                            else {
                                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                    refreshScrollbarsAutoHide(true);

                                if (!nativeOverlayScrollbarsAreActive())
                                    addClass(_hostElement, _classNameHostScrolling);

                                dispatchCallback('onScrollStart', event);
                            }

                            //if a scrollbars handle gets dragged, the mousemove event is responsible for refreshing the handle offset
                            //because if CSS scroll-snap is used, the handle offset gets only refreshed on every snap point
                            //this looks laggy & clunky, it looks much better if the offset refreshes with the mousemove
                            if (!_scrollbarsHandlesDefineScrollPos) {
                                refreshScrollbarHandleOffset(true);
                                refreshScrollbarHandleOffset(false);
                            }
                            dispatchCallback('onScroll', event);

                            scrollStopTimeoutId = setTimeout(function () {
                                if (!_destroyed) {
                                    //OnScrollStop:
                                    clearTimeout(scrollStopTimeoutId);
                                    scrollStopTimeoutId = undefined;

                                    if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                        refreshScrollbarsAutoHide(false);

                                    if (!nativeOverlayScrollbarsAreActive())
                                        removeClass(_hostElement, _classNameHostScrolling);

                                    dispatchCallback('onScrollStop', event);
                                }
                            }, scrollStopDelay);
                        }
                    }


                    if (_isTextarea) {
                        if (_msieVersion > 9 || !_autoUpdateRecommended) {
                            addDestroyEventListener(_targetElement, 'input', updateTextarea);
                        }
                        else {
                            addDestroyEventListener(_targetElement,
                                [_strKeyDownEvent, _strKeyUpEvent],
                                [textareaOnKeyDown, textareaOnKeyUp]);
                        }

                        addDestroyEventListener(_targetElement,
                            [_strScroll, 'drop', strFocus, strFocus + 'out'],
                            [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]);
                    }
                    else {
                        addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);
                    }
                    addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);
                }


                //==== Scrollbars ====//

                /**
                 * Builds or destroys all scrollbar DOM elements (scrollbar, track, handle)
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupScrollbarsDOM(destroy) {
                    var selectOrGenerateScrollbarDOM = function (isHorizontal) {
                        var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;
                        var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);
                        var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);
                        var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);

                        if (!_domExists && !destroy) {
                            scrollbar.append(track);
                            track.append(handle);
                        }

                        return {
                            _scrollbar: scrollbar,
                            _track: track,
                            _handle: handle
                        };
                    };
                    function resetScrollbarDOM(isHorizontal) {
                        var scrollbarVars = getScrollbarVars(isHorizontal);
                        var scrollbar = scrollbarVars._scrollbar;
                        var track = scrollbarVars._track;
                        var handle = scrollbarVars._handle;

                        if (_domExists && _initialized) {
                            each([scrollbar, track, handle], function (i, elm) {
                                removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                            });
                        }
                        else {
                            remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);
                        }
                    }
                    var horizontalElements;
                    var verticalElements;

                    if (!destroy) {
                        horizontalElements = selectOrGenerateScrollbarDOM(true);
                        verticalElements = selectOrGenerateScrollbarDOM();

                        _scrollbarHorizontalElement = horizontalElements._scrollbar;
                        _scrollbarHorizontalTrackElement = horizontalElements._track;
                        _scrollbarHorizontalHandleElement = horizontalElements._handle;
                        _scrollbarVerticalElement = verticalElements._scrollbar;
                        _scrollbarVerticalTrackElement = verticalElements._track;
                        _scrollbarVerticalHandleElement = verticalElements._handle;

                        if (!_domExists) {
                            _paddingElement.after(_scrollbarVerticalElement);
                            _paddingElement.after(_scrollbarHorizontalElement);
                        }
                    }
                    else {
                        resetScrollbarDOM(true);
                        resetScrollbarDOM();
                    }
                }

                /**
                 * Initializes all scrollbar interactivity events. (track and handle dragging, clicking, scrolling)
                 * @param isHorizontal True if the target scrollbar is the horizontal scrollbar, false if the target scrollbar is the vertical scrollbar.
                 */
                function setupScrollbarEvents(isHorizontal) {
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var insideIFrame = _windowElementNative.top !== _windowElementNative;
                    var xy = scrollbarVars._x_y;
                    var XY = scrollbarVars._X_Y;
                    var scroll = _strScroll + scrollbarVars._Left_Top;
                    var strActive = 'active';
                    var strSnapHandle = 'snapHandle';
                    var strClickEvent = 'click';
                    var scrollDurationFactor = 1;
                    var increaseDecreaseScrollAmountKeyCodes = [16, 17]; //shift, ctrl
                    var trackTimeout;
                    var mouseDownScroll;
                    var mouseDownOffset;
                    var mouseDownInvertedScale;

                    function getPointerPosition(event) {
                        return _msieVersion && insideIFrame ? event['screen' + XY] : COMPATIBILITY.page(event)[xy]; //use screen coordinates in EDGE & IE because the page values are incorrect in frames.
                    }
                    function getPreparedScrollbarsOption(name) {
                        return _currentPreparedOptions.scrollbars[name];
                    }
                    function increaseTrackScrollAmount() {
                        scrollDurationFactor = 0.5;
                    }
                    function decreaseTrackScrollAmount() {
                        scrollDurationFactor = 1;
                    }
                    function stopClickEventPropagation(event) {
                        COMPATIBILITY.stpP(event);
                    }
                    function documentKeyDown(event) {
                        if (inArray(event.keyCodereaseDecreaseScrollAmountKeyCodes) > -1)
                            increaseTrackScrollAmount();
                    }
                    function documentKeyUp(event) {
                        if (inArray(event.keyCodereaseDecreaseScrollAmountKeyCodes) > -1)
                            decreaseTrackScrollAmount();
                    }
                    function onMouseTouchDownContinue(event) {
                        var originalEvent = event.originalEvent || event;
                        var isTouchEvent = originalEvent.touches !== undefined;
                        return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || (isTouchEvent && !getPreparedScrollbarsOption('touchSupport')) ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                    }
                    function documentDragMove(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var trackLength = scrollbarVarsInfo._trackLength;
                            var handleLength = scrollbarVarsInfo._handleLength;
                            var scrollRange = scrollbarVarsInfo._maxScroll;
                            var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;
                            var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);
                            var scrollDelta = (scrollRange * scrollDeltaPercent);
                            scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;
                            if (_isRTL && isHorizontal && !_rtlScrollBehavior.i)
                                scrollDelta *= -1;

                            _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));

                            if (_scrollbarsHandlesDefineScrollPos)
                                refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);

                            if (!_supportPassiveEvents)
                                COMPATIBILITY.prvD(event);
                        }
                        else
                            documentMouseTouchUp(event);
                    }
                    function documentMouseTouchUp(event) {
                        event = event || event.originalEvent;

                        setupResponsiveEventListener(_documentElement,
                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                            [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart],
                            true);
                        COMPATIBILITY.rAF()(function() {
                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, true, { _capture: true });
                        });


                        if (_scrollbarsHandlesDefineScrollPos)
                            refreshScrollbarHandleOffset(isHorizontal, true);

                        _scrollbarsHandlesDefineScrollPos = false;
                        removeClass(_bodyElement, _classNameDragging);
                        removeClass(scrollbarVars._handle, strActive);
                        removeClass(scrollbarVars._track, strActive);
                        removeClass(scrollbarVars._scrollbar, strActive);

                        mouseDownScroll = undefined;
                        mouseDownOffset = undefined;
                        mouseDownInvertedScale = 1;

                        decreaseTrackScrollAmount();

                        if (trackTimeout !== undefined) {
                            _base.scrollStop();
                            clearTimeout(trackTimeout);
                            trackTimeout = undefined;
                        }

                        if (event) {
                            var rect = _hostElementNative[LEXICON.bCR]();
                            var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;

                            //if mouse is outside host element
                            if (!mouseInsideHost)
                                hostOnMouseLeave();

                            if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                refreshScrollbarsAutoHide(false);
                        }
                    }
                    function onHandleMouseTouchDown(event) {
                        if (onMouseTouchDownContinue(event))
                            onHandleMouseTouchDownAction(event);
                    }
                    function onHandleMouseTouchDownAction(event) {
                        mouseDownScroll = _viewportElement[scroll]();
                        mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;
                        if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL)
                            mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;

                        mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                        mouseDownOffset = getPointerPosition(event);

                        _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                        addClass(_bodyElement, _classNameDragging);
                        addClass(scrollbarVars._handle, strActive);
                        addClass(scrollbarVars._scrollbar, strActive);

                        setupResponsiveEventListener(_documentElement,
                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent],
                            [documentDragMove, documentMouseTouchUp, documentOnSelectStart]);
                        COMPATIBILITY.rAF()(function() {
                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, false, { _capture: true });
                        });


                        if (_msieVersion || !_documentMixed)
                            COMPATIBILITY.prvD(event);
                        COMPATIBILITY.stpP(event);
                    }
                    function onTrackMouseTouchDown(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var handleToViewportRatio = scrollbarVars._info._handleLength / Math.round(MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]) * scrollbarVars._info._trackLength);
                            var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h] * handleToViewportRatio);
                            var scrollBaseDuration = 270 * handleToViewportRatio;
                            var scrollFirstIterationDelay = 400 * handleToViewportRatio;
                            var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];
                            var ctrlKey = event.ctrlKey;
                            var instantScroll = event.shiftKey;
                            var instantScrollTransition = instantScroll && ctrlKey;
                            var isFirstIteration = true;
                            var easing = 'linear';
                            var decreaseScroll;
                            var finishedCondition;
                            var scrollActionFinsished = function (transition) {
                                if (_scrollbarsHandlesDefineScrollPos)
                                    refreshScrollbarHandleOffset(isHorizontal, transition);
                            };
                            var scrollActionInstantFinished = function () {
                                scrollActionFinsished();
                                onHandleMouseTouchDownAction(event);
                            };
                            var scrollAction = function () {
                                if (!_destroyed) {
                                    var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;
                                    var handleOffset = scrollbarVarsInfo._handleOffset;
                                    var trackLength = scrollbarVarsInfo._trackLength;
                                    var handleLength = scrollbarVarsInfo._handleLength;
                                    var scrollRange = scrollbarVarsInfo._maxScroll;
                                    var currScroll = scrollbarVarsInfo._currentScroll;
                                    var scrollDuration = scrollBaseDuration * scrollDurationFactor;
                                    var timeoutDelay = isFirstIteration ? MATH.max(scrollFirstIterationDelay, scrollDuration) : scrollDuration;
                                    var instantScrollPosition = scrollRange * ((mouseOffset - (handleLength / 2)) / (trackLength - handleLength)); // 100% * positionPercent
                                    var rtlIsNormal = _isRTL && isHorizontal && ((!_rtlScrollBehavior.i && !_rtlScrollBehavior.n) || _normalizeRTLCache);
                                    var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;
                                    var scrollObj = {};
                                    var animationObj = {
                                        easing: easing,
                                        step: function (now) {
                                            if (_scrollbarsHandlesDefineScrollPos) {
                                                _viewportElement[scroll](now); //https://github.com/jquery/jquery/issues/4340
                                                refreshScrollbarHandleOffset(isHorizontal, now);
                                            }
                                        }
                                    };
                                    instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;
                                    instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;

                                    //_base.scrollStop();

                                    if (instantScroll) {
                                        _viewportElement[scroll](instantScrollPosition); //scroll instantly to new position
                                        if (instantScrollTransition) {
                                            //get the scroll position after instant scroll (in case CSS Snap Points are used) to get the correct snapped scroll position
                                            //and the animation stops at the correct point
                                            instantScrollPosition = _viewportElement[scroll]();
                                            //scroll back to the position before instant scrolling so animation can be performed
                                            _viewportElement[scroll](currScroll);

                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;
                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;

                                            scrollObj[xy] = instantScrollPosition;
                                            _base.scroll(scrollObj, extendDeep(animationObj, {
                                                duration: 130,
                                                complete: scrollActionInstantFinished
                                            }));
                                        }
                                        else
                                            scrollActionInstantFinished();
                                    }
                                    else {
                                        decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;
                                        finishedCondition = rtlIsNormal
                                            ? (decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset)
                                            : (decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset);

                                        if (finishedCondition) {
                                            clearTimeout(trackTimeout);
                                            _base.scrollStop();
                                            trackTimeout = undefined;
                                            scrollActionFinsished(true);
                                        }
                                        else {
                                            trackTimeout = setTimeout(scrollAction, timeoutDelay);

                                            scrollObj[xy] = (decreaseScroll ? '-=' : '+=') + scrollDistance;
                                            _base.scroll(scrollObj, extendDeep(animationObj, {
                                                duration: scrollDuration
                                            }));
                                        }
                                        isFirstIteration = false;
                                    }
                                }
                            };
                            if (ctrlKey)
                                increaseTrackScrollAmount();

                            mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                            mouseDownOffset = COMPATIBILITY.page(event)[xy];

                            _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                            addClass(_bodyElement, _classNameDragging);
                            addClass(scrollbarVars._track, strActive);
                            addClass(scrollbarVars._scrollbar, strActive);

                            setupResponsiveEventListener(_documentElement,
                                [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                                [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]);

                            scrollAction();
                            COMPATIBILITY.prvD(event);
                            COMPATIBILITY.stpP(event);
                        }
                    }
                    function onTrackMouseTouchEnter(event) {
                        //make sure both scrollbars will stay visible if one scrollbar is hovered if autoHide is "scroll" or "move".
                        _scrollbarsHandleHovered = true;
                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                            refreshScrollbarsAutoHide(true);
                    }
                    function onTrackMouseTouchLeave(event) {
                        _scrollbarsHandleHovered = false;
                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                            refreshScrollbarsAutoHide(false);
                    }
                    function onScrollbarMouseTouchDown(event) {
                        COMPATIBILITY.stpP(event);
                    }

                    addDestroyEventListener(scrollbarVars._handle,
                        _strMouseTouchDownEvent,
                        onHandleMouseTouchDown);
                    addDestroyEventListener(scrollbarVars._track,
                        [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave],
                        [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]);
                    addDestroyEventListener(scrollbarVars._scrollbar,
                        _strMouseTouchDownEvent,
                        onScrollbarMouseTouchDown);

                    if (_supportTransition) {
                        addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function (event) {
                            if (event.target !== scrollbarVars._scrollbar[0])
                                return;
                            refreshScrollbarHandleLength(isHorizontal);
                            refreshScrollbarHandleOffset(isHorizontal);
                        });
                    }
                }

                /**
                 * Shows or hides the given scrollbar and applied a class name which indicates if the scrollbar is scrollable or not.
                 * @param isHorizontal True if the horizontal scrollbar is the target, false if the vertical scrollbar is the target.
                 * @param shallBeVisible True if the scrollbar shall be shown, false if hidden.
                 * @param canScroll True if the scrollbar is scrollable, false otherwise.
                 */
                function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {
                    var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;
                    var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;

                    addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);
                    addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);
                }

                /**
                 * Autoshows / autohides both scrollbars with.
                 * @param shallBeVisible True if the scrollbars shall be autoshown (only the case if they are hidden by a autohide), false if the shall be auto hidden.
                 * @param delayfree True if the scrollbars shall be hidden without a delay, false or undefined otherwise.
                 */
                function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {
                    clearTimeout(_scrollbarsAutoHideTimeoutId);
                    if (shallBeVisible) {
                        //if(_hasOverflowCache.x && _hideOverflowCache.xs)
                        removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                        //if(_hasOverflowCache.y && _hideOverflowCache.ys)
                        removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                    }
                    else {
                        var anyActive;
                        var strActive = 'active';
                        var hide = function () {
                            if (!_scrollbarsHandleHovered && !_destroyed) {
                                anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);
                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                    addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                    addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                            }
                        };
                        if (_scrollbarsAutoHideDelay > 0 && delayfree !== true)
                            _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);
                        else
                            hide();
                    }
                }

                /**
                 * Refreshes the handle length of the given scrollbar.
                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
                 */
                function refreshScrollbarHandleLength(isHorizontal) {
                    var handleCSS = {};
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var digit = 1000000;
                    //get and apply intended handle length
                    var handleRatio = MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]);
                    handleCSS[scrollbarVars._width_height] = (MATH.floor(handleRatio * 100 * digit) / digit) + '%'; //the last * digit / digit is for flooring to the 4th digit

                    if (!nativeOverlayScrollbarsAreActive())
                        scrollbarVars._handle.css(handleCSS);

                    //measure the handle length to respect min & max length
                    scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]['offset' + scrollbarVars._Width_Height];
                    scrollbarVarsInfo._handleLengthRatio = handleRatio;
                }

                /**
                 * Refreshes the handle offset of the given scrollbar.
                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
                 * @param scrollOrTransition The scroll position of the given scrollbar axis to which the handle shall be moved or a boolean which indicates whether a transition shall be applied. If undefined or boolean if the current scroll-offset is taken. (if isHorizontal ? scrollLeft : scrollTop)
                 */
                function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {
                    var transition = type(scrollOrTransition) == TYPES.b;
                    var transitionDuration = 250;
                    var isRTLisHorizontal = _isRTL && isHorizontal;
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var strTranslateBrace = 'translate(';
                    var strTransform = VENDORS._cssProperty('transform');
                    var strTransition = VENDORS._cssProperty('transition');
                    var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();
                    var currentScroll = scrollOrTransition === undefined || transition ? nativeScroll : scrollOrTransition;

                    //measure the handle length to respect min & max length
                    var handleLength = scrollbarVarsInfo._handleLength;
                    var trackLength = scrollbarVars._track[0]['offset' + scrollbarVars._Width_Height];
                    var handleTrackDiff = trackLength - handleLength;
                    var handleCSS = {};
                    var transformOffset;
                    var translateValue;

                    //DONT use the variable '_contentScrollSizeCache[scrollbarVars._w_h]' instead of '_viewportElement[0]['scroll' + scrollbarVars._Width_Height]'
                    // because its a bit behind during the small delay when content size updates
                    //(delay = mutationObserverContentLag, if its 0 then this var could be used)
                    var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative['client' + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1); //* -1 if rtl scroll max is negative
                    var getScrollRatio = function (base) {
                        return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));
                    };
                    var getHandleOffset = function (scrollRatio) {
                        var offset = handleTrackDiff * scrollRatio;
                        offset = isNaN(offset) ? 0 : offset;
                        offset = (isRTLisHorizontal && !_rtlScrollBehavior.i) ? (trackLength - handleLength - offset) : offset;
                        offset = MATH.max(0, offset);
                        return offset;
                    };
                    var scrollRatio = getScrollRatio(nativeScroll);
                    var unsnappedScrollRatio = getScrollRatio(currentScroll);
                    var handleOffset = getHandleOffset(unsnappedScrollRatio);
                    var snappedHandleOffset = getHandleOffset(scrollRatio);

                    scrollbarVarsInfo._maxScroll = maxScroll;
                    scrollbarVarsInfo._currentScroll = nativeScroll;
                    scrollbarVarsInfo._currentScrollRatio = scrollRatio;

                    if (_supportTransform) {
                        transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset; //in px
                        //transformOffset = (transformOffset / trackLength * 100) * (trackLength / handleLength); //in %
                        translateValue = isHorizontal ? strTranslateBrace + transformOffset + 'px, 0)' : strTranslateBrace + '0, ' + transformOffset + 'px)';

                        handleCSS[strTransform] = translateValue;

                        //apply or clear up transition
                        if (_supportTransition)
                            handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ', ' + (strTransform + _strSpace + transitionDuration + 'ms') : _strEmpty;
                    }
                    else
                        handleCSS[scrollbarVars._left_top] = handleOffset;


                    //only apply css if offset has changed and overflow exists.
                    if (!nativeOverlayScrollbarsAreActive()) {
                        scrollbarVars._handle.css(handleCSS);

                        //clear up transition
                        if (_supportTransform && _supportTransition && transition) {
                            scrollbarVars._handle.one(_strTransitionEndEvent, function () {
                                if (!_destroyed)
                                    scrollbarVars._handle.css(strTransition, _strEmpty);
                            });
                        }
                    }

                    scrollbarVarsInfo._handleOffset = handleOffset;
                    scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;
                    scrollbarVarsInfo._trackLength = trackLength;
                }

                /**
                 * Refreshes the interactivity of the given scrollbar element.
                 * @param isTrack True if the track element is the target, false if the handle element is the target.
                 * @param value True for interactivity false for no interactivity.
                 */
                function refreshScrollbarsInteractive(isTrack, value) {
                    var action = value ? 'removeClass' : 'addClass';
                    var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;
                    var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;
                    var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;

                    element1[action](className);
                    element2[action](className);
                }

                /**
                 * Returns a object which is used for fast access for specific variables.
                 * @param isHorizontal True if the horizontal scrollbar vars shall be accessed, false if the vertical scrollbar vars shall be accessed.
                 * @returns {{wh: string, WH: string, lt: string, _wh: string, _lt: string, t: *, h: *, c: {}, s: *}}
                 */
                function getScrollbarVars(isHorizontal) {
                    return {
                        _width_height: isHorizontal ? _strWidth : _strHeight,
                        _Width_Height: isHorizontal ? 'Width' : 'Height',
                        _left_top: isHorizontal ? _strLeft : _strTop,
                        _Left_Top: isHorizontal ? 'Left' : 'Top',
                        _x_y: isHorizontal ? _strX : _strY,
                        _X_Y: isHorizontal ? 'X' : 'Y',
                        _w_h: isHorizontal ? 'w' : 'h',
                        _l_t: isHorizontal ? 'l' : 't',
                        _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,
                        _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,
                        _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,
                        _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo
                    };
                }


                //==== Scrollbar Corner ====//

                /**
                 * Builds or destroys the scrollbar corner DOM element.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupScrollbarCornerDOM(destroy) {
                    _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);

                    if (!destroy) {
                        if (!_domExists) {
                            _hostElement.append(_scrollbarCornerElement);
                        }
                    }
                    else {
                        if (_domExists && _initialized) {
                            removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                        }
                        else {
                            remove(_scrollbarCornerElement);
                        }
                    }
                }

                /**
                 * Initializes all scrollbar corner interactivity events.
                 */
                function setupScrollbarCornerEvents() {
                    var insideIFrame = _windowElementNative.top !== _windowElementNative;
                    var mouseDownPosition = {};
                    var mouseDownSize = {};
                    var mouseDownInvertedScale = {};
                    var reconnectMutationObserver;

                    function documentDragMove(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var pageOffset = getCoordinates(event);
                            var hostElementCSS = {};
                            if (_resizeHorizontal || _resizeBoth)
                                hostElementCSS[_strWidth] = (mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x);
                            if (_resizeVertical || _resizeBoth)
                                hostElementCSS[_strHeight] = (mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y);
                            _hostElement.css(hostElementCSS);
                            COMPATIBILITY.stpP(event);
                        }
                        else {
                            documentMouseTouchUp(event);
                        }
                    }
                    function documentMouseTouchUp(event) {
                        var eventIsTrusted = event !== undefined;

                        setupResponsiveEventListener(_documentElement,
                            [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                            [documentOnSelectStart, documentDragMove, documentMouseTouchUp],
                            true);

                        removeClass(_bodyElement, _classNameDragging);
                        if (_scrollbarCornerElement.releaseCapture)
                            _scrollbarCornerElement.releaseCapture();

                        if (eventIsTrusted) {
                            if (reconnectMutationObserver)
                                connectMutationObservers();
                            _base.update(_strAuto);
                        }
                        reconnectMutationObserver = false;
                    }
                    function onMouseTouchDownContinue(event) {
                        var originalEvent = event.originalEvent || event;
                        var isTouchEvent = originalEvent.touches !== undefined;
                        return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                    }
                    function getCoordinates(event) {
                        return _msieVersion && insideIFrame ? { x: event.screenX, y: event.screenY } : COMPATIBILITY.page(event);
                    }

                    addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function (event) {
                        if (onMouseTouchDownContinue(event) && !_resizeNone) {
                            if (_mutationObserversConnected) {
                                reconnectMutationObserver = true;
                                disconnectMutationObservers();
                            }

                            mouseDownPosition = getCoordinates(event);

                            mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);
                            mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);
                            mouseDownInvertedScale = getHostElementInvertedScale();

                            setupResponsiveEventListener(_documentElement,
                                [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                                [documentOnSelectStart, documentDragMove, documentMouseTouchUp]);

                            addClass(_bodyElement, _classNameDragging);
                            if (_scrollbarCornerElement.setCapture)
                                _scrollbarCornerElement.setCapture();

                            COMPATIBILITY.prvD(event);
                            COMPATIBILITY.stpP(event);
                        }
                    });
                }


                //==== Utils ====//

                /**
                 * Calls the callback with the given name. The Context of this callback is always _base (this).
                 * @param name The name of the target which shall be called.
                 * @param args The args with which the callback shall be called.
                 * @param dependent Boolean which decides whether the callback shall be fired, undefined is like a "true" value.
                 */
                function dispatchCallback(name, args, dependent) {
                    if (dependent === false)
                        return;
                    if (_initialized) {
                        var callback = _currentPreparedOptions.callbacks[name];
                        var extensionOnName = name;
                        var ext;

                        if (extensionOnName.substr(0, 2) === 'on')
                            extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);

                        if (type(callback) == TYPES.f)
                            callback.call(_base, args);

                        each(_extensions, function () {
                            ext = this;
                            if (type(ext.on) == TYPES.f)
                                ext.on(extensionOnName, args);
                        });
                    }
                    else if (!_destroyed)
                        _callbacksInitQeueue.push({ n: name, a: args });
                }

                /**
                 * Sets the "top, right, bottom, left" properties, with a given prefix, of the given css object.
                 * @param targetCSSObject The css object to which the values shall be applied.
                 * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
                 * @param values A array of values which shall be applied to the "top, right, bottom, left" -properties. The array order is [top, right, bottom, left].
                 * If this argument is undefined the value '' (empty string) will be applied to all properties.
                 */
                function setTopRightBottomLeft(targetCSSObject, prefix, values) {
                    prefix = prefix || _strEmpty;
                    values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];

                    targetCSSObject[prefix + _strTop] = values[0];
                    targetCSSObject[prefix + _strRight] = values[1];
                    targetCSSObject[prefix + _strBottom] = values[2];
                    targetCSSObject[prefix + _strLeft] = values[3];
                }

                /**
                 * Gets the "top, right, bottom, left" CSS properties of the CSS property with the given prefix from the host element.
                 * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
                 * @param suffix The suffix of the "top, right, bottom, left" css properties. (example: 'border-' is a valid prefix with '-width' is a valid suffix)
                 * @param zeroX True if the x axis shall be 0.
                 * @param zeroY True if the y axis shall be 0.
                 * @returns {{}} The object which contains the numbers of the read CSS properties.
                 */
                function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {
                    suffix = suffix || _strEmpty;
                    prefix = prefix || _strEmpty;
                    return {
                        t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),
                        r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),
                        b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),
                        l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))
                    };
                }

                /**
                 * Returns the computed CSS transition string from the given element.
                 * @param element The element from which the transition string shall be returned.
                 * @returns {string} The CSS transition string from the given element.
                 */
                function getCSSTransitionString(element) {
                    var transitionStr = VENDORS._cssProperty('transition');
                    var assembledValue = element.css(transitionStr);
                    if (assembledValue)
                        return assembledValue;
                    var regExpString = '\\s*(' + '([^,(]+(\\(.+?\\))?)+' + ')[\\s,]*';
                    var regExpMain = new RegExp(regExpString);
                    var regExpValidate = new RegExp('^(' + regExpString + ')+$');
                    var properties = 'property duration timing-function delay'.split(' ');
                    var result = [];
                    var strResult;
                    var valueArray;
                    var i = 0;
                    var j;
                    var splitCssStyleByComma = function (str) {
                        strResult = [];
                        if (!str.match(regExpValidate))
                            return str;
                        while (str.match(regExpMain)) {
                            strResult.push(RegExp.$1);
                            str = str.replace(regExpMain, _strEmpty);
                        }

                        return strResult;
                    };
                    for (; i < properties[LEXICON.l]; i++) {
                        valueArray = splitCssStyleByComma(element.css(transitionStr + '-' + properties[i]));
                        for (j = 0; j < valueArray[LEXICON.l]; j++)
                            result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];
                    }
                    return result.join(', ');
                }

                /**
                 * Generates a Regular Expression which matches with a string which starts with 'os-host'.
                 * @param {boolean} withCurrClassNameOption The Regular Expression also matches if the string is the current ClassName option (multiple values splitted by space possible).
                 * @param {boolean} withOldClassNameOption The Regular Expression also matches if the string is the old ClassName option (multiple values splitted by space possible).
                 */
                function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {
                    var i;
                    var split;
                    var appendix;
                    var appendClasses = function (classes, condition) {
                        appendix = '';
                        if (condition && typeof classes == TYPES.s) {
                            split = classes.split(_strSpace);
                            for (i = 0; i < split[LEXICON.l]; i++)
                                appendix += '|' + split[i] + '$';
                            // split[i].replace(/[.*+?^${}()|[\]\\]/g, '\\$&') for escaping regex characters
                        }
                        return appendix;
                    };

                    return new RegExp(
                        '(^' + _classNameHostElement + '([-_].+|)$)' +
                        appendClasses(_classNameCache, withCurrClassNameOption) +
                        appendClasses(_oldClassName, withOldClassNameOption), 'g');
                }

                /**
                 * Calculates the host-elements inverted scale. (invertedScale = 1 / scale)
                 * @returns {{x: number, y: number}} The scale of the host-element.
                 */
                function getHostElementInvertedScale() {
                    var rect = _paddingElementNative[LEXICON.bCR]();
                    return {
                        x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,
                        y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1
                    };
                }

                /**
                 * Checks whether the given object is a HTMLElement.
                 * @param o The object which shall be checked.
                 * @returns {boolean} True the given object is a HTMLElement, false otherwise.
                 */
                function isHTMLElement(o) {
                    var strOwnerDocument = 'ownerDocument';
                    var strHTMLElement = 'HTMLElement';
                    var wnd = o && o[strOwnerDocument] ? (o[strOwnerDocument].parentWindow || window) : window;
                    return (
                        typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : //DOM2
                            o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s
                    );
                }

                /**
                 * Compares 2 arrays and returns the differences between them as a array.
                 * @param a1 The first array which shall be compared.
                 * @param a2 The second array which shall be compared.
                 * @returns {Array} The differences between the two arrays.
                 */
                function getArrayDifferences(a1, a2) {
                    var a = [];
                    var diff = [];
                    var i;
                    var k;
                    for (i = 0; i < a1.length; i++)
                        a[a1[i]] = true;
                    for (i = 0; i < a2.length; i++) {
                        if (a[a2[i]])
                            delete a[a2[i]];
                        else
                            a[a2[i]] = true;
                    }
                    for (k in a)
                        diff.push(k);
                    return diff;
                }

                /**
                 * Returns Zero or the number to which the value can be parsed.
                 * @param value The value which shall be parsed.
                 * @param toFloat Indicates whether the number shall be parsed to a float.
                 */
                function parseToZeroOrNumber(value, toFloat) {
                    var num = toFloat ? parseFloat(value) : parseInt(value, 10);
                    return isNaN(num) ? 0 : num;
                }

                /**
                 * Gets several information of the textarea and returns them as a object or undefined if the browser doesn't support it.
                 * @returns {{cursorRow: Number, cursorCol, rows: Number, cols: number, wRow: number, pos: number, max : number}} or undefined if not supported.
                 */
                function getTextareaInfo() {
                    //read needed values
                    var textareaCursorPosition = _targetElementNative.selectionStart;
                    if (textareaCursorPosition === undefined)
                        return;

                    var textareaValue = _targetElement.val();
                    var textareaLength = textareaValue[LEXICON.l];
                    var textareaRowSplit = textareaValue.split('\n');
                    var textareaLastRow = textareaRowSplit[LEXICON.l];
                    var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split('\n');
                    var widestRow = 0;
                    var textareaLastCol = 0;
                    var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];
                    var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];
                    var rowCols;
                    var i;

                    //get widest Row and the last column of the textarea
                    for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {
                        rowCols = textareaRowSplit[i][LEXICON.l];
                        if (rowCols > textareaLastCol) {
                            widestRow = i + 1;
                            textareaLastCol = rowCols;
                        }
                    }

                    return {
                        _cursorRow: cursorRow, //cursorRow
                        _cursorColumn: cursorCol, //cursorCol
                        _rows: textareaLastRow, //rows
                        _columns: textareaLastCol, //cols
                        _widestRow: widestRow, //wRow
                        _cursorPosition: textareaCursorPosition, //pos
                        _cursorMax: textareaLength //max
                    };
                }

                /**
                 * Determines whether native overlay scrollbars are active.
                 * @returns {boolean} True if native overlay scrollbars are active, false otherwise.
                 */
                function nativeOverlayScrollbarsAreActive() {
                    return (_ignoreOverlayScrollbarHidingCache && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y));
                }

                /**
                 * Gets the element which is used to measure the content size.
                 * @returns {*} TextareaCover if target element is textarea else the ContentElement.
                 */
                function getContentMeasureElement() {
                    return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;
                }

                /**
                 * Generates a string which represents a HTML div with the given classes or attributes.
                 * @param classesOrAttrs The class of the div as string or a object which represents the attributes of the div. (The class attribute can also be written as "className".)
                 * @param content The content of the div as string.
                 * @returns {string} The concated string which represents a HTML div and its content.
                 */
                function generateDiv(classesOrAttrs, content) {
                    return '<div ' + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ?
                        'class="' + classesOrAttrs + '"' :
                        (function () {
                            var key;
                            var attrs = _strEmpty;
                            if (FRAMEWORK.isPlainObject(classesOrAttrs)) {
                                for (key in classesOrAttrs)
                                    attrs += (key === 'c' ? 'class' : key) + '="' + classesOrAttrs[key] + '" ';
                            }
                            return attrs;
                        })() :
                        _strEmpty) +
                        '>' +
                        (content || _strEmpty) +
                        '</div>';
                }

                /**
                 * Selects or generates a div with the given class attribute.
                 * @param className The class names (divided by spaces) of the div which shall be selected or generated.
                 * @param selectParentOrOnlyChildren The parent element from which of the element shall be selected. (if undefined or boolean its hostElement)
                 * If its a boolean it decides whether only the children of the host element shall be selected.
                 * @returns {*} The generated or selected element.
                 */
                function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {
                    var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;
                    var selectParent = onlyChildren ? _hostElement : (selectParentOrOnlyChildren || _hostElement);

                    return (_domExists && !selectParent[LEXICON.l])
                        ? null
                        : _domExists
                            ? selectParent[onlyChildren ? 'children' : 'find'](_strDot + className.replace(/\s/g, _strDot)).eq(0)
                            : FRAMEWORK(generateDiv(className))
                }

                /**
                 * Gets the value of the given property from the given object.
                 * @param obj The object from which the property value shall be got.
                 * @param path The property of which the value shall be got.
                 * @returns {*} Returns the value of the searched property or undefined of the property wasn't found.
                 */
                function getObjectPropVal(obj, path) {
                    var splits = path.split(_strDot);
                    var i = 0;
                    var val;
                    for (; i < splits.length; i++) {
                        if (!obj[LEXICON.hOP](splits[i]))
                            return;
                        val = obj[splits[i]];
                        if (i < splits.length && type(val) == TYPES.o)
                            obj = val;
                    }
                    return val;
                }

                /**
                 * Sets the value of the given property from the given object.
                 * @param obj The object from which the property value shall be set.
                 * @param path The property of which the value shall be set.
                 * @param val The value of the property which shall be set.
                 */
                function setObjectPropVal(obj, path, val) {
                    var splits = path.split(_strDot);
                    var splitsLength = splits.length;
                    var i = 0;
                    var extendObj = {};
                    var extendObjRoot = extendObj;
                    for (; i < splitsLength; i++)
                        extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;
                    FRAMEWORK.extend(obj, extendObjRoot, true);
                }

                /**
                 * Runs a action for each selector inside the updateOnLoad option.
                 * @param {Function} action The action for each updateOnLoad selector, the arguments the function takes is the index and the value (the selector).
                 */
                function eachUpdateOnLoad(action) {
                    var updateOnLoad = _currentPreparedOptions.updateOnLoad;
                    updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;

                    if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {
                        each(updateOnLoad, action);
                    }
                }


                //==== Utils Cache ====//

                /**
                 * Compares two values or objects and returns true if they aren't equal.
                 * @param current The first value or object which shall be compared.
                 * @param cache The second value or object which shall be compared.
                 * @param force If true the returned value is always true.
                 * @returns {boolean} True if both values or objects aren't equal or force is true, false otherwise.
                 */
                function checkCache(current, cache, force) {
                    if (force)
                        return force;
                    if (type(current) == TYPES.o && type(cache) == TYPES.o) {
                        for (var prop in current) {
                            if (prop !== 'c') {
                                if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {
                                    if (checkCache(current[prop], cache[prop]))
                                        return true;
                                }
                                else {
                                    return true;
                                }
                            }
                        }
                    }
                    else {
                        return current !== cache;
                    }
                    return false;
                }


                //==== Shortcuts ====//

                /**
                 * jQuery extend method shortcut with a appended "true" as first argument.
                 */
                function extendDeep() {
                    return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));
                }

                /**
                 * jQuery addClass method shortcut.
                 */
                function addClass(el, classes) {
                    return _frameworkProto.addClass.call(el, classes);
                }

                /**
                 * jQuery removeClass method shortcut.
                 */
                function removeClass(el, classes) {
                    return _frameworkProto.removeClass.call(el, classes);
                }

                /**
                 * Adds or removes the given classes dependent on the boolean value. True for add, false for remove.
                 */
                function addRemoveClass(el, classes, doAdd) {
                    return doAdd ? addClass(el, classes) : removeClass(el, classes);
                }

                /**
                 * jQuery remove method shortcut.
                 */
                function remove(el) {
                    return _frameworkProto.remove.call(el);
                }

                /**
                 * Finds the first child element with the given selector of the given element.
                 * @param el The root element from which the selector shall be valid.
                 * @param selector The selector of the searched element.
                 * @returns {*} The first element which is a child of the given element and matches the givens selector.
                 */
                function findFirst(el, selector) {
                    return _frameworkProto.find.call(el, selector).eq(0);
                }


                //==== API ====//

                /**
                 * Puts the instance to sleep. It wont respond to any changes in the DOM and won't update. Scrollbar Interactivity is also disabled as well as the resize handle.
                 * This behavior can be reset by calling the update method.
                 */
                _base.sleep = function () {
                    _sleeping = true;
                };

                /**
                 * Updates the plugin and DOM to the current options.
                 * This method should only be called if a update is 100% required.
                 * @param force True if every property shall be updated and the cache shall be ignored.
                 * !INTERNAL USAGE! : force can be a string "auto", "sync" or "zoom" too
                 * if "auto" then before a real update the content size and host element attributes gets checked, and if they changed only then the update method will be called.
                 * if "sync" then the async update process (MutationObserver or UpdateLoop) gets synchronized and a corresponding update takes place if one was needed due to pending changes.
                 * if "zoom" then a update takes place where it's assumed that content and host size changed
                 * @returns {boolean|undefined}
                 * If force is "sync" then a boolean is returned which indicates whether a update was needed due to pending changes.
                 * If force is "auto" then a boolean is returned whether a update was needed due to attribute or size changes.
                 * undefined otherwise.
                 */
                _base.update = function (force) {
                    if (_destroyed)
                        return;

                    var attrsChanged;
                    var contentSizeC;
                    var isString = type(force) == TYPES.s;
                    var doUpdateAuto;
                    var mutHost;
                    var mutContent;

                    if (isString) {
                        if (force === _strAuto) {
                            attrsChanged = meaningfulAttrsChanged();
                            contentSizeC = updateAutoContentSizeChanged();
                            doUpdateAuto = attrsChanged || contentSizeC;
                            if (doUpdateAuto) {
                                update({
                                    _contentSizeChanged: contentSizeC,
                                    _changedOptions: _initialized ? undefined : _currentPreparedOptions
                                });
                            }
                        }
                        else if (force === _strSync) {
                            if (_mutationObserversConnected) {
                                mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());
                                mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());
                            }
                            else {
                                mutHost = _base.update(_strAuto);
                            }
                        }
                        else if (force === 'zoom') {
                            update({
                                _hostSizeChanged: true,
                                _contentSizeChanged: true
                            });
                        }
                    }
                    else {
                        force = _sleeping || force;
                        _sleeping = false;
                        if (!_base.update(_strSync) || force)
                            update({ _force: force });
                    }

                    updateElementsOnLoad();

                    return doUpdateAuto || mutHost || mutContent;
                };

                /**
                 Gets or sets the current options. The update method will be called automatically if new options were set.
                 * @param newOptions If new options are given, then the new options will be set, if new options aren't given (undefined or a not a plain object) then the current options will be returned.
                 * @param value If new options is a property path string, then this value will be used to set the option to which the property path string leads.
                 * @returns {*}
                 */
                _base.options = function (newOptions, value) {
                    var option = {};
                    var changedOps;

                    //return current options if newOptions are undefined or empty
                    if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {
                        if (type(newOptions) == TYPES.s) {
                            if (arguments.length > 1) {
                                setObjectPropVal(option, newOptions, value);
                                changedOps = setOptions(option);
                            }
                            else
                                return getObjectPropVal(_currentOptions, newOptions);
                        }
                        else
                            return _currentOptions;
                    }
                    else {
                        changedOps = setOptions(newOptions);
                    }

                    if (!FRAMEWORK.isEmptyObject(changedOps)) {
                        update({ _changedOptions: changedOps });
                    }
                };

                /**
                 * Restore the DOM, disconnects all observers, remove all resize observers and put the instance to sleep.
                 */
                _base.destroy = function () {
                    if (_destroyed)
                        return;

                    //remove this instance from auto update loop
                    autoUpdateLoop.remove(_base);

                    //disconnect all mutation observers
                    disconnectMutationObservers();

                    //remove all resize observers
                    setupResizeObserver(_sizeObserverElement);
                    setupResizeObserver(_sizeAutoObserverElement);

                    //remove all extensions
                    for (var extName in _extensions)
                        _base.removeExt(extName);

                    //remove all 'destroy' events
                    while (_destroyEvents[LEXICON.l] > 0)
                        _destroyEvents.pop()();

                    //remove all events from host element
                    setupHostMouseTouchEvents(true);

                    //remove all helper / detection elements
                    if (_contentGlueElement)
                        remove(_contentGlueElement);
                    if (_contentArrangeElement)
                        remove(_contentArrangeElement);
                    if (_sizeAutoObserverAdded)
                        remove(_sizeAutoObserverElement);

                    //remove all generated DOM
                    setupScrollbarsDOM(true);
                    setupScrollbarCornerDOM(true);
                    setupStructureDOM(true);

                    //remove all generated image load events
                    for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++)
                        FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);
                    _updateOnLoadElms = undefined;

                    _destroyed = true;
                    _sleeping = true;

                    //remove this instance from the instances list
                    INSTANCES(pluginTargetElement, 0);
                    dispatchCallback('onDestroyed');

                    //remove all properties and methods
                    //for (var property in _base)
                    //    delete _base[property];
                    //_base = undefined;
                };

                /**
                 * Scrolls to a given position or element.
                 * @param coordinates
                 * 1. Can be "coordinates" which looks like:
                 *    { x : ?, y : ? } OR          Object with x and y properties
                 *    { left : ?, top : ? } OR     Object with left and top properties
                 *    { l : ?, t : ? } OR          Object with l and t properties
                 *    [ ?, ? ] OR                  Array where the first two element are the coordinates (first is x, second is y)
                 *    ?                            A single value which stays for both axis
                 *    A value can be a number, a string or a calculation.
                 *
                 *    Operators:
                 *    [NONE]  The current scroll will be overwritten by the value.
                 *    '+='    The value will be added to the current scroll offset
                 *    '-='    The value will be subtracted from the current scroll offset
                 *    '*='    The current scroll wil be multiplicated by the value.
                 *    '/='    The current scroll wil be divided by the value.
                 *
                 *    Units:
                 *    [NONE]  The value is the final scroll amount.                   final = (value * 1)
                 *    'px'    Same as none
                 *    '%'     The value is dependent on the current scroll value.     final = ((currentScrollValue / 100) * value)
                 *    'vw'    The value is multiplicated by the viewport width.       final = (value * viewportWidth)
                 *    'vh'    The value is multiplicated by the viewport height.      final = (value * viewportHeight)
                 *
                 *    example final values:
                 *    200, '200px', '50%', '1vw', '1vh', '+=200', '/=1vw', '*=2px', '-=5vh', '+=33%', '+= 50% - 2px', '-= 1vw - 50%'
                 *
                 * 2. Can be a HTML or jQuery element:
                 *    The final scroll offset is the offset (without margin) of the given HTML / jQuery element.
                 *
                 * 3. Can be a object with a HTML or jQuery element with additional settings:
                 *    {
                 *      el : [HTMLElement, jQuery element],             MUST be specified, else this object isn't valid.
                 *      scroll : [string, array, object],               Default value is 'always'.
                 *      block : [string, array, object],                Default value is 'begin'.
                 *      margin : [number, boolean, array, object]       Default value is false.
                 *    }
                 *
                 *    Possible scroll settings are:
                 *    'always'      Scrolls always.
                 *    'ifneeded'    Scrolls only if the element isnt fully in view.
                 *    'never'       Scrolls never.
                 *
                 *    Possible block settings are:
                 *    'begin'   Both axis shall be docked to the "begin" edge. - The element will be docked to the top and left edge of the viewport.
                 *    'end'     Both axis shall be docked to the "end" edge. - The element will be docked to the bottom and right edge of the viewport. (If direction is RTL to the bottom and left edge.)
                 *    'center'  Both axis shall be docked to "center". - The element will be centered in the viewport.
                 *    'nearest' The element will be docked to the nearest edge(s).
                 *
                 *    Possible margin settings are: -- The actual margin of the element wont be affect, this option affects only the final scroll offset.
                 *    [BOOLEAN]                                         If true the css margin of the element will be used, if false no margin will be used.
                 *    [NUMBER]                                          The margin will be used for all edges.
                 *
                 * @param duration The duration of the scroll animation, OR a jQuery animation configuration object.
                 * @param easing The animation easing.
                 * @param complete The animation complete callback.
                 * @returns {{
                 *   position: {x: number, y: number},
                 *   ratio: {x: number, y: number},
                 *   max: {x: number, y: number},
                 *   handleOffset: {x: number, y: number},
                 *   handleLength: {x: number, y: number},
                 *   handleLengthRatio: {x: number, y: number}, t
                 *   rackLength: {x: number, y: number},
                 *   isRTL: boolean,
                 *   isRTLNormalized: boolean
                 *  }}
                 */
                _base.scroll = function (coordinates, duration, easing, complete) {
                    if (arguments.length === 0 || coordinates === undefined) {
                        var infoX = _scrollHorizontalInfo;
                        var infoY = _scrollVerticalInfo;
                        var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;
                        var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;
                        var scrollX = infoX._currentScroll;
                        var scrollXRatio = infoX._currentScrollRatio;
                        var maxScrollX = infoX._maxScroll;
                        scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;
                        scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;
                        scrollX *= normalizeNegate ? -1 : 1;
                        maxScrollX *= normalizeNegate ? -1 : 1;

                        return {
                            position: {
                                x: scrollX,
                                y: infoY._currentScroll
                            },
                            ratio: {
                                x: scrollXRatio,
                                y: infoY._currentScrollRatio
                            },
                            max: {
                                x: maxScrollX,
                                y: infoY._maxScroll
                            },
                            handleOffset: {
                                x: infoX._handleOffset,
                                y: infoY._handleOffset
                            },
                            handleLength: {
                                x: infoX._handleLength,
                                y: infoY._handleLength
                            },
                            handleLengthRatio: {
                                x: infoX._handleLengthRatio,
                                y: infoY._handleLengthRatio
                            },
                            trackLength: {
                                x: infoX._trackLength,
                                y: infoY._trackLength
                            },
                            snappedHandleOffset: {
                                x: infoX._snappedHandleOffset,
                                y: infoY._snappedHandleOffset
                            },
                            isRTL: _isRTL,
                            isRTLNormalized: _normalizeRTLCache
                        };
                    }

                    _base.update(_strSync);

                    var normalizeRTL = _normalizeRTLCache;
                    var coordinatesXAxisProps = [_strX, _strLeft, 'l'];
                    var coordinatesYAxisProps = [_strY, _strTop, 't'];
                    var coordinatesOperators = ['+=', '-=', '*=', '/='];
                    var durationIsObject = type(duration) == TYPES.o;
                    var completeCallback = durationIsObject ? duration.complete : complete;
                    var i;
                    var finalScroll = {};
                    var specialEasing = {};
                    var doScrollLeft;
                    var doScrollTop;
                    var animationOptions;
                    var strEnd = 'end';
                    var strBegin = 'begin';
                    var strCenter = 'center';
                    var strNearest = 'nearest';
                    var strAlways = 'always';
                    var strNever = 'never';
                    var strIfNeeded = 'ifneeded';
                    var strLength = LEXICON.l;
                    var settingsAxis;
                    var settingsScroll;
                    var settingsBlock;
                    var settingsMargin;
                    var finalElement;
                    var elementObjSettingsAxisValues = [_strX, _strY, 'xy', 'yx'];
                    var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];
                    var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];
                    var coordinatesIsElementObj = coordinates[LEXICON.hOP]('el');
                    var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;
                    var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;
                    var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);
                    var updateScrollbarInfos = function () {
                        if (doScrollLeft)
                            refreshScrollbarHandleOffset(true);
                        if (doScrollTop)
                            refreshScrollbarHandleOffset(false);
                    };
                    var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined : function () {
                        updateScrollbarInfos();
                        completeCallback();
                    };
                    function checkSettingsStringValue(currValue, allowedValues) {
                        for (i = 0; i < allowedValues[strLength]; i++) {
                            if (currValue === allowedValues[i])
                                return true;
                        }
                        return false;
                    }
                    function getRawScroll(isX, coordinates) {
                        var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;
                        coordinates = type(coordinates) == TYPES.s || type(coordinates) == TYPES.n ? [coordinates, coordinates] : coordinates;

                        if (COMPATIBILITY.isA(coordinates))
                            return isX ? coordinates[0] : coordinates[1];
                        else if (type(coordinates) == TYPES.o) {
                            //decides RTL normalization "hack" with .n
                            //normalizeRTL = type(coordinates.n) == TYPES.b ? coordinates.n : normalizeRTL;
                            for (i = 0; i < coordinateProps[strLength]; i++)
                                if (coordinateProps[i] in coordinates)
                                    return coordinates[coordinateProps[i]];
                        }
                    }
                    function getFinalScroll(isX, rawScroll) {
                        var isString = type(rawScroll) == TYPES.s;
                        var operator;
                        var amount;
                        var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;
                        var currScroll = scrollInfo._currentScroll;
                        var maxScroll = scrollInfo._maxScroll;
                        var mult = ' * ';
                        var finalValue;
                        var isRTLisX = _isRTL && isX;
                        var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;
                        var strReplace = 'replace';
                        var evalFunc = eval;
                        var possibleOperator;
                        if (isString) {
                            //check operator
                            if (rawScroll[strLength] > 2) {
                                possibleOperator = rawScroll.substr(0, 2);
                                if (inArray(possibleOperator, coordinatesOperators) > -1)
                                    operator = possibleOperator;
                            }

                            //calculate units and shortcuts
                            rawScroll = operator ? rawScroll.substr(2) : rawScroll;
                            rawScroll = rawScroll
                            [strReplace](/min/g, 0) //'min' = 0%
                            [strReplace](/</g, 0)   //'<'   = 0%
                            [strReplace](/max/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)    //'max' = 100%
                            [strReplace](/>/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)      //'>'   = 100%
                            [strReplace](/px/g, _strEmpty)
                            [strReplace](/%/g, mult + (maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100.0))
                            [strReplace](/vw/g, mult + _viewportSize.w)
                            [strReplace](/vh/g, mult + _viewportSize.h);
                            amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);
                        }
                        else {
                            amount = rawScroll;
                        }

                        if (amount !== undefined && !isNaN(amount) && type(amount) == TYPES.n) {
                            var normalizeIsRTLisX = normalizeRTL && isRTLisX;
                            var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);
                            var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;
                            var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;
                            operatorCurrScroll = invert ? (maxScroll - operatorCurrScroll) : operatorCurrScroll;
                            switch (operator) {
                                case '+=':
                                    finalValue = operatorCurrScroll + amount;
                                    break;
                                case '-=':
                                    finalValue = operatorCurrScroll - amount;
                                    break;
                                case '*=':
                                    finalValue = operatorCurrScroll * amount;
                                    break;
                                case '/=':
                                    finalValue = operatorCurrScroll / amount;
                                    break;
                                default:
                                    finalValue = amount;
                                    break;
                            }
                            finalValue = invert ? maxScroll - finalValue : finalValue;
                            finalValue *= negate ? -1 : 1;
                            finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));
                        }
                        return finalValue === currScroll ? undefined : finalValue;
                    }
                    function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {
                        var resultDefault = [defaultValue, defaultValue];
                        var valueType = type(value);
                        var valueArrLength;
                        var valueArrItem;

                        //value can be [ string, or array of two strings ]
                        if (valueType == valueInternalType) {
                            value = [value, value];
                        }
                        else if (valueType == TYPES.a) {
                            valueArrLength = value[strLength];
                            if (valueArrLength > 2 || valueArrLength < 1)
                                value = resultDefault;
                            else {
                                if (valueArrLength === 1)
                                    value[1] = defaultValue;
                                for (i = 0; i < valueArrLength; i++) {
                                    valueArrItem = value[i];
                                    if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {
                                        value = resultDefault;
                                        break;
                                    }
                                }
                            }
                        }
                        else if (valueType == TYPES.o)
                            value = [value[_strX] || defaultValue, value[_strY] || defaultValue];
                        else
                            value = resultDefault;
                        return { x: value[0], y: value[1] };
                    }
                    function generateMargin(marginTopRightBottomLeftArray) {
                        var result = [];
                        var currValue;
                        var currValueType;
                        var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];
                        for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {
                            if (i === valueDirections[strLength])
                                break;
                            currValue = marginTopRightBottomLeftArray[i];
                            currValueType = type(currValue);
                            if (currValueType == TYPES.b)
                                result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);
                            else
                                result.push(currValueType == TYPES.n ? currValue : 0);
                        }
                        return result;
                    }

                    if (possibleElementIsJQuery || possibleElementIsHTMLElement) {
                        //get settings
                        var margin = coordinatesIsElementObj ? coordinates.margin : 0;
                        var axis = coordinatesIsElementObj ? coordinates.axis : 0;
                        var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;
                        var block = coordinatesIsElementObj ? coordinates.block : 0;
                        var marginDefault = [0, 0, 0, 0];
                        var marginType = type(margin);
                        var marginLength;
                        finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);

                        if (finalElement[strLength] > 0) {
                            //margin can be [ boolean, number, array of 2, array of 4, object ]
                            if (marginType == TYPES.n || marginType == TYPES.b)
                                margin = generateMargin([margin, margin, margin, margin]);
                            else if (marginType == TYPES.a) {
                                marginLength = margin[strLength];
                                if (marginLength === 2)
                                    margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);
                                else if (marginLength >= 4)
                                    margin = generateMargin(margin);
                                else
                                    margin = marginDefault;
                            }
                            else if (marginType == TYPES.o)
                                margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);
                            else
                                margin = marginDefault;

                            //block = type(block) === TYPES.b ? block ? [ strNearest, strBegin ] : [ strNearest, strEnd ] : block;
                            settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : 'xy';
                            settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);
                            settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);
                            settingsMargin = margin;

                            var viewportScroll = {
                                l: _scrollHorizontalInfo._currentScroll,
                                t: _scrollVerticalInfo._currentScroll
                            };
                            // use padding element instead of viewport element because padding element has never padding, margin or position applied.
                            var viewportOffset = _paddingElement.offset();

                            //get coordinates
                            var elementOffset = finalElement.offset();
                            var doNotScroll = {
                                x: settingsScroll.x == strNever || settingsAxis == _strY,
                                y: settingsScroll.y == strNever || settingsAxis == _strX
                            };
                            elementOffset[_strTop] -= settingsMargin[0];
                            elementOffset[_strLeft] -= settingsMargin[3];
                            var elementScrollCoordinates = {
                                x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),
                                y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)
                            };
                            if (_isRTL) {
                                if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i)
                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);
                                if (_rtlScrollBehavior.n && normalizeRTL)
                                    elementScrollCoordinates.x *= -1;
                                if (_rtlScrollBehavior.i && normalizeRTL)
                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));
                            }

                            //measuring is required
                            if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {
                                var measuringElm = finalElement[0];
                                var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {
                                    width: measuringElm[LEXICON.oW],
                                    height: measuringElm[LEXICON.oH]
                                };
                                var elementSize = {
                                    w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],
                                    h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]
                                };
                                var finalizeBlock = function (isX) {
                                    var vars = getScrollbarVars(isX);
                                    var wh = vars._w_h;
                                    var lt = vars._left_top;
                                    var xy = vars._x_y;
                                    var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);
                                    var blockIsCenter = settingsBlock[xy] == strCenter;
                                    var blockIsNearest = settingsBlock[xy] == strNearest;
                                    var scrollNever = settingsScroll[xy] == strNever;
                                    var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;
                                    var vpSize = _viewportSize[wh];
                                    var vpOffset = viewportOffset[lt];
                                    var elSize = elementSize[wh];
                                    var elOffset = elementOffset[lt];
                                    var divide = blockIsCenter ? 2 : 1;
                                    var elementCenterOffset = elOffset + (elSize / 2);
                                    var viewportCenterOffset = vpOffset + (vpSize / 2);
                                    var isInView =
                                        elSize <= vpSize
                                        && elOffset >= vpOffset
                                        && elOffset + elSize <= vpOffset + vpSize;

                                    if (scrollNever)
                                        doNotScroll[xy] = true;
                                    else if (!doNotScroll[xy]) {
                                        if (blockIsNearest || scrollIfNeeded) {
                                            doNotScroll[xy] = scrollIfNeeded ? isInView : false;
                                            blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;
                                        }
                                        elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? ((vpSize / divide) - (elSize / divide)) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;
                                    }
                                };
                                finalizeBlock(true);
                                finalizeBlock(false);
                            }

                            if (doNotScroll.y)
                                delete elementScrollCoordinates.y;
                            if (doNotScroll.x)
                                delete elementScrollCoordinates.x;

                            coordinates = elementScrollCoordinates;
                        }
                    }

                    finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));
                    finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));
                    doScrollLeft = finalScroll[_strScrollLeft] !== undefined;
                    doScrollTop = finalScroll[_strScrollTop] !== undefined;

                    if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {
                        if (durationIsObject) {
                            duration.complete = proxyCompleteCallback;
                            _viewportElement.animate(finalScroll, duration);
                        }
                        else {
                            animationOptions = {
                                duration: duration,
                                complete: proxyCompleteCallback
                            };
                            if (COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing)) {
                                specialEasing[_strScrollLeft] = easing[0] || easing.x;
                                specialEasing[_strScrollTop] = easing[1] || easing.y;
                                animationOptions.specialEasing = specialEasing;
                            }
                            else {
                                animationOptions.easing = easing;
                            }
                            _viewportElement.animate(finalScroll, animationOptions);
                        }
                    }
                    else {
                        if (doScrollLeft)
                            _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);
                        if (doScrollTop)
                            _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);
                        updateScrollbarInfos();
                    }
                };

                /**
                 * Stops all scroll animations.
                 * @returns {*} The current OverlayScrollbars instance (for chaining).
                 */
                _base.scrollStop = function (param1, param2, param3) {
                    _viewportElement.stop(param1, param2, param3);
                    return _base;
                };

                /**
                 * Returns all relevant elements.
                 * @param elementName The name of the element which shall be returned.
                 * @returns {{target: *, host: *, padding: *, viewport: *, content: *, scrollbarHorizontal: {scrollbar: *, track: *, handle: *}, scrollbarVertical: {scrollbar: *, track: *, handle: *}, scrollbarCorner: *} | *}
                 */
                _base.getElements = function (elementName) {
                    var obj = {
                        target: _targetElementNative,
                        host: _hostElementNative,
                        padding: _paddingElementNative,
                        viewport: _viewportElementNative,
                        content: _contentElementNative,
                        scrollbarHorizontal: {
                            scrollbar: _scrollbarHorizontalElement[0],
                            track: _scrollbarHorizontalTrackElement[0],
                            handle: _scrollbarHorizontalHandleElement[0]
                        },
                        scrollbarVertical: {
                            scrollbar: _scrollbarVerticalElement[0],
                            track: _scrollbarVerticalTrackElement[0],
                            handle: _scrollbarVerticalHandleElement[0]
                        },
                        scrollbarCorner: _scrollbarCornerElement[0]
                    };
                    return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;
                };

                /**
                 * Returns a object which describes the current state of this instance.
                 * @param stateProperty A specific property from the state object which shall be returned.
                 * @returns {{widthAuto, heightAuto, overflowAmount, hideOverflow, hasOverflow, contentScrollSize, viewportSize, hostSize, autoUpdate} | *}
                 */
                _base.getState = function (stateProperty) {
                    function prepare(obj) {
                        if (!FRAMEWORK.isPlainObject(obj))
                            return obj;
                        var extended = extendDeep({}, obj);
                        var changePropertyName = function (from, to) {
                            if (extended[LEXICON.hOP](from)) {
                                extended[to] = extended[from];
                                delete extended[from];
                            }
                        };
                        changePropertyName('w', _strWidth); //change w to width
                        changePropertyName('h', _strHeight); //change h to height
                        delete extended.c; //delete c (the 'changed' prop)
                        return extended;
                    };
                    var obj = {
                        destroyed: !!prepare(_destroyed),
                        sleeping: !!prepare(_sleeping),
                        autoUpdate: prepare(!_mutationObserversConnected),
                        widthAuto: prepare(_widthAutoCache),
                        heightAuto: prepare(_heightAutoCache),
                        padding: prepare(_cssPaddingCache),
                        overflowAmount: prepare(_overflowAmountCache),
                        hideOverflow: prepare(_hideOverflowCache),
                        hasOverflow: prepare(_hasOverflowCache),
                        contentScrollSize: prepare(_contentScrollSizeCache),
                        viewportSize: prepare(_viewportSize),
                        hostSize: prepare(_hostSizeCache),
                        documentMixed: prepare(_documentMixed)
                    };
                    return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;
                };

                /**
                 * Gets all or specific extension instance.
                 * @param extName The name of the extension from which the instance shall be got.
                 * @returns {{}} The instance of the extension with the given name or undefined if the instance couldn't be found.
                 */
                _base.ext = function (extName) {
                    var result;
                    var privateMethods = _extensionsPrivateMethods.split(' ');
                    var i = 0;
                    if (type(extName) == TYPES.s) {
                        if (_extensions[LEXICON.hOP](extName)) {
                            result = extendDeep({}, _extensions[extName]);
                            for (; i < privateMethods.length; i++)
                                delete result[privateMethods[i]];
                        }
                    }
                    else {
                        result = {};
                        for (i in _extensions)
                            result[i] = extendDeep({}, _base.ext(i));
                    }
                    return result;
                };

                /**
                 * Adds a extension to this instance.
                 * @param extName The name of the extension which shall be added.
                 * @param extensionOptions The extension options which shall be used.
                 * @returns {{}} The instance of the added extension or undefined if the extension couldn't be added properly.
                 */
                _base.addExt = function (extName, extensionOptions) {
                    var registeredExtensionObj = _plugin.extension(extName);
                    var instance;
                    var instanceAdded;
                    var instanceContract;
                    var contractResult;
                    var contractFulfilled = true;
                    if (registeredExtensionObj) {
                        if (!_extensions[LEXICON.hOP](extName)) {
                            instance = registeredExtensionObj.extensionFactory.call(_base,
                                extendDeep({}, registeredExtensionObj.defaultOptions),
                                FRAMEWORK,
                                COMPATIBILITY);

                            if (instance) {
                                instanceContract = instance.contract;
                                if (type(instanceContract) == TYPES.f) {
                                    contractResult = instanceContract(window);
                                    contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;
                                }
                                if (contractFulfilled) {
                                    _extensions[extName] = instance;
                                    instanceAdded = instance.added;
                                    if (type(instanceAdded) == TYPES.f)
                                        instanceAdded(extensionOptions);

                                    return _base.ext(extName);
                                }
                            }
                        }
                        else
                            return _base.ext(extName);
                    }
                    else
                        console.warn("A extension with the name \"" + extName + "\" isn't registered.");
                };

                /**
                 * Removes a extension from this instance.
                 * @param extName The name of the extension which shall be removed.
                 * @returns {boolean} True if the extension was removed, false otherwise e.g. if the extension wasn't added before.
                 */
                _base.removeExt = function (extName) {
                    var instance = _extensions[extName];
                    var instanceRemoved;
                    if (instance) {
                        delete _extensions[extName];

                        instanceRemoved = instance.removed;
                        if (type(instanceRemoved) == TYPES.f)
                            instanceRemoved();

                        return true;
                    }
                    return false;
                };

                /**
                 * Constructs the plugin.
                 * @param targetElement The element to which the plugin shall be applied.
                 * @param options The initial options of the plugin.
                 * @param extensions The extension(s) which shall be added right after the initialization.
                 * @returns {boolean} True if the plugin was successfully initialized, false otherwise.
                 */
                function construct(targetElement, options, extensions) {
                    _defaultOptions = globals.defaultOptions;
                    _nativeScrollbarStyling = globals.nativeScrollbarStyling;
                    _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                    _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);
                    _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);
                    _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior);

                    //parse & set options but don't update
                    setOptions(extendDeep({}, _defaultOptions, options));

                    _cssCalc = globals.cssCalc;
                    _msieVersion = globals.msie;
                    _autoUpdateRecommended = globals.autoUpdateRecommended;
                    _supportTransition = globals.supportTransition;
                    _supportTransform = globals.supportTransform;
                    _supportPassiveEvents = globals.supportPassiveEvents;
                    _supportResizeObserver = globals.supportResizeObserver;
                    _supportMutationObserver = globals.supportMutationObserver;
                    _restrictedMeasuring = globals.restrictedMeasuring;
                    _documentElement = FRAMEWORK(targetElement.ownerDocument);
                    _documentElementNative = _documentElement[0];
                    _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);
                    _windowElementNative = _windowElement[0];
                    _htmlElement = findFirst(_documentElement, 'html');
                    _bodyElement = findFirst(_htmlElement, 'body');
                    _targetElement = FRAMEWORK(targetElement);
                    _targetElementNative = _targetElement[0];
                    _isTextarea = _targetElement.is('textarea');
                    _isBody = _targetElement.is('body');
                    _documentMixed = _documentElementNative !== document;

                    /* On a div Element The if checks only whether:
                     * - the targetElement has the class "os-host"
                     * - the targetElement has a a child with the class "os-padding"
                     *
                     * If that's the case, its assumed the DOM has already the following structure:
                     * (The ".os-host" element is the targetElement)
                     *
                     *  <div class="os-host">
                     *      <div class="os-resize-observer-host"></div>
                     *      <div class="os-padding">
                     *          <div class="os-viewport">
                     *              <div class="os-content"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-horizontal ">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-vertical">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar-corner"></div>
                     *  </div>
                     *
                     * =====================================================================================
                     *
                     * On a Textarea Element The if checks only whether:
                     * - the targetElement has the class "os-textarea"
                     * - the targetElement is inside a element with the class "os-content"
                     *
                     * If that's the case, its assumed the DOM has already the following structure:
                     * (The ".os-textarea" (textarea) element is the targetElement)
                     *
                     *  <div class="os-host-textarea">
                     *      <div class="os-resize-observer-host"></div>
                     *      <div class="os-padding os-text-inherit">
                     *          <div class="os-viewport os-text-inherit">
                     *              <div class="os-content os-text-inherit">
                     *                  <div class="os-textarea-cover"></div>
                     *                  <textarea class="os-textarea os-text-inherit"></textarea>
                     *              </div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-horizontal ">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-vertical">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar-corner"></div>
                     *  </div>
                     */
                    _domExists = _isTextarea
                        ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement)
                        : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];

                    var initBodyScroll;
                    var bodyMouseTouchDownListener;

                    //check if the plugin hasn't to be initialized
                    if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {
                        _initialized = true; // workaround so the onInitializationWithdrawn callback below is fired
                        dispatchCallback('onInitializationWithdrawn');
                        if (_domExists) {
                            setupStructureDOM(true);
                            setupScrollbarsDOM(true);
                            setupScrollbarCornerDOM(true);
                        }

                        _initialized = false;
                        _destroyed = true;
                        _sleeping = true;

                        return _base;
                    }

                    if (_isBody) {
                        initBodyScroll = {};
                        initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());
                        initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());

                        bodyMouseTouchDownListener = function () {
                            _viewportElement.removeAttr(LEXICON.ti);
                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);
                        }
                    }

                    //build OverlayScrollbars DOM
                    setupStructureDOM();
                    setupScrollbarsDOM();
                    setupScrollbarCornerDOM();

                    //create OverlayScrollbars events
                    setupStructureEvents();
                    setupScrollbarEvents(true);
                    setupScrollbarEvents(false);
                    setupScrollbarCornerEvents();

                    //create mutation observers
                    createMutationObservers();

                    //build resize observer for the host element
                    setupResizeObserver(_sizeObserverElement, hostOnResized);

                    if (_isBody) {
                        //apply the body scroll to handle it right in the update method
                        _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t);

                        //set the focus on the viewport element so you dont have to click on the page to use keyboard keys (up / down / space) for scrolling
                        if (document.activeElement == targetElement && _viewportElementNative.focus) {
                            //set a tabindex to make the viewportElement focusable
                            _viewportElement.attr(LEXICON.ti, '-1');
                            _viewportElementNative.focus();

                            /* the tabindex has to be removed due to;
                             * If you set the tabindex attribute on an <div>, then its child content cannot be scrolled with the arrow keys unless you set tabindex on the content, too
                             * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
                             */
                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);
                        }
                    }

                    //update for the first time & initialize cache
                    _base.update(_strAuto);

                    //the plugin is initialized now!
                    _initialized = true;
                    dispatchCallback('onInitialized');

                    //call all callbacks which would fire before the initialized was complete
                    each(_callbacksInitQeueue, function (index, value) { dispatchCallback(value.n, value.a); });
                    _callbacksInitQeueue = [];

                    //add extensions
                    if (type(extensions) == TYPES.s)
                        extensions = [extensions];
                    if (COMPATIBILITY.isA(extensions))
                        each(extensions, function (index, value) { _base.addExt(value); });
                    else if (FRAMEWORK.isPlainObject(extensions))
                        each(extensions, function (key, value) { _base.addExt(key, value); });

                    //add the transition class for transitions AFTER the first update & AFTER the applied extensions (for preventing unwanted transitions)
                    setTimeout(function () {
                        if (_supportTransition && !_destroyed)
                            addClass(_hostElement, _classNameHostTransition);
                    }, 333);

                    return _base;
                }

                if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {
                    INSTANCES(pluginTargetElement, _base);
                }

                return _base;
            }

            /**
             * Initializes a new OverlayScrollbarsInstance object or changes options if already initialized or returns the current instance.
             * @param pluginTargetElements The elements to which the Plugin shall be initialized.
             * @param options The custom options with which the plugin shall be initialized.
             * @param extensions The extension(s) which shall be added right after initialization.
             * @returns {*}
             */
            _plugin = window[PLUGINNAME] = function (pluginTargetElements, options, extensions) {
                if (arguments[LEXICON.l] === 0)
                    return this;

                var arr = [];
                var optsIsPlainObj = FRAMEWORK.isPlainObject(options);
                var inst;
                var result;

                //pluginTargetElements is null or undefined
                if (!pluginTargetElements)
                    return optsIsPlainObj || !options ? result : arr;

                /*
                   pluginTargetElements will be converted to:
                   1. A jQueryElement Array
                   2. A HTMLElement Array
                   3. A Array with a single HTML Element
                   so pluginTargetElements is always a array.
                */
                pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];
                initOverlayScrollbarsStatics();

                if (pluginTargetElements[LEXICON.l] > 0) {
                    if (optsIsPlainObj) {
                        FRAMEWORK.each(pluginTargetElements, function (i, v) {
                            inst = v;
                            if (inst !== undefined)
                                arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));
                        });
                    }
                    else {
                        FRAMEWORK.each(pluginTargetElements, function (i, v) {
                            inst = INSTANCES(v);
                            if ((options === '!' && _plugin.valid(inst)) || (COMPATIBILITY.type(options) == TYPES.f && options(v, inst)))
                                arr.push(inst);
                            else if (options === undefined)
                                arr.push(inst);
                        });
                    }
                    result = arr[LEXICON.l] === 1 ? arr[0] : arr;
                }
                return result;
            };

            /**
             * Returns a object which contains global information about the plugin and each instance of it.
             * The returned object is just a copy, that means that changes to the returned object won't have any effect to the original object.
             */
            _plugin.globals = function () {
                initOverlayScrollbarsStatics();
                var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);
                delete globals['msie'];
                return globals;
            };

            /**
             * Gets or Sets the default options for each new plugin initialization.
             * @param newDefaultOptions The object with which the default options shall be extended.
             */
            _plugin.defaultOptions = function (newDefaultOptions) {
                initOverlayScrollbarsStatics();
                var currDefaultOptions = _pluginsGlobals.defaultOptions;
                if (newDefaultOptions === undefined)
                    return FRAMEWORK.extend(true, {}, currDefaultOptions);

                //set the new default options
                _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);
            };

            /**
             * Checks whether the passed instance is a non-destroyed OverlayScrollbars instance.
             * @param osInstance The potential OverlayScrollbars instance which shall be checked.
             * @returns {boolean} True if the passed value is a non-destroyed OverlayScrollbars instance, false otherwise.
             */
            _plugin.valid = function (osInstance) {
                return osInstance instanceof _plugin && !osInstance.getState().destroyed;
            };

            /**
             * Registers, Unregisters or returns a extension.
             * Register: Pass the name and the extension. (defaultOptions is optional)
             * Unregister: Pass the name and anything except a function as extension parameter.
             * Get extension: Pass the name of the extension which shall be got.
             * Get all extensions: Pass no arguments.
             * @param extensionName The name of the extension which shall be registered, unregistered or returned.
             * @param extension A function which generates the instance of the extension or anything other to remove a already registered extension.
             * @param defaultOptions The default options which shall be used for the registered extension.
             */
            _plugin.extension = function (extensionName, extension, defaultOptions) {
                var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;
                var argLen = arguments[LEXICON.l];
                var i = 0;
                if (argLen < 1 || !extNameTypeString) {
                    //return a copy of all extension objects
                    return FRAMEWORK.extend(true, { length: _pluginsExtensions[LEXICON.l] }, _pluginsExtensions);
                }
                else if (extNameTypeString) {
                    if (COMPATIBILITY.type(extension) == TYPES.f) {
                        //register extension
                        _pluginsExtensions.push({
                            name: extensionName,
                            extensionFactory: extension,
                            defaultOptions: defaultOptions
                        });
                    }
                    else {
                        for (; i < _pluginsExtensions[LEXICON.l]; i++) {
                            if (_pluginsExtensions[i].name === extensionName) {
                                if (argLen > 1)
                                    _pluginsExtensions.splice(i, 1); //remove extension
                                else
                                    return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]); //return extension with the given name
                            }
                        }
                    }
                }
            };

            return _plugin;
        })();

        if (JQUERY && JQUERY.fn) {
            /**
             * The jQuery initialization interface.
             * @param options The initial options for the construction of the plugin. To initialize the plugin, this option has to be a object! If it isn't a object, the instance(s) are returned and the plugin wont be initialized.
             * @param extensions The extension(s) which shall be added right after initialization.
             * @returns {*} After initialization it returns the jQuery element array, else it returns the instance(s) of the elements which are selected.
             */
            JQUERY.fn.overlayScrollbars = function (options, extensions) {
                var _elements = this;
                if (JQUERY.isPlainObject(options)) {
                    JQUERY.each(_elements, function () { PLUGIN(this, options, extensions); });
                    return _elements;
                }
                else
                    return PLUGIN(_elements, options);
            };
        }
        return PLUGIN;
    }
));

/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.13.3
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 20.07.2022
 */
/* eslint-disable */

(function (global, factory) {
    if (typeof define === 'function' && define.amd)
        define(function () { return factory(global, global.document, undefined); });
    else if (typeof module === 'object' && typeof module.exports === 'object')
        module.exports = factory(global, global.document, undefined);
    else
        factory(global, global.document, undefined);
}(typeof window !== 'undefined' ? window : this,
    function (window, document, undefined) {
        'use strict';
        var PLUGINNAME = 'OverlayScrollbars';
        var TYPES = {
            o: 'object',
            f: 'function',
            a: 'array',
            s: 'string',
            b: 'boolean',
            n: 'number',
            u: 'undefined',
            z: 'null'
            //d : 'date',
            //e : 'error',
            //r : 'regexp',
            //y : 'symbol'
        };
        var LEXICON = {
            c: 'class',
            s: 'style',
            i: 'id',
            l: 'length',
            p: 'prototype',
            ti: 'tabindex',
            oH: 'offsetHeight',
            cH: 'clientHeight',
            sH: 'scrollHeight',
            oW: 'offsetWidth',
            cW: 'clientWidth',
            sW: 'scrollWidth',
            hOP: 'hasOwnProperty',
            bCR: 'getBoundingClientRect'
        };
        var VENDORS = (function () {
            //https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix
            var jsCache = {};
            var cssCache = {};
            var cssPrefixes = ['-webkit-', '-moz-', '-o-', '-ms-'];
            var jsPrefixes = ['WebKit', 'Moz', 'O', 'MS'];
            function firstLetterToUpper(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            }

            return {
                _cssPrefixes: cssPrefixes,
                _jsPrefixes: jsPrefixes,
                _cssProperty: function (name) {
                    var result = cssCache[name];

                    if (cssCache[LEXICON.hOP](name))
                        return result;

                    var uppercasedName = firstLetterToUpper(name);
                    var elmStyle = document.createElement('div')[LEXICON.s];
                    var resultPossibilities;
                    var i = 0;
                    var v;
                    var currVendorWithoutDashes;

                    for (; i < cssPrefixes.length; i++) {
                        currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, '');
                        resultPossibilities = [
                            name, //transition
                            cssPrefixes[i] + name, //-webkit-transition
                            currVendorWithoutDashes + uppercasedName, //webkitTransition
                            firstLetterToUpper(currVendorWithoutDashes) + uppercasedName //WebkitTransition
                        ];
                        for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {
                            if (elmStyle[resultPossibilities[v]] !== undefined) {
                                result = resultPossibilities[v];
                                break;
                            }
                        }
                    }

                    cssCache[name] = result;
                    return result;
                },
                _cssPropertyValue: function (property, values, suffix) {
                    var name = property + ' ' + values;
                    var result = cssCache[name];

                    if (cssCache[LEXICON.hOP](name))
                        return result;

                    var dummyStyle = document.createElement('div')[LEXICON.s];
                    var possbleValues = values.split(' ');
                    var preparedSuffix = suffix || '';
                    var i = 0;
                    var v = -1;
                    var prop;

                    for (; i < possbleValues[LEXICON.l]; i++) {
                        for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {
                            prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i];
                            dummyStyle.cssText = property + ':' + prop + preparedSuffix;
                            if (dummyStyle[LEXICON.l]) {
                                result = prop;
                                break;
                            }
                        }
                    }

                    cssCache[name] = result;
                    return result;
                },
                _jsAPI: function (name, isInterface, fallback) {
                    var i = 0;
                    var result = jsCache[name];

                    if (!jsCache[LEXICON.hOP](name)) {
                        result = window[name];
                        for (; i < jsPrefixes[LEXICON.l]; i++)
                            result = result || window[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];
                        jsCache[name] = result;
                    }
                    return result || fallback;
                }
            }
        })();
        var COMPATIBILITY = (function () {
            function windowSize(x) {
                return x ? window.innerWidth || document.documentElement[LEXICON.cW] || document.body[LEXICON.cW] : window.innerHeight || document.documentElement[LEXICON.cH] || document.body[LEXICON.cH];
            }
            function bind(func, thisObj) {
                if (typeof func != TYPES.f) {
                    throw "Can't bind function!";
                    // closest thing possible to the ECMAScript 5
                    // internal IsCallable function
                    //throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
                }
                var proto = LEXICON.p;
                var aArgs = Array[proto].slice.call(arguments, 2);
                var fNOP = function () { };
                var fBound = function () { return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments))); };

                if (func[proto])
                    fNOP[proto] = func[proto]; // Function.prototype doesn't have a prototype property
                fBound[proto] = new fNOP();

                return fBound;
            }

            return {
                /**
                 * Gets the current window width.
                 * @returns {Number|number} The current window width in pixel.
                 */
                wW: bind(windowSize, 0, true),

                /**
                 * Gets the current window height.
                 * @returns {Number|number} The current window height in pixel.
                 */
                wH: bind(windowSize, 0),

                /**
                 * Gets the MutationObserver Object or undefined if not supported.
                 * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.
                 */
                mO: bind(VENDORS._jsAPI, 0, 'MutationObserver', true),

                /**
                 * Gets the ResizeObserver Object or undefined if not supported.
                 * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.
                 */
                rO: bind(VENDORS._jsAPI, 0, 'ResizeObserver', true),

                /**
                 * Gets the RequestAnimationFrame method or it's corresponding polyfill.
                 * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.
                 */
                rAF: bind(VENDORS._jsAPI, 0, 'requestAnimationFrame', false, function (func) { return window.setTimeout(func, 1000 / 60); }),

                /**
                 * Gets the CancelAnimationFrame method or it's corresponding polyfill.
                 * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.
                 */
                cAF: bind(VENDORS._jsAPI, 0, 'cancelAnimationFrame', false, function (id) { return window.clearTimeout(id); }),

                /**
                 * Gets the current time.
                 * @returns {number} The current time.
                 */
                now: function () {
                    return Date.now && Date.now() || new Date().getTime();
                },

                /**
                 * Stops the propagation of the given event.
                 * @param event The event of which the propagation shall be stoped.
                 */
                stpP: function (event) {
                    if (event.stopPropagation)
                        event.stopPropagation();
                    else
                        event.cancelBubble = true;
                },

                /**
                 * Prevents the default action of the given event.
                 * @param event The event of which the default action shall be prevented.
                 */
                prvD: function (event) {
                    if (event.preventDefault && event.cancelable)
                        event.preventDefault();
                    else
                        event.returnValue = false;
                },

                /**
                 * Gets the pageX and pageY values of the given mouse event.
                 * @param event The mouse event of which the pageX and pageX shall be got.
                 * @returns {{x: number, y: number}} x = pageX value, y = pageY value.
                 */
                page: function (event) {
                    event = event.originalEvent || event;

                    var strPage = 'page';
                    var strClient = 'client';
                    var strX = 'X';
                    var strY = 'Y';
                    var target = event.target || event.srcElement || document;
                    var eventDoc = target.ownerDocument || document;
                    var doc = eventDoc.documentElement;
                    var body = eventDoc.body;

                    //if touch event return return pageX/Y of it
                    if (event.touches !== undefined) {
                        var touch = event.touches[0];
                        return {
                            x: touch[strPage + strX],
                            y: touch[strPage + strY]
                        }
                    }

                    // Calculate pageX/Y if not native supported
                    if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {

                        return {
                            x: event[strClient + strX] +
                                (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                                (doc && doc.clientLeft || body && body.clientLeft || 0),
                            y: event[strClient + strY] +
                                (doc && doc.scrollTop || body && body.scrollTop || 0) -
                                (doc && doc.clientTop || body && body.clientTop || 0)
                        }
                    }
                    return {
                        x: event[strPage + strX],
                        y: event[strPage + strY]
                    };
                },

                /**
                 * Gets the clicked mouse button of the given mouse event.
                 * @param event The mouse event of which the clicked button shal be got.
                 * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)
                 */
                mBtn: function (event) {
                    var button = event.button;
                    if (!event.which && button !== undefined)
                        return (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                    else
                        return event.which;
                },

                /**
                 * Checks whether a item is in the given array and returns its index.
                 * @param item The item of which the position in the array shall be determined.
                 * @param arr The array.
                 * @returns {number} The zero based index of the item or -1 if the item isn't in the array.
                 */
                inA: function (item, arr) {
                    for (var i = 0; i < arr[LEXICON.l]; i++)
                        //Sometiems in IE a "SCRIPT70" Permission denied error occurs if HTML elements in a iFrame are compared
                        try {
                            if (arr[i] === item)
                                return i;
                        }
                        catch (e) { }
                    return -1;
                },

                /**
                 * Returns true if the given value is a array.
                 * @param arr The potential array.
                 * @returns {boolean} True if the given value is a array, false otherwise.
                 */
                isA: function (arr) {
                    var def = Array.isArray;
                    return def ? def(arr) : this.type(arr) == TYPES.a;
                },

                /**
                 * Determine the internal JavaScript [[Class]] of the given object.
                 * @param obj The object of which the type shall be determined.
                 * @returns {string} The type of the given object.
                 */
                type: function (obj) {
                    if (obj === undefined)
                        return obj + '';
                    if (obj === null)
                        return obj + '';
                    return Object[LEXICON.p].toString.call(obj).replace(/^\[object (.+)\]$/, '$1').toLowerCase();
                },


                bind: bind

                /**
                 * Gets the vendor-prefixed CSS property by the given name.
                 * For example the given name is "transform" and you're using a old Firefox browser then the returned value would be "-moz-transform".
                 * If the browser doesn't need a vendor-prefix, then the returned string is the given name.
                 * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.
                 * @param propName The unprefixed CSS property name.
                 * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.

                cssProp: function(propName) {
                    return VENDORS._cssProperty(propName);
                }
                */
            }
        })();


        var MATH = Math;
        var JQUERY = window.jQuery;
        var EASING = (function () {
            var _easingsMath = {
                p: MATH.PI,
                c: MATH.cos,
                s: MATH.sin,
                w: MATH.pow,
                t: MATH.sqrt,
                n: MATH.asin,
                a: MATH.abs,
                o: 1.70158
            };

            /*
             x : current percent (0 - 1),
             t : current time (duration * percent),
             b : start value (from),
             c : end value (to),
             d : duration

             easingName : function(x, t, b, c, d) { return easedValue; }
             */

            return {
                swing: function (x, t, b, c, d) {
                    return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;
                },
                linear: function (x, t, b, c, d) {
                    return x;
                },
                easeInQuad: function (x, t, b, c, d) {
                    return c * (t /= d) * t + b;
                },
                easeOutQuad: function (x, t, b, c, d) {
                    return -c * (t /= d) * (t - 2) + b;
                },
                easeInOutQuad: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t + b : -c / 2 * ((--t) * (t - 2) - 1) + b;
                },
                easeInCubic: function (x, t, b, c, d) {
                    return c * (t /= d) * t * t + b;
                },
                easeOutCubic: function (x, t, b, c, d) {
                    return c * ((t = t / d - 1) * t * t + 1) + b;
                },
                easeInOutCubic: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b;
                },
                easeInQuart: function (x, t, b, c, d) {
                    return c * (t /= d) * t * t * t + b;
                },
                easeOutQuart: function (x, t, b, c, d) {
                    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
                },
                easeInOutQuart: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b;
                },
                easeInQuint: function (x, t, b, c, d) {
                    return c * (t /= d) * t * t * t * t + b;
                },
                easeOutQuint: function (x, t, b, c, d) {
                    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
                },
                easeInOutQuint: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
                },
                easeInSine: function (x, t, b, c, d) {
                    return -c * _easingsMath.c(t / d * (_easingsMath.p / 2)) + c + b;
                },
                easeOutSine: function (x, t, b, c, d) {
                    return c * _easingsMath.s(t / d * (_easingsMath.p / 2)) + b;
                },
                easeInOutSine: function (x, t, b, c, d) {
                    return -c / 2 * (_easingsMath.c(_easingsMath.p * t / d) - 1) + b;
                },
                easeInExpo: function (x, t, b, c, d) {
                    return (t == 0) ? b : c * _easingsMath.w(2, 10 * (t / d - 1)) + b;
                },
                easeOutExpo: function (x, t, b, c, d) {
                    return (t == d) ? b + c : c * (-_easingsMath.w(2, -10 * t / d) + 1) + b;
                },
                easeInOutExpo: function (x, t, b, c, d) {
                    if (t == 0) return b;
                    if (t == d) return b + c;
                    if ((t /= d / 2) < 1) return c / 2 * _easingsMath.w(2, 10 * (t - 1)) + b;
                    return c / 2 * (-_easingsMath.w(2, -10 * --t) + 2) + b;
                },
                easeInCirc: function (x, t, b, c, d) {
                    return -c * (_easingsMath.t(1 - (t /= d) * t) - 1) + b;
                },
                easeOutCirc: function (x, t, b, c, d) {
                    return c * _easingsMath.t(1 - (t = t / d - 1) * t) + b;
                },
                easeInOutCirc: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? -c / 2 * (_easingsMath.t(1 - t * t) - 1) + b : c / 2 * (_easingsMath.t(1 - (t -= 2) * t) + 1) + b;
                },
                easeInElastic: function (x, t, b, c, d) {
                    var s = _easingsMath.o; var p = 0; var a = c;
                    if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3;
                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                    return -(a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
                },
                easeOutElastic: function (x, t, b, c, d) {
                    var s = _easingsMath.o; var p = 0; var a = c;
                    if (t == 0) return b;
                    if ((t /= d) == 1) return b + c;
                    if (!p) p = d * .3;
                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                    return a * _easingsMath.w(2, -10 * t) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) + c + b;
                },
                easeInOutElastic: function (x, t, b, c, d) {
                    var s = _easingsMath.o; var p = 0; var a = c;
                    if (t == 0) return b;
                    if ((t /= d / 2) == 2) return b + c;
                    if (!p) p = d * (.3 * 1.5);
                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                    if (t < 1) return -.5 * (a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
                    return a * _easingsMath.w(2, -10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) * .5 + c + b;
                },
                easeInBack: function (x, t, b, c, d, s) {
                    s = s || _easingsMath.o;
                    return c * (t /= d) * t * ((s + 1) * t - s) + b;
                },
                easeOutBack: function (x, t, b, c, d, s) {
                    s = s || _easingsMath.o;
                    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
                },
                easeInOutBack: function (x, t, b, c, d, s) {
                    s = s || _easingsMath.o;
                    return ((t /= d / 2) < 1) ? c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
                },
                easeInBounce: function (x, t, b, c, d) {
                    return c - this.easeOutBounce(x, d - t, 0, c, d) + b;
                },
                easeOutBounce: function (x, t, b, c, d) {
                    var o = 7.5625;
                    if ((t /= d) < (1 / 2.75)) {
                        return c * (o * t * t) + b;
                    } else if (t < (2 / 2.75)) {
                        return c * (o * (t -= (1.5 / 2.75)) * t + .75) + b;
                    } else if (t < (2.5 / 2.75)) {
                        return c * (o * (t -= (2.25 / 2.75)) * t + .9375) + b;
                    } else {
                        return c * (o * (t -= (2.625 / 2.75)) * t + .984375) + b;
                    }
                },
                easeInOutBounce: function (x, t, b, c, d) {
                    return (t < d / 2) ? this.easeInBounce(x, t * 2, 0, c, d) * .5 + b : this.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b;
                }
            };
            /*
             *
             * TERMS OF USE - EASING EQUATIONS
             *
             * Open source under the BSD License.
             *
             * Copyright Â© 2001 Robert Penner
             * All rights reserved.
             *
             * Redistribution and use in source and binary forms, with or without modification,
             * are permitted provided that the following conditions are met:
             *
             * Redistributions of source code must retain the above copyright notice, this list of
             * conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice, this list
             * of conditions and the following disclaimer in the documentation and/or other materials
             * provided with the distribution.
             *
             * Neither the name of the author nor the names of contributors may be used to endorse
             * or promote products derived from this software without specific prior written permission.
             *
             * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
             * EXPRESS OR IMPLIED WARRANTIESLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
             * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
             *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECTIDENTAL, SPECIAL,
             *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
             *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
             * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
             *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
             * OF THE POSSIBILITY OF SUCH DAMAGE.
             *
             */
        })();
        var FRAMEWORK = (function () {
            var _rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);
            var _strSpace = ' ';
            var _strEmpty = '';
            var _strScrollLeft = 'scrollLeft';
            var _strScrollTop = 'scrollTop';
            var _animations = [];
            var _type = COMPATIBILITY.type;
            var _cssNumber = {
                animationIterationCount: true,
                columnCount: true,
                fillOpacity: true,
                flexGrow: true,
                flexShrink: true,
                fontWeight: true,
                lineHeight: true,
                opacity: true,
                order: true,
                orphans: true,
                widows: true,
                zIndex: true,
                zoom: true
            };

            function extend() {
                var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {},
                    i = 1,
                    length = arguments[LEXICON.l],
                    deep = false;

                // Handle a deep copy situation
                if (_type(target) == TYPES.b) {
                    deep = target;
                    target = arguments[1] || {};
                    // skip the boolean and the target
                    i = 2;
                }

                // Handle case when target is a string or something (possible in deep copy)
                if (_type(target) != TYPES.o && !_type(target) == TYPES.f) {
                    target = {};
                }

                // extend jQuery itself if only one argument is passed
                if (length === i) {
                    target = FakejQuery;
                    --i;
                }

                for (; i < length; i++) {
                    // Only deal with non-null/undefined values
                    if ((options = arguments[i]) != null) {
                        // Extend the base object
                        for (name in options) {
                            src = target[name];
                            copy = options[name];

                            // Prevent never-ending loop
                            if (target === copy) {
                                continue;
                            }

                            // Recurse if we're merging plain objects or arrays
                            if (deep && copy && (isPlainObject(copy) || (copyIsArray = COMPATIBILITY.isA(copy)))) {
                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && COMPATIBILITY.isA(src) ? src : [];

                                } else {
                                    clone = src && isPlainObject(src) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[name] = extend(deep, clone, copy);

                                // Don't bring in undefined values
                            } else if (copy !== undefined) {
                                target[name] = copy;
                            }
                        }
                    }
                }

                // Return the modified object
                return target;
            };

            function inArray(item, arr, fromIndex) {
                for (var i = fromIndex || 0; i < arr[LEXICON.l]; i++)
                    if (arr[i] === item)
                        return i;
                return -1;
            }

            function isFunction(obj) {
                return _type(obj) == TYPES.f;
            };

            function isEmptyObject(obj) {
                for (var name in obj)
                    return false;
                return true;
            };

            function isPlainObject(obj) {
                if (!obj || _type(obj) != TYPES.o)
                    return false;

                var key;
                var proto = LEXICON.p;
                var hasOwnProperty = Object[proto].hasOwnProperty;
                var hasOwnConstructor = hasOwnProperty.call(obj, 'constructor');
                var hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], 'isPrototypeOf');

                if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
                    return false;
                }


                for (key in obj) { /**/ }

                return _type(key) == TYPES.u || hasOwnProperty.call(obj, key);
            };

            function each(obj, callback) {
                var i = 0;

                if (isArrayLike(obj)) {
                    for (; i < obj[LEXICON.l]; i++) {
                        if (callback.call(obj[i], i, obj[i]) === false)
                            break;
                    }
                }
                else {
                    for (i in obj) {
                        if (callback.call(obj[i], i, obj[i]) === false)
                            break;
                    }
                }

                return obj;
            };

            function isArrayLike(obj) {
                var length = !!obj && [LEXICON.l] in obj && obj[LEXICON.l];
                var t = _type(obj);
                return isFunction(t) ? false : (t == TYPES.a || length === 0 || _type(length) == TYPES.n && length > 0 && (length - 1) in obj);
            }

            function stripAndCollapse(value) {
                var tokens = value.match(_rnothtmlwhite) || [];
                return tokens.join(_strSpace);
            }

            function matches(elem, selector) {
                var nodeList = (elem.parentNode || document).querySelectorAll(selector) || [];
                var i = nodeList[LEXICON.l];

                while (i--)
                    if (nodeList[i] == elem)
                        return true;

                return false;
            }

            function insertAdjacentElement(el, strategy, child) {
                if (COMPATIBILITY.isA(child)) {
                    for (var i = 0; i < child[LEXICON.l]; i++)
                        insertAdjacentElement(el, strategy, child[i]);
                }
                else if (_type(child) == TYPES.s)
                    el.insertAdjacentHTML(strategy, child);
                else
                    el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);
            }

            function setCSSVal(el, prop, val) {
                try {
                    if (el[LEXICON.s][prop] !== undefined)
                        el[LEXICON.s][prop] = parseCSSVal(prop, val);
                } catch (e) { }
            }

            function parseCSSVal(prop, val) {
                if (!_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n)
                    val += 'px';
                return val;
            }

            function startNextAnimationInQ(animObj, removeFromQ) {
                var index;
                var nextAnim;
                if (removeFromQ !== false)
                    animObj.q.splice(0, 1);
                if (animObj.q[LEXICON.l] > 0) {
                    nextAnim = animObj.q[0];
                    animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true);
                }
                else {
                    index = inArray(animObj, _animations);
                    if (index > -1)
                        _animations.splice(index, 1);
                }
            }

            function setAnimationValue(el, prop, value) {
                if (prop === _strScrollLeft || prop === _strScrollTop)
                    el[prop] = value;
                else
                    setCSSVal(el, prop, value);
            }

            function animate(el, props, options, easing, complete, guaranteedNext) {
                var hasOptions = isPlainObject(options);
                var from = {};
                var to = {};
                var i = 0;
                var key;
                var animObj;
                var start;
                var progress;
                var step;
                var specialEasing;
                var duration;
                if (hasOptions) {
                    easing = options.easing;
                    start = options.start;
                    progress = options.progress;
                    step = options.step;
                    specialEasing = options.specialEasing;
                    complete = options.complete;
                    duration = options.duration;
                }
                else
                    duration = options;
                specialEasing = specialEasing || {};
                duration = duration || 400;
                easing = easing || 'swing';
                guaranteedNext = guaranteedNext || false;

                for (; i < _animations[LEXICON.l]; i++) {
                    if (_animations[i].el === el) {
                        animObj = _animations[i];
                        break;
                    }
                }

                if (!animObj) {
                    animObj = {
                        el: el,
                        q: []
                    };
                    _animations.push(animObj);
                }

                for (key in props) {
                    if (key === _strScrollLeft || key === _strScrollTop)
                        from[key] = el[key];
                    else
                        from[key] = FakejQuery(el).css(key);
                }

                for (key in from) {
                    if (from[key] !== props[key] && props[key] !== undefined)
                        to[key] = props[key];
                }

                if (!isEmptyObject(to)) {
                    var timeNow;
                    var end;
                    var percent;
                    var fromVal;
                    var toVal;
                    var easedVal;
                    var timeStart;
                    var frame;
                    var elapsed;
                    var qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q);
                    var qObj = {
                        props: to,
                        duration: hasOptions ? options : duration,
                        easing: easing,
                        complete: complete
                    };
                    if (qPos === -1) {
                        qPos = animObj.q[LEXICON.l];
                        animObj.q.push(qObj);
                    }

                    if (qPos === 0) {
                        if (duration > 0) {
                            timeStart = COMPATIBILITY.now();
                            frame = function () {
                                timeNow = COMPATIBILITY.now();
                                elapsed = (timeNow - timeStart);
                                end = qObj.stop || elapsed >= duration;
                                percent = 1 - ((MATH.max(0, timeStart + duration - timeNow) / duration) || 0);

                                for (key in to) {
                                    fromVal = parseFloat(from[key]);
                                    toVal = parseFloat(to[key]);
                                    easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing](percent, percent * duration, 0, 1, duration) + fromVal;
                                    setAnimationValue(el, key, easedVal);
                                    if (isFunction(step)) {
                                        step(easedVal, {
                                            elem: el,
                                            prop: key,
                                            start: fromVal,
                                            now: easedVal,
                                            end: toVal,
                                            pos: percent,
                                            options: {
                                                easing: easing,
                                                speacialEasing: specialEasing,
                                                duration: duration,
                                                complete: complete,
                                                step: step
                                            },
                                            startTime: timeStart
                                        });
                                    }
                                }

                                if (isFunction(progress))
                                    progress({}, percent, MATH.max(0, duration - elapsed));

                                if (end) {
                                    startNextAnimationInQ(animObj);
                                    if (isFunction(complete))
                                        complete();
                                }
                                else
                                    qObj.frame = COMPATIBILITY.rAF()(frame);
                            };
                            qObj.frame = COMPATIBILITY.rAF()(frame);
                        }
                        else {
                            for (key in to)
                                setAnimationValue(el, key, to[key]);
                            startNextAnimationInQ(animObj);
                        }
                    }
                }
                else if (guaranteedNext)
                    startNextAnimationInQ(animObj);
            }

            function stop(el, clearQ, jumpToEnd) {
                var animObj;
                var qObj;
                var key;
                var i = 0;
                for (; i < _animations[LEXICON.l]; i++) {
                    animObj = _animations[i];
                    if (animObj.el === el) {
                        if (animObj.q[LEXICON.l] > 0) {
                            qObj = animObj.q[0];
                            qObj.stop = true;
                            COMPATIBILITY.cAF()(qObj.frame);
                            animObj.q.splice(0, 1);

                            if (jumpToEnd)
                                for (key in qObj.props)
                                    setAnimationValue(el, key, qObj.props[key]);

                            if (clearQ)
                                animObj.q = [];
                            else
                                startNextAnimationInQ(animObj, false);
                        }
                        break;
                    }
                }
            }

            function elementIsVisible(el) {
                return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);
            }

            function FakejQuery(selector) {
                if (arguments[LEXICON.l] === 0)
                    return this;

                var base = new FakejQuery();
                var elements = selector;
                var i = 0;
                var elms;
                var el;

                if (_type(selector) == TYPES.s) {
                    elements = [];
                    if (selector.charAt(0) === '<') {
                        el = document.createElement('div');
                        el.innerHTML = selector;
                        elms = el.children;
                    }
                    else {
                        elms = document.querySelectorAll(selector);
                    }

                    for (; i < elms[LEXICON.l]; i++)
                        elements.push(elms[i]);
                }

                if (elements) {
                    if (_type(elements) != TYPES.s && (!isArrayLike(elements) || elements === window || elements === elements.self))
                        elements = [elements];

                    for (i = 0; i < elements[LEXICON.l]; i++)
                        base[i] = elements[i];

                    base[LEXICON.l] = elements[LEXICON.l];
                }

                return base;
            };

            FakejQuery[LEXICON.p] = {

                //EVENTS:

                on: function (eventName, handler) {
                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];

                    var eventNameLength = eventName[LEXICON.l];
                    var i = 0;
                    var el;
                    return this.each(function () {
                        el = this;
                        try {
                            if (el.addEventListener) {
                                for (; i < eventNameLength; i++)
                                    el.addEventListener(eventName[i], handler);
                            }
                            else if (el.detachEvent) {
                                for (; i < eventNameLength; i++)
                                    el.attachEvent('on' + eventName[i], handler);
                            }
                        } catch (e) { }
                    });
                },

                off: function (eventName, handler) {
                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];

                    var eventNameLength = eventName[LEXICON.l];
                    var i = 0;
                    var el;
                    return this.each(function () {
                        el = this;
                        try {
                            if (el.removeEventListener) {
                                for (; i < eventNameLength; i++)
                                    el.removeEventListener(eventName[i], handler);
                            }
                            else if (el.detachEvent) {
                                for (; i < eventNameLength; i++)
                                    el.detachEvent('on' + eventName[i], handler);
                            }
                        } catch (e) { }
                    });
                },

                one: function (eventName, handler) {
                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
                    return this.each(function () {
                        var el = FakejQuery(this);
                        FakejQuery.each(eventName, function (i, oneEventName) {
                            var oneHandler = function (e) {
                                handler.call(this, e);
                                el.off(oneEventName, oneHandler);
                            };
                            el.on(oneEventName, oneHandler);
                        });
                    });
                },

                trigger: function (eventName) {
                    var el;
                    var event;
                    return this.each(function () {
                        el = this;
                        if (document.createEvent) {
                            event = document.createEvent('HTMLEvents');
                            event.initEvent(eventName, true, false);
                            el.dispatchEvent(event);
                        }
                        else {
                            el.fireEvent('on' + eventName);
                        }
                    });
                },

                //DOM NODE INSERTING / REMOVING:

                append: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'beforeend', child); });
                },

                prepend: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'afterbegin', child); });
                },

                before: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'beforebegin', child); });
                },

                after: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'afterend', child); });
                },

                remove: function () {
                    return this.each(function () {
                        var el = this;
                        var parentNode = el.parentNode;
                        if (parentNode != null)
                            parentNode.removeChild(el);
                    });
                },

                unwrap: function () {
                    var parents = [];
                    var i;
                    var el;
                    var parent;

                    this.each(function () {
                        parent = this.parentNode;
                        if (inArray(parent, parents) === - 1)
                            parents.push(parent);
                    });

                    for (i = 0; i < parents[LEXICON.l]; i++) {
                        el = parents[i];
                        parent = el.parentNode;

                        if (parent) {
                            while (el.firstChild)
                                parent.insertBefore(el.firstChild, el);
                            parent.removeChild(el);
                        }
                    }

                    return this;
                },

                wrapAll: function (wrapperHTML) {
                    var i;
                    var nodes = this;
                    var wrapper = FakejQuery(wrapperHTML)[0];
                    var deepest = wrapper;
                    var parent = nodes[0].parentNode;
                    var previousSibling = nodes[0].previousSibling;
                    while (deepest.childNodes[LEXICON.l] > 0)
                        deepest = deepest.childNodes[0];

                    for (i = 0; nodes[LEXICON.l] - i; deepest.firstChild === nodes[0] && i++)
                        deepest.appendChild(nodes[i]);

                    var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;
                    parent.insertBefore(wrapper, nextSibling);

                    return this;
                },

                wrapInner: function (wrapperHTML) {
                    return this.each(function () {
                        var el = FakejQuery(this);
                        var contents = el.contents();

                        if (contents[LEXICON.l])
                            contents.wrapAll(wrapperHTML);
                        else
                            el.append(wrapperHTML);
                    });
                },

                wrap: function (wrapperHTML) {
                    return this.each(function () { FakejQuery(this).wrapAll(wrapperHTML); });
                },


                //DOM NODE MANIPULATION / INFORMATION:

                css: function (styles, val) {
                    var el;
                    var key;
                    var cptStyle;
                    var getCptStyle = window.getComputedStyle;
                    if (_type(styles) == TYPES.s) {
                        if (val === undefined) {
                            el = this[0];
                            cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles];

                            //https://bugzilla.mozilla.org/show_bug.cgi?id=548397 can be null sometimes if iframe with display: none (firefox only!)
                            return getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles) : el[LEXICON.s][styles] : cptStyle;
                        }
                        else {
                            return this.each(function () {
                                setCSSVal(this, styles, val);
                            });
                        }
                    }
                    else {
                        return this.each(function () {
                            for (key in styles)
                                setCSSVal(this, key, styles[key]);
                        });
                    }
                },

                hasClass: function (className) {
                    var elem, i = 0;
                    var classNamePrepared = _strSpace + className + _strSpace;
                    var classList;

                    while ((elem = this[i++])) {
                        classList = elem.classList;
                        if (classList && classList.contains(className))
                            return true;
                        else if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1)
                            return true;
                    }

                    return false;
                },

                addClass: function (className) {
                    var classes;
                    var elem;
                    var cur;
                    var curValue;
                    var clazz;
                    var finalValue;
                    var supportClassList;
                    var elmClassList;
                    var i = 0;
                    var v = 0;

                    if (className) {
                        classes = className.match(_rnothtmlwhite) || [];

                        while ((elem = this[i++])) {
                            elmClassList = elem.classList;
                            if (supportClassList === undefined)
                                supportClassList = elmClassList !== undefined;

                            if (supportClassList) {
                                while ((clazz = classes[v++]))
                                    elmClassList.add(clazz);
                            }
                            else {
                                curValue = elem.className + _strEmpty;
                                cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);

                                if (cur) {
                                    while ((clazz = classes[v++]))
                                        if (cur.indexOf(_strSpace + clazz + _strSpace) < 0)
                                            cur += clazz + _strSpace;

                                    finalValue = stripAndCollapse(cur);
                                    if (curValue !== finalValue)
                                        elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                removeClass: function (className) {
                    var classes;
                    var elem;
                    var cur;
                    var curValue;
                    var clazz;
                    var finalValue;
                    var supportClassList;
                    var elmClassList;
                    var i = 0;
                    var v = 0;

                    if (className) {
                        classes = className.match(_rnothtmlwhite) || [];

                        while ((elem = this[i++])) {
                            elmClassList = elem.classList;
                            if (supportClassList === undefined)
                                supportClassList = elmClassList !== undefined;

                            if (supportClassList) {
                                while ((clazz = classes[v++]))
                                    elmClassList.remove(clazz);
                            }
                            else {
                                curValue = elem.className + _strEmpty;
                                cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);

                                if (cur) {
                                    while ((clazz = classes[v++]))
                                        while (cur.indexOf(_strSpace + clazz + _strSpace) > -1)
                                            cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);

                                    finalValue = stripAndCollapse(cur);
                                    if (curValue !== finalValue)
                                        elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                hide: function () {
                    return this.each(function () { this[LEXICON.s].display = 'none'; });
                },

                show: function () {
                    return this.each(function () { this[LEXICON.s].display = 'block'; });
                },

                attr: function (attrName, value) {
                    var i = 0;
                    var el;
                    while (el = this[i++]) {
                        if (value === undefined)
                            return el.getAttribute(attrName);
                        el.setAttribute(attrName, value);
                    }
                    return this;
                },

                removeAttr: function (attrName) {
                    return this.each(function () { this.removeAttribute(attrName); });
                },

                offset: function () {
                    var el = this[0];
                    var rect = el[LEXICON.bCR]();
                    var scrollLeft = window.pageXOffset || document.documentElement[_strScrollLeft];
                    var scrollTop = window.pageYOffset || document.documentElement[_strScrollTop];
                    return {
                        top: rect.top + scrollTop,
                        left: rect.left + scrollLeft
                    };
                },

                position: function () {
                    var el = this[0];
                    return {
                        top: el.offsetTop,
                        left: el.offsetLeft
                    };
                },

                scrollLeft: function (value) {
                    var i = 0;
                    var el;
                    while (el = this[i++]) {
                        if (value === undefined)
                            return el[_strScrollLeft];
                        el[_strScrollLeft] = value;
                    }
                    return this;
                },

                scrollTop: function (value) {
                    var i = 0;
                    var el;
                    while (el = this[i++]) {
                        if (value === undefined)
                            return el[_strScrollTop];
                        el[_strScrollTop] = value;
                    }
                    return this;
                },

                val: function (value) {
                    var el = this[0];
                    if (!value)
                        return el.value;
                    el.value = value;
                    return this;
                },


                //DOM TRAVERSAL / FILTERING:

                first: function () {
                    return this.eq(0);
                },

                last: function () {
                    return this.eq(-1);
                },

                eq: function (index) {
                    return FakejQuery(this[index >= 0 ? index : this[LEXICON.l] + index]);
                },

                find: function (selector) {
                    var children = [];
                    var i;
                    this.each(function () {
                        var el = this;
                        var ch = el.querySelectorAll(selector);
                        for (i = 0; i < ch[LEXICON.l]; i++)
                            children.push(ch[i]);
                    });
                    return FakejQuery(children);
                },

                children: function (selector) {
                    var children = [];
                    var el;
                    var ch;
                    var i;

                    this.each(function () {
                        ch = this.children;
                        for (i = 0; i < ch[LEXICON.l]; i++) {
                            el = ch[i];
                            if (selector) {
                                if ((el.matches && el.matches(selector)) || matches(el, selector))
                                    children.push(el);
                            }
                            else
                                children.push(el);
                        }
                    });
                    return FakejQuery(children);
                },

                parent: function (selector) {
                    var parents = [];
                    var parent;
                    this.each(function () {
                        parent = this.parentNode;
                        if (selector ? FakejQuery(parent).is(selector) : true)
                            parents.push(parent);
                    });
                    return FakejQuery(parents);
                },

                is: function (selector) {

                    var el;
                    var i;
                    for (i = 0; i < this[LEXICON.l]; i++) {
                        el = this[i];
                        if (selector === ':visible')
                            return elementIsVisible(el);
                        if (selector === ':hidden')
                            return !elementIsVisible(el);
                        if ((el.matches && el.matches(selector)) || matches(el, selector))
                            return true;
                    }
                    return false;
                },

                contents: function () {
                    var contents = [];
                    var childs;
                    var i;

                    this.each(function () {
                        childs = this.childNodes;
                        for (i = 0; i < childs[LEXICON.l]; i++)
                            contents.push(childs[i]);
                    });

                    return FakejQuery(contents);
                },

                each: function (callback) {
                    return each(this, callback);
                },


                //ANIMATION:

                animate: function (props, duration, easing, complete) {
                    return this.each(function () { animate(this, props, duration, easing, complete); });
                },

                stop: function (clearQ, jump) {
                    return this.each(function () { stop(this, clearQ, jump); });
                }
            };

            extend(FakejQuery, {
                extend: extend,
                inArray: inArray,
                isEmptyObject: isEmptyObject,
                isPlainObject: isPlainObject,
                each: each
            });

            return FakejQuery;
        })();
        var INSTANCES = (function () {
            var _targets = [];
            var _instancePropertyString = '__overlayScrollbars__';

            /**
             * Register, unregister or get a certain (or all) instances.
             * Register: Pass the target and the instance.
             * Unregister: Pass the target and null.
             * Get Instance: Pass the target from which the instance shall be got.
             * Get Targets: Pass no arguments.
             * @param target The target to which the instance shall be registered / from which the instance shall be unregistered / the instance shall be got
             * @param instance The instance.
             * @returns {*|void} Returns the instance from the given target.
             */
            return function (target, instance) {
                var argLen = arguments[LEXICON.l];
                if (argLen < 1) {
                    //return all targets
                    return _targets;
                }
                else {
                    if (instance) {
                        //register instance
                        target[_instancePropertyString] = instance;
                        _targets.push(target);
                    }
                    else {
                        var index = COMPATIBILITY.inA(target, _targets);
                        if (index > -1) {
                            if (argLen > 1) {
                                //unregister instance
                                delete target[_instancePropertyString];
                                _targets.splice(index, 1);
                            }
                            else {
                                //get instance from target
                                return _targets[index][_instancePropertyString];
                            }
                        }
                    }
                }
            }
        })();
        var PLUGIN = (function () {
            var _plugin;
            var _pluginsGlobals;
            var _pluginsAutoUpdateLoop;
            var _pluginsExtensions = [];
            var _pluginsOptions = (function () {
                var type = COMPATIBILITY.type;
                var possibleTemplateTypes = [
                    TYPES.b, //boolean
                    TYPES.n, //number
                    TYPES.s, //string
                    TYPES.a, //array
                    TYPES.o, //object
                    TYPES.f, //function
                    TYPES.z  //null
                ];
                var restrictedStringsSplit = ' ';
                var restrictedStringsPossibilitiesSplit = ':';
                var classNameAllowedValues = [TYPES.z, TYPES.s];
                var numberAllowedValues = TYPES.n;
                var booleanNullAllowedValues = [TYPES.z, TYPES.b];
                var booleanTrueTemplate = [true, TYPES.b];
                var booleanFalseTemplate = [false, TYPES.b];
                var callbackTemplate = [null, [TYPES.z, TYPES.f]];
                var updateOnLoadTemplate = [['img'], [TYPES.s, TYPES.a, TYPES.z]];
                var inheritedAttrsTemplate = [['style', 'class'], [TYPES.s, TYPES.a, TYPES.z]];
                var resizeAllowedValues = 'n:none b:both h:horizontal v:vertical';
                var overflowBehaviorAllowedValues = 'v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden';
                var scrollbarsVisibilityAllowedValues = 'v:visible h:hidden a:auto';
                var scrollbarsAutoHideAllowedValues = 'n:never s:scroll l:leave m:move';
                var optionsDefaultsAndTemplate = {
                    className: ['os-theme-dark', classNameAllowedValues],                //null || string
                    resize: ['none', resizeAllowedValues],                               //none || both  || horizontal || vertical || n || b || h || v
                    sizeAutoCapable: booleanTrueTemplate,                                //true || false
                    clipAlways: booleanTrueTemplate,                                     //true || false
                    normalizeRTL: booleanTrueTemplate,                                   //true || false
                    paddingAbsolute: booleanFalseTemplate,                               //true || false
                    autoUpdate: [null, booleanNullAllowedValues],                        //true || false || null
                    autoUpdateInterval: [33, numberAllowedValues],                       //number
                    updateOnLoad: updateOnLoadTemplate,                                  //string || array || null
                    nativeScrollbarsOverlaid: {
                        showNativeScrollbars: booleanFalseTemplate,                      //true || false
                        initialize: booleanTrueTemplate                                  //true || false
                    },
                    overflowBehavior: {
                        x: ['scroll', overflowBehaviorAllowedValues],                    //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                        y: ['scroll', overflowBehaviorAllowedValues]                     //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                    },
                    scrollbars: {
                        visibility: ['auto', scrollbarsVisibilityAllowedValues],         //visible || hidden || auto || v || h || a
                        autoHide: ['never', scrollbarsAutoHideAllowedValues],            //never || scroll || leave || move || n || s || l || m
                        autoHideDelay: [800, numberAllowedValues],                       //number
                        dragScrolling: booleanTrueTemplate,                              //true || false
                        clickScrolling: booleanFalseTemplate,                            //true || false
                        touchSupport: booleanTrueTemplate,                               //true || false
                        snapHandle: booleanFalseTemplate                                 //true || false
                    },
                    textarea: {
                        dynWidth: booleanFalseTemplate,                                  //true || false
                        dynHeight: booleanFalseTemplate,                                 //true || false
                        inheritedAttrs: inheritedAttrsTemplate                           //string || array || null
                    },
                    callbacks: {
                        onInitialized: callbackTemplate,                                 //null || function
                        onInitializationWithdrawn: callbackTemplate,                     //null || function
                        onDestroyed: callbackTemplate,                                   //null || function
                        onScrollStart: callbackTemplate,                                 //null || function
                        onScroll: callbackTemplate,                                      //null || function
                        onScrollStop: callbackTemplate,                                  //null || function
                        onOverflowChanged: callbackTemplate,                             //null || function
                        onOverflowAmountChanged: callbackTemplate,                       //null || function
                        onDirectionChanged: callbackTemplate,                            //null || function
                        onContentSizeChanged: callbackTemplate,                          //null || function
                        onHostSizeChanged: callbackTemplate,                             //null || function
                        onUpdated: callbackTemplate                                      //null || function
                    }
                };
                var convert = function (template) {
                    var recursive = function (obj) {
                        var key;
                        var val;
                        var valType;
                        for (key in obj) {
                            if (!obj[LEXICON.hOP](key))
                                continue;
                            val = obj[key];
                            valType = type(val);
                            if (valType == TYPES.a)
                                obj[key] = val[template ? 1 : 0];
                            else if (valType == TYPES.o)
                                obj[key] = recursive(val);
                        }
                        return obj;
                    };
                    return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));
                };

                return {
                    _defaults: convert(),

                    _template: convert(true),

                    /**
                     * Validates the passed object by the passed template.
                     * @param obj The object which shall be validated.
                     * @param template The template which defines the allowed values and types.
                     * @param writeErrors True if errors shall be logged to the console.
                     * @param diffObj If a object is passed then only valid differences to this object will be returned.
                     * @returns {{}} A object which contains two objects called "default" and "prepared" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.
                     */
                    _validate: function (obj, template, writeErrors, diffObj) {
                        var validatedOptions = {};
                        var validatedOptionsPrepared = {};
                        var objectCopy = FRAMEWORK.extend(true, {}, obj);
                        var inArray = FRAMEWORK.inArray;
                        var isEmptyObj = FRAMEWORK.isEmptyObject;
                        var checkObjectProps = function (data, template, diffData, validatedOptions, validatedOptionsPrepared, prevPropName) {
                            for (var prop in template) {
                                if (template[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {
                                    var isValid = false;
                                    var isDiff = false;
                                    var templateValue = template[prop];
                                    var templateValueType = type(templateValue);
                                    var templateIsComplex = templateValueType == TYPES.o;
                                    var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;
                                    var dataDiffValue = diffData[prop];
                                    var dataValue = data[prop];
                                    var dataValueType = type(dataValue);
                                    var propPrefix = prevPropName ? prevPropName + '.' : '';
                                    var error = "The option \"" + propPrefix + prop + "\" wasn't set, because";
                                    var errorPossibleTypes = [];
                                    var errorRestrictedStrings = [];
                                    var restrictedStringValuesSplit;
                                    var restrictedStringValuesPossibilitiesSplit;
                                    var isRestrictedValue;
                                    var mainPossibility;
                                    var currType;
                                    var i;
                                    var v;
                                    var j;

                                    dataDiffValue = dataDiffValue === undefined ? {} : dataDiffValue;

                                    //if the template has a object as value, it means that the options are complex (verschachtelt)
                                    if (templateIsComplex && dataValueType == TYPES.o) {
                                        validatedOptions[prop] = {};
                                        validatedOptionsPrepared[prop] = {};
                                        checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions[prop], validatedOptionsPrepared[prop], propPrefix + prop);
                                        FRAMEWORK.each([data, validatedOptions, validatedOptionsPrepared], function (index, value) {
                                            if (isEmptyObj(value[prop])) {
                                                delete value[prop];
                                            }
                                        });
                                    }
                                    else if (!templateIsComplex) {
                                        for (i = 0; i < templateTypes[LEXICON.l]; i++) {
                                            currType = templateTypes[i];
                                            templateValueType = type(currType);
                                            //if currtype is string and starts with restrictedStringPrefix and end with restrictedStringSuffix
                                            isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;
                                            if (isRestrictedValue) {
                                                errorPossibleTypes.push(TYPES.s);

                                                //split it into a array which contains all possible values for example: ["y:yes", "n:no", "m:maybe"]
                                                restrictedStringValuesSplit = currType.split(restrictedStringsSplit);
                                                errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);
                                                for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {
                                                    //split the possible values into their possibiliteis for example: ["y", "yes"] -> the first is always the mainPossibility
                                                    restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);
                                                    mainPossibility = restrictedStringValuesPossibilitiesSplit[0];
                                                    for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {
                                                        //if any possibility matches with the dataValue, its valid
                                                        if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {
                                                            isValid = true;
                                                            break;
                                                        }
                                                    }
                                                    if (isValid)
                                                        break;
                                                }
                                            }
                                            else {
                                                errorPossibleTypes.push(currType);

                                                if (dataValueType === currType) {
                                                    isValid = true;
                                                    break;
                                                }
                                            }
                                        }

                                        if (isValid) {
                                            isDiff = dataValue !== dataDiffValue;

                                            if (isDiff)
                                                validatedOptions[prop] = dataValue;

                                            if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff)
                                                validatedOptionsPrepared[prop] = isRestrictedValue ? mainPossibility : dataValue;
                                        }
                                        else if (writeErrors) {
                                            console.warn(error + " it doesn't accept the type [ " + dataValueType.toUpperCase() + " ] with the value of \"" + dataValue + "\".\r\n" +
                                                "Accepted types are: [ " + errorPossibleTypes.join(', ').toUpperCase() + " ]." +
                                                (errorRestrictedStrings[length] > 0 ? "\r\nValid strings are: [ " + errorRestrictedStrings.join(', ').split(restrictedStringsPossibilitiesSplit).join(', ') + " ]." : ''));
                                        }
                                        delete data[prop];
                                    }
                                }
                            }
                        };
                        checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared);

                        //add values which aren't specified in the template to the finished validated object to prevent them from being discarded
                        /*
                        if(keepForeignProps) {
                            FRAMEWORK.extend(true, validatedOptions, objectCopy);
                            FRAMEWORK.extend(true, validatedOptionsPrepared, objectCopy);
                        }
                        */

                        if (!isEmptyObj(objectCopy) && writeErrors)
                            console.warn('The following options are discarded due to invalidity:\r\n' + window.JSON.stringify(objectCopy, null, 2));

                        return {
                            _default: validatedOptions,
                            _prepared: validatedOptionsPrepared
                        };
                    }
                }
            }());

            /**
             * Initializes the object which contains global information about the plugin and each instance of it.
             */
            function initOverlayScrollbarsStatics() {
                if (!_pluginsGlobals)
                    _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);
                if (!_pluginsAutoUpdateLoop)
                    _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);
            }

            /**
             * The global object for the OverlayScrollbars objects. It contains resources which every OverlayScrollbars object needs. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
             * @param defaultOptions
             * @constructor
             */
            function OverlayScrollbarsGlobals(defaultOptions) {
                var _base = this;
                var strOverflow = 'overflow';
                var strHidden = 'hidden';
                var strScroll = 'scroll';
                var bodyElement = FRAMEWORK('body');
                var scrollbarDummyElement = FRAMEWORK('<div id="os-dummy-scrollbar-size"><div></div></div>');
                var scrollbarDummyElement0 = scrollbarDummyElement[0];
                var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children('div').eq(0));

                bodyElement.append(scrollbarDummyElement);
                scrollbarDummyElement.hide().show(); //fix IE8 bug (incorrect measuring)

                var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);
                var nativeScrollbarIsOverlaid = {
                    x: nativeScrollbarSize.x === 0,
                    y: nativeScrollbarSize.y === 0
                };
                var msie = (function () {
                    var ua = window.navigator.userAgent;
                    var strIndexOf = 'indexOf';
                    var strSubString = 'substring';
                    var msie = ua[strIndexOf]('MSIE ');
                    var trident = ua[strIndexOf]('Trident/');
                    var edge = ua[strIndexOf]('Edge/');
                    var rv = ua[strIndexOf]('rv:');
                    var result;
                    var parseIntFunc = parseInt;

                    // IE 10 or older => return version number
                    if (msie > 0)
                        result = parseIntFunc(ua[strSubString](msie + 5, ua[strIndexOf]('.', msie)), 10);

                    // IE 11 => return version number
                    else if (trident > 0)
                        result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf]('.', rv)), 10);

                    // Edge (IE 12+) => return version number
                    else if (edge > 0)
                        result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf]('.', edge)), 10);

                    // other browser
                    return result;
                })();

                FRAMEWORK.extend(_base, {
                    defaultOptions: defaultOptions,
                    msie: msie,
                    autoUpdateLoop: false,
                    autoUpdateRecommended: !COMPATIBILITY.mO(),
                    nativeScrollbarSize: nativeScrollbarSize,
                    nativeScrollbarIsOverlaid: nativeScrollbarIsOverlaid,
                    nativeScrollbarStyling: (function () {
                        var result = false;
                        scrollbarDummyElement.addClass('os-viewport-native-scrollbars-invisible');
                        try {
                            result = (scrollbarDummyElement.css('scrollbar-width') === 'none' && (msie > 9 || !msie)) || window.getComputedStyle(scrollbarDummyElement0, '::-webkit-scrollbar').getPropertyValue('display') === 'none';
                        } catch (ex) { }

                        //fix opera bug: scrollbar styles will only appear if overflow value is scroll or auto during the activation of the style.
                        //and set overflow to scroll
                        //scrollbarDummyElement.css(strOverflow, strHidden).hide().css(strOverflow, strScroll).show();
                        //return (scrollbarDummyElement0[LEXICON.oH] - scrollbarDummyElement0[LEXICON.cH]) === 0 && (scrollbarDummyElement0[LEXICON.oW] - scrollbarDummyElement0[LEXICON.cW]) === 0;

                        return result;
                    })(),
                    overlayScrollbarDummySize: { x: 30, y: 30 },
                    cssCalc: VENDORS._cssPropertyValue('width', 'calc', '(1px)') || null,
                    restrictedMeasuring: (function () {
                        //https://bugzilla.mozilla.org/show_bug.cgi?id=1439305
                        //since 1.11.0 always false -> fixed via CSS (hopefully)
                        scrollbarDummyElement.css(strOverflow, strHidden);
                        var scrollSize = {
                            w: scrollbarDummyElement0[LEXICON.sW],
                            h: scrollbarDummyElement0[LEXICON.sH]
                        };
                        scrollbarDummyElement.css(strOverflow, 'visible');
                        var scrollSize2 = {
                            w: scrollbarDummyElement0[LEXICON.sW],
                            h: scrollbarDummyElement0[LEXICON.sH]
                        };
                        return (scrollSize.w - scrollSize2.w) !== 0 || (scrollSize.h - scrollSize2.h) !== 0;
                    })(),
                    rtlScrollBehavior: (function () {
                        scrollbarDummyElement.css({ 'overflow-y': strHidden, 'overflow-x': strScroll, 'direction': 'rtl' }).scrollLeft(0);
                        var dummyContainerOffset = scrollbarDummyElement.offset();
                        var dummyContainerChildOffset = dummyContainerChild.offset();
                        //https://github.com/KingSora/OverlayScrollbars/issues/187
                        scrollbarDummyElement.scrollLeft(-999);
                        var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();
                        return {
                            //origin direction = determines if the zero scroll position is on the left or right side
                            //'i' means 'invert' (i === true means that the axis must be inverted to be correct)
                            //true = on the left side
                            //false = on the right side
                            i: dummyContainerOffset.left === dummyContainerChildOffset.left,
                            //negative = determines if the maximum scroll is positive or negative
                            //'n' means 'negate' (n === true means that the axis must be negated to be correct)
                            //true = negative
                            //false = positive
                            n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left
                        };
                    })(),
                    supportTransform: !!VENDORS._cssProperty('transform'),
                    supportTransition: !!VENDORS._cssProperty('transition'),
                    supportPassiveEvents: (function () {
                        var supportsPassive = false;
                        try {
                            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
                                get: function () {
                                    supportsPassive = true;
                                }
                            }));
                        } catch (e) { }
                        return supportsPassive;
                    })(),
                    supportResizeObserver: !!COMPATIBILITY.rO(),
                    supportMutationObserver: !!COMPATIBILITY.mO()
                });

                scrollbarDummyElement.removeAttr(LEXICON.s).remove();

                //Catch zoom event:
                (function () {
                    if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y)
                        return;

                    var abs = MATH.abs;
                    var windowWidth = COMPATIBILITY.wW();
                    var windowHeight = COMPATIBILITY.wH();
                    var windowDpr = getWindowDPR();
                    var onResize = function () {
                        if (INSTANCES().length > 0) {
                            var newW = COMPATIBILITY.wW();
                            var newH = COMPATIBILITY.wH();
                            var deltaW = newW - windowWidth;
                            var deltaH = newH - windowHeight;

                            if (deltaW === 0 && deltaH === 0)
                                return;

                            var deltaWRatio = MATH.round(newW / (windowWidth / 100.0));
                            var deltaHRatio = MATH.round(newH / (windowHeight / 100.0));
                            var absDeltaW = abs(deltaW);
                            var absDeltaH = abs(deltaH);
                            var absDeltaWRatio = abs(deltaWRatio);
                            var absDeltaHRatio = abs(deltaHRatio);
                            var newDPR = getWindowDPR();

                            var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;
                            var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);
                            var dprChanged = newDPR !== windowDpr && windowDpr > 0;
                            var isZoom = deltaIsBigger && difference && dprChanged;
                            var oldScrollbarSize = _base.nativeScrollbarSize;
                            var newScrollbarSize;

                            if (isZoom) {
                                bodyElement.append(scrollbarDummyElement);
                                newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);
                                scrollbarDummyElement.remove();
                                if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {
                                    FRAMEWORK.each(INSTANCES(), function () {
                                        if (INSTANCES(this))
                                            INSTANCES(this).update('zoom');
                                    });
                                }
                            }

                            windowWidth = newW;
                            windowHeight = newH;
                            windowDpr = newDPR;
                        }
                    };

                    function differenceIsBiggerThanOne(valOne, valTwo) {
                        var absValOne = abs(valOne);
                        var absValTwo = abs(valTwo);
                        return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);
                    }

                    function getWindowDPR() {
                        var dDPI = window.screen.deviceXDPI || 0;
                        var sDPI = window.screen.logicalXDPI || 1;
                        return window.devicePixelRatio || (dDPI / sDPI);
                    }

                    FRAMEWORK(window).on('resize', onResize);
                })();

                function calcNativeScrollbarSize(measureElement) {
                    return {
                        x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],
                        y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]
                    };
                }
            }

            /**
             * The object which manages the auto update loop for all OverlayScrollbars objects. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
             * @constructor
             */
            function OverlayScrollbarsAutoUpdateLoop(globals) {
                var _base = this;
                var _inArray = FRAMEWORK.inArray;
                var _getNow = COMPATIBILITY.now;
                var _strAutoUpdate = 'autoUpdate';
                var _strAutoUpdateInterval = _strAutoUpdate + 'Interval';
                var _strLength = LEXICON.l;
                var _loopingInstances = [];
                var _loopingInstancesIntervalCache = [];
                var _loopIsActive = false;
                var _loopIntervalDefault = 33;
                var _loopInterval = _loopIntervalDefault;
                var _loopTimeOld = _getNow();
                var _loopID;


                /**
                 * The auto update loop which will run every 50 milliseconds or less if the update interval of a instance is lower than 50 milliseconds.
                 */
                var loop = function () {
                    if (_loopingInstances[_strLength] > 0 && _loopIsActive) {
                        _loopID = COMPATIBILITY.rAF()(function () {
                            loop();
                        });
                        var timeNew = _getNow();
                        var timeDelta = timeNew - _loopTimeOld;
                        var lowestInterval;
                        var instance;
                        var instanceOptions;
                        var instanceAutoUpdateAllowed;
                        var instanceAutoUpdateInterval;
                        var now;

                        if (timeDelta > _loopInterval) {
                            _loopTimeOld = timeNew - (timeDelta % _loopInterval);
                            lowestInterval = _loopIntervalDefault;
                            for (var i = 0; i < _loopingInstances[_strLength]; i++) {
                                instance = _loopingInstances[i];
                                if (instance !== undefined) {
                                    instanceOptions = instance.options();
                                    instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];
                                    instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);
                                    now = _getNow();

                                    if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && (now - _loopingInstancesIntervalCache[i]) > instanceAutoUpdateInterval) {
                                        instance.update('auto');
                                        _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval);
                                    }

                                    lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));
                                }
                            }
                            _loopInterval = lowestInterval;
                        }
                    } else {
                        _loopInterval = _loopIntervalDefault;
                    }
                };

                /**
                 * Add OverlayScrollbars instance to the auto update loop. Only successful if the instance isn't already added.
                 * @param instance The instance which shall be updated in a loop automatically.
                 */
                _base.add = function (instance) {
                    if (_inArray(instance, _loopingInstances) === -1) {
                        _loopingInstances.push(instance);
                        _loopingInstancesIntervalCache.push(_getNow());
                        if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {
                            _loopIsActive = true;
                            globals.autoUpdateLoop = _loopIsActive;
                            loop();
                        }
                    }
                };

                /**
                 * Remove OverlayScrollbars instance from the auto update loop. Only successful if the instance was added before.
                 * @param instance The instance which shall be updated in a loop automatically.
                 */
                _base.remove = function (instance) {
                    var index = _inArray(instance, _loopingInstances);
                    if (index > -1) {
                        //remove from loopingInstances list
                        _loopingInstancesIntervalCache.splice(index, 1);
                        _loopingInstances.splice(index, 1);

                        //correct update loop behavior
                        if (_loopingInstances[_strLength] === 0 && _loopIsActive) {
                            _loopIsActive = false;
                            globals.autoUpdateLoop = _loopIsActive;
                            if (_loopID !== undefined) {
                                COMPATIBILITY.cAF()(_loopID);
                                _loopID = -1;
                            }
                        }
                    }
                };
            }

            /**
             * A object which manages the scrollbars visibility of the target element.
             * @param pluginTargetElement The element from which the scrollbars shall be hidden.
             * @param options The custom options.
             * @param extensions The custom extensions.
             * @param globals
             * @param autoUpdateLoop
             * @returns {*}
             * @constructor
             */
            function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {
                //shortcuts
                var type = COMPATIBILITY.type;
                var inArray = FRAMEWORK.inArray;
                var each = FRAMEWORK.each;

                //make correct instanceof
                var _base = new _plugin();
                var _frameworkProto = FRAMEWORK[LEXICON.p];

                //if passed element is no HTML element: skip and return
                if (!isHTMLElement(pluginTargetElement))
                    return;

                //if passed element is already initialized: set passed options if there are any and return its instance
                if (INSTANCES(pluginTargetElement)) {
                    var inst = INSTANCES(pluginTargetElement);
                    inst.options(options);
                    return inst;
                }

                //globals:
                var _nativeScrollbarIsOverlaid;
                var _overlayScrollbarDummySize;
                var _rtlScrollBehavior;
                var _autoUpdateRecommended;
                var _msieVersion;
                var _nativeScrollbarStyling;
                var _cssCalc;
                var _nativeScrollbarSize;
                var _supportTransition;
                var _supportTransform;
                var _supportPassiveEvents;
                var _supportResizeObserver;
                var _supportMutationObserver;
                var _restrictedMeasuring;

                //general readonly:
                var _initialized;
                var _destroyed;
                var _isTextarea;
                var _isBody;
                var _documentMixed;
                var _domExists;

                //general:
                var _isBorderBox;
                var _sizeAutoObserverAdded;
                var _paddingX;
                var _paddingY;
                var _borderX;
                var _borderY;
                var _marginX;
                var _marginY;
                var _isRTL;
                var _sleeping;
                var _contentBorderSize = {};
                var _scrollHorizontalInfo = {};
                var _scrollVerticalInfo = {};
                var _viewportSize = {};
                var _nativeScrollbarMinSize = {};

                //naming:
                var _strMinusHidden = '-hidden';
                var _strMarginMinus = 'margin-';
                var _strPaddingMinus = 'padding-';
                var _strBorderMinus = 'border-';
                var _strTop = 'top';
                var _strRight = 'right';
                var _strBottom = 'bottom';
                var _strLeft = 'left';
                var _strMinMinus = 'min-';
                var _strMaxMinus = 'max-';
                var _strWidth = 'width';
                var _strHeight = 'height';
                var _strFloat = 'float';
                var _strEmpty = '';
                var _strAuto = 'auto';
                var _strSync = 'sync';
                var _strScroll = 'scroll';
                var _strHundredPercent = '100%';
                var _strX = 'x';
                var _strY = 'y';
                var _strDot = '.';
                var _strSpace = ' ';
                var _strScrollbar = 'scrollbar';
                var _strMinusHorizontal = '-horizontal';
                var _strMinusVertical = '-vertical';
                var _strScrollLeft = _strScroll + 'Left';
                var _strScrollTop = _strScroll + 'Top';
                var _strMouseTouchDownEvent = 'mousedown touchstart';
                var _strMouseTouchUpEvent = 'mouseup touchend touchcancel';
                var _strMouseTouchMoveEvent = 'mousemove touchmove';
                var _strMouseEnter = 'mouseenter';
                var _strMouseLeave = 'mouseleave';
                var _strKeyDownEvent = 'keydown';
                var _strKeyUpEvent = 'keyup';
                var _strSelectStartEvent = 'selectstart';
                var _strTransitionEndEvent = 'transitionend webkitTransitionEnd oTransitionEnd';
                var _strResizeObserverProperty = '__overlayScrollbarsRO__';

                //class names:
                var _cassNamesPrefix = 'os-';
                var _classNameHTMLElement = _cassNamesPrefix + 'html';
                var _classNameHostElement = _cassNamesPrefix + 'host';
                var _classNameHostElementForeign = _classNameHostElement + '-foreign';
                var _classNameHostTextareaElement = _classNameHostElement + '-textarea';
                var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusHorizontal + _strMinusHidden;
                var _classNameHostScrollbarVerticalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusVertical + _strMinusHidden;
                var _classNameHostTransition = _classNameHostElement + '-transition';
                var _classNameHostRTL = _classNameHostElement + '-rtl';
                var _classNameHostResizeDisabled = _classNameHostElement + '-resize-disabled';
                var _classNameHostScrolling = _classNameHostElement + '-scrolling';
                var _classNameHostOverflow = _classNameHostElement + '-overflow';
                var _classNameHostOverflow = _classNameHostElement + '-overflow';
                var _classNameHostOverflowX = _classNameHostOverflow + '-x';
                var _classNameHostOverflowY = _classNameHostOverflow + '-y';
                var _classNameTextareaElement = _cassNamesPrefix + 'textarea';
                var _classNameTextareaCoverElement = _classNameTextareaElement + '-cover';
                var _classNamePaddingElement = _cassNamesPrefix + 'padding';
                var _classNameViewportElement = _cassNamesPrefix + 'viewport';
                var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + '-native-scrollbars-invisible';
                var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + '-native-scrollbars-overlaid';
                var _classNameContentElement = _cassNamesPrefix + 'content';
                var _classNameContentArrangeElement = _cassNamesPrefix + 'content-arrange';
                var _classNameContentGlueElement = _cassNamesPrefix + 'content-glue';
                var _classNameSizeAutoObserverElement = _cassNamesPrefix + 'size-auto-observer';
                var _classNameResizeObserverElement = _cassNamesPrefix + 'resize-observer';
                var _classNameResizeObserverItemElement = _cassNamesPrefix + 'resize-observer-item';
                var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + '-final';
                var _classNameTextInherit = _cassNamesPrefix + 'text-inherit';
                var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;
                var _classNameScrollbarTrack = _classNameScrollbar + '-track';
                var _classNameScrollbarTrackOff = _classNameScrollbarTrack + '-off';
                var _classNameScrollbarHandle = _classNameScrollbar + '-handle';
                var _classNameScrollbarHandleOff = _classNameScrollbarHandle + '-off';
                var _classNameScrollbarUnusable = _classNameScrollbar + '-unusable';
                var _classNameScrollbarAutoHidden = _classNameScrollbar + '-' + _strAuto + _strMinusHidden;
                var _classNameScrollbarCorner = _classNameScrollbar + '-corner';
                var _classNameScrollbarCornerResize = _classNameScrollbarCorner + '-resize';
                var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + '-both';
                var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;
                var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;
                var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;
                var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;
                var _classNameDragging = _cassNamesPrefix + 'dragging';
                var _classNameThemeNone = _cassNamesPrefix + 'theme-none';
                var _classNamesDynamicDestroy = [
                    _classNameViewportNativeScrollbarsInvisible,
                    _classNameViewportNativeScrollbarsOverlaid,
                    _classNameScrollbarTrackOff,
                    _classNameScrollbarHandleOff,
                    _classNameScrollbarUnusable,
                    _classNameScrollbarAutoHidden,
                    _classNameScrollbarCornerResize,
                    _classNameScrollbarCornerResizeB,
                    _classNameScrollbarCornerResizeH,
                    _classNameScrollbarCornerResizeV,
                    _classNameDragging].join(_strSpace);

                //callbacks:
                var _callbacksInitQeueue = [];

                //attrs viewport shall inherit from target
                var _viewportAttrsFromTarget = [LEXICON.ti];

                //options:
                var _defaultOptions;
                var _currentOptions;
                var _currentPreparedOptions;

                //extensions:
                var _extensions = {};
                var _extensionsPrivateMethods = 'added removed on contract';

                //update
                var _lastUpdateTime;
                var _swallowedUpdateHints = {};
                var _swallowedUpdateTimeout;
                var _swallowUpdateLag = 42;
                var _updateOnLoadEventName = 'load';
                var _updateOnLoadElms = [];

                //DOM elements:
                var _windowElement;
                var _documentElement;
                var _htmlElement;
                var _bodyElement;
                var _targetElement;                     //the target element of this OverlayScrollbars object
                var _hostElement;                       //the host element of this OverlayScrollbars object -> may be the same as targetElement
                var _sizeAutoObserverElement;           //observes size auto changes
                var _sizeObserverElement;               //observes size and padding changes
                var _paddingElement;                    //manages the padding
                var _viewportElement;                   //is the viewport of our scrollbar model
                var _contentElement;                    //the element which holds the content
                var _contentArrangeElement;             //is needed for correct sizing of the content element (only if native scrollbars are overlays)
                var _contentGlueElement;                //has always the size of the content element
                var _textareaCoverElement;              //only applied if target is a textarea element. Used for correct size calculation and for prevention of uncontrolled scrolling
                var _scrollbarCornerElement;
                var _scrollbarHorizontalElement;
                var _scrollbarHorizontalTrackElement;
                var _scrollbarHorizontalHandleElement;
                var _scrollbarVerticalElement;
                var _scrollbarVerticalTrackElement;
                var _scrollbarVerticalHandleElement;
                var _windowElementNative;
                var _documentElementNative;
                var _targetElementNative;
                var _hostElementNative;
                var _sizeAutoObserverElementNative;
                var _sizeObserverElementNative;
                var _paddingElementNative;
                var _viewportElementNative;
                var _contentElementNative;

                //Cache:
                var _hostSizeCache;
                var _contentScrollSizeCache;
                var _arrangeContentSizeCache;
                var _hasOverflowCache;
                var _hideOverflowCache;
                var _widthAutoCache;
                var _heightAutoCache;
                var _cssBoxSizingCache;
                var _cssPaddingCache;
                var _cssBorderCache;
                var _cssMarginCache;
                var _cssDirectionCache;
                var _cssDirectionDetectedCache;
                var _paddingAbsoluteCache;
                var _clipAlwaysCache;
                var _contentGlueSizeCache;
                var _overflowBehaviorCache;
                var _overflowAmountCache;
                var _ignoreOverlayScrollbarHidingCache;
                var _autoUpdateCache;
                var _sizeAutoCapableCache;
                var _contentElementScrollSizeChangeDetectedCache;
                var _hostElementSizeChangeDetectedCache;
                var _scrollbarsVisibilityCache;
                var _scrollbarsAutoHideCache;
                var _scrollbarsClickScrollingCache;
                var _scrollbarsDragScrollingCache;
                var _resizeCache;
                var _normalizeRTLCache;
                var _classNameCache;
                var _oldClassName;
                var _textareaAutoWrappingCache;
                var _textareaInfoCache;
                var _textareaSizeCache;
                var _textareaDynHeightCache;
                var _textareaDynWidthCache;
                var _bodyMinSizeCache;
                var _updateAutoCache = {};

                //MutationObserver:
                var _mutationObserverHost;
                var _mutationObserverContent;
                var _mutationObserverHostCallback;
                var _mutationObserverContentCallback;
                var _mutationObserversConnected;
                var _mutationObserverAttrsTextarea = ['wrap', 'cols', 'rows'];
                var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, 'open'].concat(_viewportAttrsFromTarget);

                //events:
                var _destroyEvents = [];

                //textarea:
                var _textareaHasFocus;

                //scrollbars:
                var _scrollbarsAutoHideTimeoutId;
                var _scrollbarsAutoHideMoveTimeoutId;
                var _scrollbarsAutoHideDelay;
                var _scrollbarsAutoHideNever;
                var _scrollbarsAutoHideScroll;
                var _scrollbarsAutoHideMove;
                var _scrollbarsAutoHideLeave;
                var _scrollbarsHandleHovered;
                var _scrollbarsHandlesDefineScrollPos;

                //resize
                var _resizeNone;
                var _resizeBoth;
                var _resizeHorizontal;
                var _resizeVertical;


                //==== Event Listener ====//

                /**
                 * Adds or removes a event listener from the given element.
                 * @param element The element to which the event listener shall be applied or removed.
                 * @param eventNames The name(s) of the events.
                 * @param listener The method which shall be called.
                 * @param remove True if the handler shall be removed, false or undefined if the handler shall be added.
                 * @param passiveOrOptions The options for the event.
                 */
                function setupResponsiveEventListener(element, eventNames, listener, remove, passiveOrOptions) {
                    var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);
                    var method = remove ? 'removeEventListener' : 'addEventListener';
                    var onOff = remove ? 'off' : 'on';
                    var events = collected ? false : eventNames.split(_strSpace)
                    var i = 0;

                    var passiveOrOptionsIsObj = FRAMEWORK.isPlainObject(passiveOrOptions);
                    var passive = (_supportPassiveEvents && (passiveOrOptionsIsObj ? (passiveOrOptions._passive) : passiveOrOptions)) || false;
                    var capture = passiveOrOptionsIsObj && (passiveOrOptions._capture || false);
                    var nativeParam = _supportPassiveEvents ? {
                        passive: passive,
                        capture: capture,
                    } : capture;

                    if (collected) {
                        for (; i < eventNames[LEXICON.l]; i++)
                            setupResponsiveEventListener(element, eventNames[i], listener[i], remove, passiveOrOptions);
                    }
                    else {
                        for (; i < events[LEXICON.l]; i++) {
                            if(_supportPassiveEvents) {
                                element[0][method](events[i], listener, nativeParam);
                            }
                            else {
                                element[onOff](events[i], listener);
                            }
                        }
                    }
                }


                function addDestroyEventListener(element, eventNames, listener, passive) {
                    setupResponsiveEventListener(element, eventNames, listener, false, passive);
                    _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));
                }

                //==== Resize Observer ====//

                /**
                 * Adds or removes a resize observer from the given element.
                 * @param targetElement The element to which the resize observer shall be added or removed.
                 * @param onElementResizedCallback The callback which is fired every time the resize observer registers a size change or false / undefined if the resizeObserver shall be removed.
                 */
                function setupResizeObserver(targetElement, onElementResizedCallback) {
                    if (targetElement) {
                        var resizeObserver = COMPATIBILITY.rO();
                        var strAnimationStartEvent = 'animationstart mozAnimationStart webkitAnimationStart MSAnimationStart';
                        var strChildNodes = 'childNodes';
                        var constScroll = 3333333;
                        var callback = function () {
                            targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);
                            onElementResizedCallback();
                        };
                        //add resize observer:
                        if (onElementResizedCallback) {
                            if (_supportResizeObserver) {
                                var element = targetElement.addClass('observed').append(generateDiv(_classNameResizeObserverElement)).contents()[0];
                                var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);
                                observer.observe(element);
                            }
                            else {
                                if (_msieVersion > 9 || !_autoUpdateRecommended) {
                                    targetElement.prepend(
                                        generateDiv(_classNameResizeObserverElement,
                                            generateDiv({ c: _classNameResizeObserverItemElement, dir: 'ltr' },
                                                generateDiv(_classNameResizeObserverItemElement,
                                                    generateDiv(_classNameResizeObserverItemFinalElement)
                                                ) +
                                                generateDiv(_classNameResizeObserverItemElement,
                                                    generateDiv({ c: _classNameResizeObserverItemFinalElement, style: 'width: 200%; height: 200%' })
                                                )
                                            )
                                        )
                                    );

                                    var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];
                                    var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);
                                    var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);
                                    var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);
                                    var widthCache = observerElement[LEXICON.oW];
                                    var heightCache = observerElement[LEXICON.oH];
                                    var isDirty;
                                    var rAFId;
                                    var currWidth;
                                    var currHeight;
                                    var factor = 2;
                                    var nativeScrollbarSize = globals.nativeScrollbarSize; //care don't make changes to this object!!!
                                    var reset = function () {
                                        /*
                                         var sizeResetWidth = observerElement[LEXICON.oW] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                                         var sizeResetHeight = observerElement[LEXICON.oH] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                                         var expandChildCSS = {};
                                         expandChildCSS[_strWidth] = sizeResetWidth;
                                         expandChildCSS[_strHeight] = sizeResetHeight;
                                         expandElementChild.css(expandChildCSS);


                                         expandElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                                         shrinkElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                                         */
                                        expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                                        shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                                    };
                                    var onResized = function () {
                                        rAFId = 0;
                                        if (!isDirty)
                                            return;

                                        widthCache = currWidth;
                                        heightCache = currHeight;
                                        callback();
                                    };
                                    var onScroll = function (event) {
                                        currWidth = observerElement[LEXICON.oW];
                                        currHeight = observerElement[LEXICON.oH];
                                        isDirty = currWidth != widthCache || currHeight != heightCache;

                                        if (event && isDirty && !rAFId) {
                                            COMPATIBILITY.cAF()(rAFId);
                                            rAFId = COMPATIBILITY.rAF()(onResized);
                                        }
                                        else if (!event)
                                            onResized();

                                        reset();
                                        if (event) {
                                            COMPATIBILITY.prvD(event);
                                            COMPATIBILITY.stpP(event);
                                        }
                                        return false;
                                    };
                                    var expandChildCSS = {};
                                    var observerElementCSS = {};

                                    setTopRightBottomLeft(observerElementCSS, _strEmpty, [
                                        -((nativeScrollbarSize.y + 1) * factor),
                                        nativeScrollbarSize.x * -factor,
                                        nativeScrollbarSize.y * -factor,
                                        -((nativeScrollbarSize.x + 1) * factor)
                                    ]);

                                    FRAMEWORK(observerElement).css(observerElementCSS);
                                    expandElement.on(_strScroll, onScroll);
                                    shrinkElement.on(_strScroll, onScroll);
                                    targetElement.on(strAnimationStartEvent, function () {
                                        onScroll(false);
                                    });
                                    //lets assume that the divs will never be that large and a constant value is enough
                                    expandChildCSS[_strWidth] = constScroll;
                                    expandChildCSS[_strHeight] = constScroll;
                                    expandElementChild.css(expandChildCSS);

                                    reset();
                                }
                                else {
                                    var attachEvent = _documentElementNative.attachEvent;
                                    var isIE = _msieVersion !== undefined;
                                    if (attachEvent) {
                                        targetElement.prepend(generateDiv(_classNameResizeObserverElement));
                                        findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent('onresize', callback);
                                    }
                                    else {
                                        var obj = _documentElementNative.createElement(TYPES.o);
                                        obj.setAttribute(LEXICON.ti, '-1');
                                        obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);
                                        obj.onload = function () {
                                            var wnd = this.contentDocument.defaultView;
                                            wnd.addEventListener('resize', callback);
                                            wnd.document.documentElement.style.display = 'none';
                                        };
                                        obj.type = 'text/html';
                                        if (isIE)
                                            targetElement.prepend(obj);
                                        obj.data = 'about:blank';
                                        if (!isIE)
                                            targetElement.prepend(obj);
                                        targetElement.on(strAnimationStartEvent, callback);
                                    }
                                }
                            }

                            if (targetElement[0] === _sizeObserverElementNative) {
                                var directionChanged = function () {
                                    var dir = _hostElement.css('direction');
                                    var css = {};
                                    var scrollLeftValue = 0;
                                    var result = false;
                                    if (dir !== _cssDirectionDetectedCache) {
                                        if (dir === 'ltr') {
                                            css[_strLeft] = 0;
                                            css[_strRight] = _strAuto;
                                            scrollLeftValue = constScroll;
                                        }
                                        else {
                                            css[_strLeft] = _strAuto;
                                            css[_strRight] = 0;
                                            scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;
                                        }
                                        //execution order is important for IE!!!
                                        _sizeObserverElement.children().eq(0).css(css);
                                        _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);
                                        _cssDirectionDetectedCache = dir;
                                        result = true;
                                    }
                                    return result;
                                };
                                directionChanged();
                                addDestroyEventListener(targetElement, _strScroll, function (event) {
                                    if (directionChanged())
                                        update();
                                    COMPATIBILITY.prvD(event);
                                    COMPATIBILITY.stpP(event);
                                    return false;
                                });
                            }
                        }
                        //remove resize observer:
                        else {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                var resizeObserverObj = element[_strResizeObserverProperty];
                                if (resizeObserverObj) {
                                    resizeObserverObj.disconnect();
                                    delete element[_strResizeObserverProperty];
                                }
                            }
                            else {
                                remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));
                            }
                        }
                    }
                }

                /**
                 * Freezes or unfreezes the given resize observer.
                 * @param targetElement The element to which the target resize observer is applied.
                 * @param freeze True if the resize observer shall be frozen, false otherwise.

                function freezeResizeObserver(targetElement, freeze) {
                    if (targetElement !== undefined) {
                        if(freeze) {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                element[_strResizeObserverProperty].unobserve(element);
                            }
                            else {
                                targetElement = targetElement.children(_strDot + _classNameResizeObserverElement).eq(0);
                                var w = targetElement.css(_strWidth);
                                var h = targetElement.css(_strHeight);
                                var css = {};
                                css[_strWidth] = w;
                                css[_strHeight] = h;
                                targetElement.css(css);
                            }
                        }
                        else {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                element[_strResizeObserverProperty].observe(element);
                            }
                            else {
                                var css = { };
                                css[_strHeight] = _strEmpty;
                                css[_strWidth] = _strEmpty;
                                targetElement.children(_strDot + _classNameResizeObserverElement).eq(0).css(css);
                            }
                        }
                    }
                }
                */


                //==== Mutation Observers ====//

                /**
                 * Creates MutationObservers for the host and content Element if they are supported.
                 */
                function createMutationObservers() {
                    if (_supportMutationObserver) {
                        var mutationObserverContentLag = 11;
                        var mutationObserver = COMPATIBILITY.mO();
                        var contentLastUpdate = COMPATIBILITY.now();
                        var mutationTarget;
                        var mutationAttrName;
                        var mutationIsClass;
                        var oldMutationVal;
                        var newClassVal;
                        var hostClassNameRegex;
                        var contentTimeout;
                        var now;
                        var sizeAuto;
                        var action;

                        _mutationObserverHostCallback = function (mutations) {

                            var doUpdate = false;
                            var doUpdateForce = false;
                            var mutation;
                            var mutatedAttrs = [];

                            if (_initialized && !_sleeping) {
                                each(mutations, function () {
                                    mutation = this;
                                    mutationTarget = mutation.target;
                                    mutationAttrName = mutation.attributeName;
                                    mutationIsClass = mutationAttrName === LEXICON.c;
                                    oldMutationVal = mutation.oldValue;
                                    newClassVal = mutationTarget.className;

                                    if (_domExists && mutationIsClass && !doUpdateForce) {
                                        // if old class value contains _classNameHostElementForeign and new class value doesn't
                                        if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {
                                            hostClassNameRegex = createHostClassNameRegExp(true);
                                            _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function (name) {
                                                return name.match(hostClassNameRegex);
                                            })).join(_strSpace);
                                            doUpdate = doUpdateForce = true;
                                        }
                                    }

                                    if (!doUpdate) {
                                        doUpdate = mutationIsClass
                                            ? hostClassNamesChanged(oldMutationVal, newClassVal)
                                            : mutationAttrName === LEXICON.s
                                                ? oldMutationVal !== mutationTarget[LEXICON.s].cssText
                                                : true;
                                    }

                                    mutatedAttrs.push(mutationAttrName);
                                });

                                updateViewportAttrsFromTarget(mutatedAttrs);

                                if (doUpdate)
                                    _base.update(doUpdateForce || _strAuto);
                            }
                            return doUpdate;
                        };
                        _mutationObserverContentCallback = function (mutations) {
                            var doUpdate = false;
                            var mutation;

                            if (_initialized && !_sleeping) {
                                each(mutations, function () {
                                    mutation = this;
                                    doUpdate = isUnknownMutation(mutation);
                                    return !doUpdate;
                                });

                                if (doUpdate) {
                                    now = COMPATIBILITY.now();
                                    sizeAuto = (_heightAutoCache || _widthAutoCache);
                                    action = function () {
                                        if (!_destroyed) {
                                            contentLastUpdate = now;

                                            //if cols, rows or wrap attr was changed
                                            if (_isTextarea)
                                                textareaUpdate();

                                            if (sizeAuto)
                                                update();
                                            else
                                                _base.update(_strAuto);
                                        }
                                    };
                                    clearTimeout(contentTimeout);
                                    if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto)
                                        action();
                                    else
                                        contentTimeout = setTimeout(action, mutationObserverContentLag);
                                }
                            }
                            return doUpdate;
                        }

                        _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);
                        _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);
                    }
                }

                /**
                 * Connects the MutationObservers if they are supported.
                 */
                function connectMutationObservers() {
                    if (_supportMutationObserver && !_mutationObserversConnected) {
                        _mutationObserverHost.observe(_hostElementNative, {
                            attributes: true,
                            attributeOldValue: true,
                            attributeFilter: _mutationObserverAttrsHost
                        });

                        _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {
                            attributes: true,
                            attributeOldValue: true,
                            subtree: !_isTextarea,
                            childList: !_isTextarea,
                            characterData: !_isTextarea,
                            attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost
                        });

                        _mutationObserversConnected = true;
                    }
                }

                /**
                 * Disconnects the MutationObservers if they are supported.
                 */
                function disconnectMutationObservers() {
                    if (_supportMutationObserver && _mutationObserversConnected) {
                        _mutationObserverHost.disconnect();
                        _mutationObserverContent.disconnect();

                        _mutationObserversConnected = false;
                    }
                }


                //==== Events of elements ====//

                /**
                 * This method gets called every time the host element gets resized. IMPORTANT: Padding changes are detected too!!
                 * It refreshes the hostResizedEventArgs and the hostSizeResizeCache.
                 * If there are any size changes, the update method gets called.
                 */
                function hostOnResized() {
                    if (!_sleeping) {
                        var changed;
                        var hostSize = {
                            w: _sizeObserverElementNative[LEXICON.sW],
                            h: _sizeObserverElementNative[LEXICON.sH]
                        };

                        changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);
                        _hostElementSizeChangeDetectedCache = hostSize;
                        if (changed)
                            update({ _hostSizeChanged: true });
                    }
                }

                /**
                 * The mouse enter event of the host element. This event is only needed for the autoHide feature.
                 */
                function hostOnMouseEnter() {
                    if (_scrollbarsAutoHideLeave)
                        refreshScrollbarsAutoHide(true);
                }

                /**
                 * The mouse leave event of the host element. This event is only needed for the autoHide feature.
                 */
                function hostOnMouseLeave() {
                    if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging))
                        refreshScrollbarsAutoHide(false);
                }

                /**
                 * The mouse move event of the host element. This event is only needed for the autoHide "move" feature.
                 */
                function hostOnMouseMove() {
                    if (_scrollbarsAutoHideMove) {
                        refreshScrollbarsAutoHide(true);
                        clearTimeout(_scrollbarsAutoHideMoveTimeoutId);
                        _scrollbarsAutoHideMoveTimeoutId = setTimeout(function () {
                            if (_scrollbarsAutoHideMove && !_destroyed)
                                refreshScrollbarsAutoHide(false);
                        }, 100);
                    }
                }

                /**
                 * Prevents text from deselection if attached to the document element on the mousedown event of a DOM element.
                 * @param event The select start event.
                 */
                function documentOnSelectStart(event) {
                    COMPATIBILITY.prvD(event);
                    return false;
                }

                /**
                 * A callback which will be called after a element has loaded.
                 */
                function updateOnLoadCallback(event) {
					if (!_destroyed) {
						var target = event.target;
						var elm = FRAMEWORK(event.target);
						var index = FRAMEWORK.inArray(target, _updateOnLoadElms);
						if (index > -1) {
							_updateOnLoadElms.splice(index, 1);
						}

						eachUpdateOnLoad(function (i, updateOnLoadSelector) {
							if (elm.is(updateOnLoadSelector)) {
								update({ _contentSizeChanged: true });
							}
						});
					}
                }

                /**
                * Adds or removes mouse & touch events of the host element. (for handling auto-hiding of the scrollbars)
                * @param destroy Indicates whether the events shall be added or removed.
                */
                function setupHostMouseTouchEvents(destroy) {
                    if (!destroy)
                        setupHostMouseTouchEvents(true);

                    setupResponsiveEventListener(_hostElement,
                        _strMouseTouchMoveEvent.split(_strSpace)[0],
                        hostOnMouseMove,
                        (!_scrollbarsAutoHideMove || destroy), true);
                    setupResponsiveEventListener(_hostElement,
                        [_strMouseEnter, _strMouseLeave],
                        [hostOnMouseEnter, hostOnMouseLeave],
                        (!_scrollbarsAutoHideLeave || destroy), true);

                    //if the plugin is initialized and the mouse is over the host element, make the scrollbars visible
                    if (!_initialized && !destroy)
                        _hostElement.one('mouseover', hostOnMouseEnter);
                }


                //==== Update Detection ====//

                /**
                 * Measures the min width and min height of the body element and refreshes the related cache.
                 * @returns {boolean} True if the min width or min height has changed, false otherwise.
                 */
                function bodyMinSizeChanged() {
                    var bodyMinSize = {};
                    if (_isBody && _contentArrangeElement) {
                        bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));
                        bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));
                        bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);
                        bodyMinSize.f = true; //flag for "measured at least once"
                    }
                    _bodyMinSizeCache = bodyMinSize;
                    return !!bodyMinSize.c;
                }

                /**
                 * Returns true if the class names really changed (new class without plugin host prefix)
                 * @param oldClassNames The old ClassName string or array.
                 * @param newClassNames The new ClassName string or array.
                 * @returns {boolean} True if the class names has really changed, false otherwise.
                 */
                function hostClassNamesChanged(oldClassNames, newClassNames) {
                    var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];
                    var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];
                    var diff = getArrayDifferences(oldClasses, currClasses);

                    // remove none theme from diff list to prevent update
                    var idx = inArray(_classNameThemeNone, diff);
                    var i;
                    var regex;

                    if (idx > -1)
                        diff.splice(idx, 1);

                    if (diff[LEXICON.l] > 0) {
                        regex = createHostClassNameRegExp(true, true);
                        for (i = 0; i < diff.length; i++) {
                            if (!diff[i].match(regex)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }

                /**
                 * Returns true if the given mutation is not from a from the plugin generated element. If the target element is a textarea the mutation is always unknown.
                 * @param mutation The mutation which shall be checked.
                 * @returns {boolean} True if the mutation is from a unknown element, false otherwise.
                 */
                function isUnknownMutation(mutation) {
                    var attributeName = mutation.attributeName;
                    var mutationTarget = mutation.target;
                    var mutationType = mutation.type;
                    var strClosest = 'closest';

                    if (mutationTarget === _contentElementNative)
                        return attributeName === null;
                    if (mutationType === 'attributes' && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {
                        //ignore className changes by the plugin
                        if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))
                            return hostClassNamesChanged(mutation.oldValue, mutationTarget.className);

                        //only do it of browser support it natively
                        if (typeof mutationTarget[strClosest] != TYPES.f)
                            return true;
                        if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null ||
                            mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null ||
                            mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null)
                            return false;
                    }
                    return true;
                }

                /**
                 * Returns true if the content size was changed since the last time this method was called.
                 * @returns {boolean} True if the content size was changed, false otherwise.
                 */
                function updateAutoContentSizeChanged() {
                    if (_sleeping)
                        return false;

                    var contentMeasureElement = getContentMeasureElement();
                    var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;
                    var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;
                    var css = {};
                    var float;
                    var bodyMinSizeC;
                    var changed;
                    var contentElementScrollSize;

                    if (setCSS) {
                        float = _contentElement.css(_strFloat);
                        css[_strFloat] = _isRTL ? _strRight : _strLeft;
                        css[_strWidth] = _strAuto;
                        _contentElement.css(css);
                    }
                    contentElementScrollSize = {
                        w: contentMeasureElement[LEXICON.sW] + textareaValueLength,
                        h: contentMeasureElement[LEXICON.sH] + textareaValueLength
                    };
                    if (setCSS) {
                        css[_strFloat] = float;
                        css[_strWidth] = _strHundredPercent;
                        _contentElement.css(css);
                    }

                    bodyMinSizeC = bodyMinSizeChanged();
                    changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);

                    _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;

                    return changed || bodyMinSizeC;
                }

                /**
                 * Returns true when a attribute which the MutationObserver would observe has changed.
                 * @returns {boolean} True if one of the attributes which a MutationObserver would observe has changed, false or undefined otherwise.
                 */
                function meaningfulAttrsChanged() {
                    if (_sleeping || _mutationObserversConnected)
                        return;

                    var elem;
                    var curr;
                    var cache;
                    var changedAttrs = [];
                    var checks = [
                        {
                            _elem: _hostElement,
                            _attrs: _mutationObserverAttrsHost.concat(':visible')
                        },
                        {
                            _elem: _isTextarea ? _targetElement : undefined,
                            _attrs: _mutationObserverAttrsTextarea
                        }
                    ];

                    each(checks, function (index, check) {
                        elem = check._elem;
                        if (elem) {
                            each(check._attrs, function (index, attr) {
                                curr = attr.charAt(0) === ':' ? elem.is(attr) : elem.attr(attr);
                                cache = _updateAutoCache[attr];

                                if (checkCache(curr, cache)) {
                                    changedAttrs.push(attr);
                                }

                                _updateAutoCache[attr] = curr;
                            });
                        }
                    });

                    updateViewportAttrsFromTarget(changedAttrs);

                    return changedAttrs[LEXICON.l] > 0;
                }

                /**
                 * Checks is a CSS Property of a child element is affecting the scroll size of the content.
                 * @param propertyName The CSS property name.
                 * @returns {boolean} True if the property is affecting the content scroll size, false otherwise.
                 */
                function isSizeAffectingCSSProperty(propertyName) {
                    if (!_initialized)
                        return true;
                    var flexGrow = 'flex-grow';
                    var flexShrink = 'flex-shrink';
                    var flexBasis = 'flex-basis';
                    var affectingPropsX = [
                        _strWidth,
                        _strMinMinus + _strWidth,
                        _strMaxMinus + _strWidth,
                        _strMarginMinus + _strLeft,
                        _strMarginMinus + _strRight,
                        _strLeft,
                        _strRight,
                        'font-weight',
                        'word-spacing',
                        flexGrow,
                        flexShrink,
                        flexBasis
                    ];
                    var affectingPropsXContentBox = [
                        _strPaddingMinus + _strLeft,
                        _strPaddingMinus + _strRight,
                        _strBorderMinus + _strLeft + _strWidth,
                        _strBorderMinus + _strRight + _strWidth
                    ];
                    var affectingPropsY = [
                        _strHeight,
                        _strMinMinus + _strHeight,
                        _strMaxMinus + _strHeight,
                        _strMarginMinus + _strTop,
                        _strMarginMinus + _strBottom,
                        _strTop,
                        _strBottom,
                        'line-height',
                        flexGrow,
                        flexShrink,
                        flexBasis
                    ];
                    var affectingPropsYContentBox = [
                        _strPaddingMinus + _strTop,
                        _strPaddingMinus + _strBottom,
                        _strBorderMinus + _strTop + _strWidth,
                        _strBorderMinus + _strBottom + _strWidth
                    ];
                    var _strS = 's';
                    var _strVS = 'v-s';
                    var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;
                    var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;
                    var sizeIsAffected = false;
                    var checkPropertyName = function (arr, name) {
                        for (var i = 0; i < arr[LEXICON.l]; i++) {
                            if (arr[i] === name)
                                return true;
                        }
                        return false;
                    };

                    if (checkY) {
                        sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);
                        if (!sizeIsAffected && !_isBorderBox)
                            sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);
                    }
                    if (checkX && !sizeIsAffected) {
                        sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);
                        if (!sizeIsAffected && !_isBorderBox)
                            sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);
                    }
                    return sizeIsAffected;
                }


                //==== Update ====//

                /**
                 * Sets the attribute values of the viewport element to the values from the target element.
                 * The value of a attribute is only set if the attribute is whitelisted.
                 * @attrs attrs The array of attributes which shall be set or undefined if all whitelisted shall be set.
                 */
                function updateViewportAttrsFromTarget(attrs) {
                    attrs = attrs || _viewportAttrsFromTarget;
                    each(attrs, function (index, attr) {
                        if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {
                            var targetAttr = _targetElement.attr(attr);
                            if (type(targetAttr) == TYPES.s) {
                                _viewportElement.attr(attr, targetAttr);
                            }
                            else {
                                _viewportElement.removeAttr(attr);
                            }
                        }
                    });
                }

                /**
                 * Updates the variables and size of the textarea element, and manages the scroll on new line or new character.
                 */
                function textareaUpdate() {
                    if (!_sleeping) {
                        var wrapAttrOff = !_textareaAutoWrappingCache;
                        var minWidth = _viewportSize.w;
                        var minHeight = _viewportSize.h;
                        var css = {};
                        var doMeasure = _widthAutoCache || wrapAttrOff;
                        var origWidth;
                        var width;
                        var origHeight;
                        var height;

                        //reset min size
                        css[_strMinMinus + _strWidth] = _strEmpty;
                        css[_strMinMinus + _strHeight] = _strEmpty;

                        //set width auto
                        css[_strWidth] = _strAuto;
                        _targetElement.css(css);

                        //measure width
                        origWidth = _targetElementNative[LEXICON.oW];
                        width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;
                        /*width += (_widthAutoCache ? _marginX + (!_isBorderBox ? wrapAttrOff ? 0 : _paddingX + _borderX : 0) : 0);*/

                        //set measured width
                        css[_strWidth] = _widthAutoCache ? _strAuto /*width*/ : _strHundredPercent;
                        css[_strMinMinus + _strWidth] = _strHundredPercent;

                        //set height auto
                        css[_strHeight] = _strAuto;
                        _targetElement.css(css);

                        //measure height
                        origHeight = _targetElementNative[LEXICON.oH];
                        height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1);

                        //append correct size values
                        css[_strWidth] = width;
                        css[_strHeight] = height;
                        _textareaCoverElement.css(css);

                        //apply min width / min height to prevent textarea collapsing
                        css[_strMinMinus + _strWidth] = minWidth /*+ (!_isBorderBox && _widthAutoCache ? _paddingX + _borderX : 0)*/;
                        css[_strMinMinus + _strHeight] = minHeight /*+ (!_isBorderBox && _heightAutoCache ? _paddingY + _borderY : 0)*/;
                        _targetElement.css(css);

                        return {
                            _originalWidth: origWidth,
                            _originalHeight: origHeight,
                            _dynamicWidth: width,
                            _dynamicHeight: height
                        };
                    }
                }

                /**
                 * Updates the plugin and DOM to the current options.
                 * This method should only be called if a update is 100% required.
                 * @param updateHints A objects which contains hints for this update:
                 * {
                 *   _hostSizeChanged : boolean,
                 *   _contentSizeChanged : boolean,
                 *   _force : boolean,                             == preventSwallowing
                 *   _changedOptions : { },                        == preventSwallowing && preventSleep
                *  }
                 */
                function update(updateHints) {
                    clearTimeout(_swallowedUpdateTimeout);
                    updateHints = updateHints || {};
                    _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;
                    _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;
                    _swallowedUpdateHints._force |= updateHints._force;

                    var now = COMPATIBILITY.now();
                    var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;
                    var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;
                    var force = !!_swallowedUpdateHints._force;
                    var changedOptions = updateHints._changedOptions;
                    var swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && (now - _lastUpdateTime) < _swallowUpdateLag && (!_heightAutoCache && !_widthAutoCache);
                    var displayIsHidden;

                    if (swallow)
                        _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag);

                    //abort update due to:
                    //destroyed
                    //swallowing
                    //sleeping
                    //host is hidden or has false display
                    if (_destroyed || swallow || (_sleeping && !changedOptions) || (_initialized && !force && (displayIsHidden = _hostElement.is(':hidden'))) || _hostElement.css('display') === 'inline')
                        return;

                    _lastUpdateTime = now;
                    _swallowedUpdateHints = {};

                    //if scrollbar styling is possible and native scrollbars aren't overlaid the scrollbar styling will be applied which hides the native scrollbars completely.
                    if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                        //native scrollbars are hidden, so change the values to zero
                        _nativeScrollbarSize.x = 0;
                        _nativeScrollbarSize.y = 0;
                    }
                    else {
                        //refresh native scrollbar size (in case of zoom)
                        _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                    }

                    // Scrollbar padding is needed for firefox, because firefox hides scrollbar automatically if the size of the div is too small.
                    // The calculation: [scrollbar size +3 *3]
                    // (+3 because of possible decoration e.g. borders, margins etc., but only if native scrollbar is NOT a overlaid scrollbar)
                    // (*3 because (1)increase / (2)decrease -button and (3)resize handle)
                    _nativeScrollbarMinSize = {
                        x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,
                        y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3
                    };

                    changedOptions = changedOptions || {};
                    //freezeResizeObserver(_sizeObserverElement, true);
                    //freezeResizeObserver(_sizeAutoObserverElement, true);

                    var checkCacheAutoForce = function () {
                        return checkCache.apply(this, [].slice.call(arguments).concat([force]));
                    };

                    //save current scroll offset
                    var currScroll = {
                        x: _viewportElement[_strScrollLeft](),
                        y: _viewportElement[_strScrollTop]()
                    };

                    var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;
                    var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea;

                    //scrollbars visibility:
                    var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;
                    var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache);

                    //scrollbars autoHide:
                    var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;
                    var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache);

                    //scrollbars click scrolling
                    var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;
                    var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache);

                    //scrollbars drag scrolling
                    var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;
                    var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache);

                    //className
                    var className = _currentPreparedOptions.className;
                    var classNameChanged = checkCacheAutoForce(className, _classNameCache);

                    //resize
                    var resize = _currentPreparedOptions.resize;
                    var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody; //body can't be resized since the window itself acts as resize possibility.

                    //paddingAbsolute
                    var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;
                    var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache);

                    //clipAlways
                    var clipAlways = _currentPreparedOptions.clipAlways;
                    var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache);

                    //sizeAutoCapable
                    var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody; //body can never be size auto, because it shall be always as big as the viewport.
                    var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache);

                    //showNativeScrollbars
                    var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;
                    var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache);

                    //autoUpdate
                    var autoUpdate = _currentPreparedOptions.autoUpdate;
                    var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache);

                    //overflowBehavior
                    var overflowBehavior = _currentPreparedOptions.overflowBehavior;
                    var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force);

                    //dynWidth:
                    var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;
                    var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth);

                    //dynHeight:
                    var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;
                    var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight);

                    //scrollbars visibility
                    _scrollbarsAutoHideNever = scrollbarsAutoHide === 'n';
                    _scrollbarsAutoHideScroll = scrollbarsAutoHide === 's';
                    _scrollbarsAutoHideMove = scrollbarsAutoHide === 'm';
                    _scrollbarsAutoHideLeave = scrollbarsAutoHide === 'l';

                    //scrollbars autoHideDelay
                    _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay;

                    //old className
                    _oldClassName = _classNameCache;

                    //resize
                    _resizeNone = resize === 'n';
                    _resizeBoth = resize === 'b';
                    _resizeHorizontal = resize === 'h';
                    _resizeVertical = resize === 'v';

                    //normalizeRTL
                    _normalizeRTLCache = _currentPreparedOptions.normalizeRTL;

                    //ignore overlay scrollbar hiding
                    ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);

                    //refresh options cache
                    _scrollbarsVisibilityCache = scrollbarsVisibility;
                    _scrollbarsAutoHideCache = scrollbarsAutoHide;
                    _scrollbarsClickScrollingCache = scrollbarsClickScrolling;
                    _scrollbarsDragScrollingCache = scrollbarsDragScrolling;
                    _classNameCache = className;
                    _resizeCache = resize;
                    _paddingAbsoluteCache = paddingAbsolute;
                    _clipAlwaysCache = clipAlways;
                    _sizeAutoCapableCache = sizeAutoCapable;
                    _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;
                    _autoUpdateCache = autoUpdate;
                    _overflowBehaviorCache = extendDeep({}, overflowBehavior);
                    _textareaDynWidthCache = textareaDynWidth;
                    _textareaDynHeightCache = textareaDynHeight;
                    _hasOverflowCache = _hasOverflowCache || { x: false, y: false };

                    //set correct class name to the host element
                    if (classNameChanged) {
                        removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);
                        addClass(_hostElement, className !== undefined && className !== null && className.length > 0 ? className : _classNameThemeNone);
                    }

                    //set correct auto Update
                    if (autoUpdateChanged) {
                        if (autoUpdate === true || (autoUpdate === null && _autoUpdateRecommended)) {
                            disconnectMutationObservers();
                            autoUpdateLoop.add(_base);
                        }
                        else {
                            autoUpdateLoop.remove(_base);
                            connectMutationObservers();
                        }
                    }

                    //activate or deactivate size auto capability
                    if (sizeAutoCapableChanged) {
                        if (sizeAutoCapable) {
                            if (_contentGlueElement) {
                                _contentGlueElement.show();
                            }
                            else {
                                _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));
                                _paddingElement.before(_contentGlueElement);
                            }
                            if (_sizeAutoObserverAdded) {
                                _sizeAutoObserverElement.show();
                            }
                            else {
                                _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));
                                _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];

                                _contentGlueElement.before(_sizeAutoObserverElement);
                                var oldSize = { w: -1, h: -1 };
                                setupResizeObserver(_sizeAutoObserverElement, function () {
                                    var newSize = {
                                        w: _sizeAutoObserverElementNative[LEXICON.oW],
                                        h: _sizeAutoObserverElementNative[LEXICON.oH]
                                    };
                                    if (checkCache(newSize, oldSize)) {
                                        if (_initialized && (_heightAutoCache && newSize.h > 0) || (_widthAutoCache && newSize.w > 0)) {
                                            update();
                                        }
                                        else if (_initialized && (!_heightAutoCache && newSize.h === 0) || (!_widthAutoCache && newSize.w === 0)) {
                                            update();
                                        }
                                    }
                                    oldSize = newSize;
                                });
                                _sizeAutoObserverAdded = true;
                                //fix heightAuto detector bug if height is fixed but contentHeight is 0.
                                //the probability this bug will ever happen is very very low, thats why its ok if we use calc which isn't supported in IE8.
                                if (_cssCalc !== null)
                                    _sizeAutoObserverElement.css(_strHeight, _cssCalc + '(100% + 1px)');
                            }
                        }
                        else {
                            if (_sizeAutoObserverAdded)
                                _sizeAutoObserverElement.hide();
                            if (_contentGlueElement)
                                _contentGlueElement.hide();
                        }
                    }

                    //if force, update all resizeObservers too
                    if (force) {
                        _sizeObserverElement.find('*').trigger(_strScroll);
                        if (_sizeAutoObserverAdded)
                            _sizeAutoObserverElement.find('*').trigger(_strScroll);
                    }

                    //display hidden:
                    displayIsHidden = displayIsHidden === undefined ? _hostElement.is(':hidden') : displayIsHidden;

                    //textarea AutoWrapping:
                    var textareaAutoWrapping = _isTextarea ? _targetElement.attr('wrap') !== 'off' : false;
                    var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache);

                    //detect direction:
                    var cssDirection = _hostElement.css('direction');
                    var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache);

                    //detect box-sizing:
                    var boxSizing = _hostElement.css('box-sizing');
                    var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache);

                    //detect padding:
                    var padding = getTopRightBottomLeftHost(_strPaddingMinus);

                    //width + height auto detecting var:
                    var sizeAutoObserverElementBCRect;
                    //exception occurs in IE8 sometimes (unknown exception)
                    try {
                        sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;
                    } catch (ex) {
                        return;
                    }

                    _isRTL = cssDirection === 'rtl';
                    _isBorderBox = (boxSizing === 'border-box');
                    var isRTLLeft = _isRTL ? _strLeft : _strRight;
                    var isRTLRight = _isRTL ? _strRight : _strLeft;

                    //detect width auto:
                    var widthAutoResizeDetection = false;
                    var widthAutoObserverDetection = (_sizeAutoObserverAdded && (_hostElement.css(_strFloat) !== 'none' /*|| _isTextarea */)) ? (MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0) && (!paddingAbsolute ? (_hostElementNative[LEXICON.cW] - _paddingX) > 0 : true) : false;
                    if (sizeAutoCapable && !widthAutoObserverDetection) {
                        var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];
                        var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);
                        _contentGlueElement.css(_strWidth, _strAuto);

                        var tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                        _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                        widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                        if (!widthAutoResizeDetection) {
                            _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);
                            tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                            _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                            widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                        }
                    }
                    var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;
                    var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);
                    var wasWidthAuto = !widthAuto && _widthAutoCache;

                    //detect height auto:
                    var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? (MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0) /* && (!paddingAbsolute && (_msieVersion > 9 || !_msieVersion) ? true : true) */ : false;
                    var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);
                    var wasHeightAuto = !heightAuto && _heightAutoCache;

                    //detect border:
                    //we need the border only if border box and auto size
                    var updateBorderX = (widthAuto && _isBorderBox) || !_isBorderBox;
                    var updateBorderY = (heightAuto && _isBorderBox) || !_isBorderBox;
                    var border = getTopRightBottomLeftHost(_strBorderMinus, '-' + _strWidth, !updateBorderX, !updateBorderY)

                    //detect margin:
                    var margin = getTopRightBottomLeftHost(_strMarginMinus);

                    //vars to apply correct css
                    var contentElementCSS = {};
                    var contentGlueElementCSS = {};

                    //funcs
                    var getHostSize = function () {
                        //has to be clientSize because offsetSize respect borders
                        return {
                            w: _hostElementNative[LEXICON.cW],
                            h: _hostElementNative[LEXICON.cH]
                        };
                    };
                    var getViewportSize = function () {
                        //viewport size is padding container because it never has padding, margin and a border
                        //determine zoom rounding error -> sometimes scrollWidth/Height is smaller than clientWidth/Height
                        //if this happens add the difference to the viewportSize to compensate the rounding error
                        return {
                            w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),
                            h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])
                        };
                    };

                    //set info for padding
                    var paddingAbsoluteX = _paddingX = padding.l + padding.r;
                    var paddingAbsoluteY = _paddingY = padding.t + padding.b;
                    paddingAbsoluteX *= paddingAbsolute ? 1 : 0;
                    paddingAbsoluteY *= paddingAbsolute ? 1 : 0;
                    padding.c = checkCacheAutoForce(padding, _cssPaddingCache);

                    //set info for border
                    _borderX = border.l + border.r;
                    _borderY = border.t + border.b;
                    border.c = checkCacheAutoForce(border, _cssBorderCache);

                    //set info for margin
                    _marginX = margin.l + margin.r;
                    _marginY = margin.t + margin.b;
                    margin.c = checkCacheAutoForce(margin, _cssMarginCache);

                    //refresh cache
                    _textareaAutoWrappingCache = textareaAutoWrapping;
                    _cssDirectionCache = cssDirection;
                    _cssBoxSizingCache = boxSizing;
                    _widthAutoCache = widthAuto;
                    _heightAutoCache = heightAuto;
                    _cssPaddingCache = padding;
                    _cssBorderCache = border;
                    _cssMarginCache = margin;

                    //IEFix direction changed
                    if (cssDirectionChanged && _sizeAutoObserverAdded)
                        _sizeAutoObserverElement.css(_strFloat, isRTLRight);

                    //apply padding:
                    if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {
                        var paddingElementCSS = {};
                        var textareaCSS = {};
                        var paddingValues = [padding.t, padding.r, padding.b, padding.l];

                        setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);
                        if (paddingAbsolute) {
                            setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);
                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);
                        }
                        else {
                            setTopRightBottomLeft(paddingElementCSS, _strEmpty);
                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);
                        }

                        _paddingElement.css(paddingElementCSS);
                        _targetElement.css(textareaCSS);
                    }

                    //viewport size is padding container because it never has padding, margin and a border.
                    _viewportSize = getViewportSize();

                    //update Textarea
                    var textareaSize = _isTextarea ? textareaUpdate() : false;
                    var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);
                    var textareaDynOrigSize = _isTextarea && textareaSize ? {
                        w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,
                        h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight
                    } : {};
                    _textareaSizeCache = textareaSize;

                    //fix height auto / width auto in cooperation with current padding & boxSizing behavior:
                    if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {
                        contentElementCSS[_strHeight] = _strAuto;
                    }
                    else if (heightAutoChanged || paddingAbsoluteChanged) {
                        contentElementCSS[_strHeight] = _strHundredPercent;
                    }
                    if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {
                        contentElementCSS[_strWidth] = _strAuto;
                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent; //IE Fix
                    }
                    else if (widthAutoChanged || paddingAbsoluteChanged) {
                        contentElementCSS[_strWidth] = _strHundredPercent;
                        contentElementCSS[_strFloat] = _strEmpty;
                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty; //IE Fix
                    }
                    if (widthAuto) {
                        //textareaDynOrigSize.w || _strAuto :: doesnt works because applied margin will shift width
                        contentGlueElementCSS[_strWidth] = _strAuto;

                        contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, 'max-content intrinsic') || _strAuto;
                        contentElementCSS[_strFloat] = isRTLRight;
                    }
                    else {
                        contentGlueElementCSS[_strWidth] = _strEmpty;
                    }
                    if (heightAuto) {
                        //textareaDynOrigSize.h || _contentElementNative[LEXICON.cH] :: use for anti scroll jumping
                        contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];
                    }
                    else {
                        contentGlueElementCSS[_strHeight] = _strEmpty;
                    }
                    if (sizeAutoCapable)
                        _contentGlueElement.css(contentGlueElementCSS);
                    _contentElement.css(contentElementCSS);

                    //CHECKPOINT HERE ~
                    contentElementCSS = {};
                    contentGlueElementCSS = {};

                    //if [content(host) client / scroll size, or target element direction, or content(host) max-sizes] changed, or force is true
                    if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {
                        var strOverflow = 'overflow';
                        var strOverflowX = strOverflow + '-x';
                        var strOverflowY = strOverflow + '-y';
                        var strHidden = 'hidden';
                        var strVisible = 'visible';

                        //Reset the viewport (very important for natively overlaid scrollbars and zoom change
                        //don't change the overflow prop as it is very expensive and affects performance !A LOT!
                        if (!_nativeScrollbarStyling) {
                            var viewportElementResetCSS = {};
                            var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y) : 0;
                            var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x) : 0;
                            setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);
                            _viewportElement.css(viewportElementResetCSS);
                        }

                        //measure several sizes:
                        var contentMeasureElement = getContentMeasureElement();
                        //in Firefox content element has to have overflow hidden, else element margins aren't calculated properly, this element prevents this bug, but only if scrollbars aren't overlaid
                        var contentSize = {
                            //use clientSize because natively overlaidScrollbars add borders
                            w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],
                            h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]
                        };
                        var scrollSize = {
                            w: contentMeasureElement[LEXICON.sW],
                            h: contentMeasureElement[LEXICON.sH]
                        };

                        //apply the correct viewport style and measure viewport size
                        if (!_nativeScrollbarStyling) {
                            viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;
                            viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;
                            _viewportElement.css(viewportElementResetCSS);
                        }
                        _viewportSize = getViewportSize();

                        //measure and correct several sizes
                        var hostSize = getHostSize();
                        var hostAbsoluteRectSize = {
                            w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),
                            h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)
                        };
                        var contentGlueSize = {
                            //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually
                            //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding
                            w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),
                            h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)
                        };
                        contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);
                        _contentGlueSizeCache = contentGlueSize;

                        //apply correct contentGlue size
                        if (sizeAutoCapable) {
                            //size contentGlue correctly to make sure the element has correct size if the sizing switches to auto
                            if (contentGlueSize.c || (heightAuto || widthAuto)) {
                                contentGlueElementCSS[_strWidth] = contentGlueSize.w;
                                contentGlueElementCSS[_strHeight] = contentGlueSize.h;

                                //textarea-sizes are already calculated correctly at this point
                                if (!_isTextarea) {
                                    contentSize = {
                                        //use clientSize because natively overlaidScrollbars add borders
                                        w: contentMeasureElement[LEXICON.cW],
                                        h: contentMeasureElement[LEXICON.cH]
                                    };
                                }
                            }
                            var textareaCoverCSS = {};
                            var setContentGlueElementCSSfunction = function (horizontal) {
                                var scrollbarVars = getScrollbarVars(horizontal);
                                var wh = scrollbarVars._w_h;
                                var strWH = scrollbarVars._width_height;
                                var autoSize = horizontal ? widthAuto : heightAuto;
                                var borderSize = horizontal ? _borderX : _borderY;
                                var paddingSize = horizontal ? _paddingX : _paddingY;
                                var marginSize = horizontal ? _marginX : _marginY;
                                var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize);

                                //make contentGlue size -1 if element is not auto sized, to make sure that a resize event happens when the element shrinks
                                if (!autoSize || (!autoSize && border.c))
                                    contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1;

                                //if size is auto and host is smaller than size as min size, make content glue size -1 to make sure size changes will be detected (this is only needed if padding is 0)
                                if (autoSize && (contentSize[wh] < viewportSize) && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {
                                    if (_isTextarea)
                                        textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;
                                    contentGlueElementCSS[strWH] -= 1;
                                }

                                //make sure content glue size is at least 1
                                if (contentSize[wh] > 0)
                                    contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);
                            };
                            setContentGlueElementCSSfunction(true);
                            setContentGlueElementCSSfunction(false);

                            if (_isTextarea)
                                _textareaCoverElement.css(textareaCoverCSS);
                            _contentGlueElement.css(contentGlueElementCSS);
                        }
                        if (widthAuto)
                            contentElementCSS[_strWidth] = _strHundredPercent;
                        if (widthAuto && !_isBorderBox && !_mutationObserversConnected)
                            contentElementCSS[_strFloat] = 'none';

                        //apply and reset content style
                        _contentElement.css(contentElementCSS);
                        contentElementCSS = {};

                        //measure again, but this time all correct sizes:
                        var contentScrollSize = {
                            w: contentMeasureElement[LEXICON.sW],
                            h: contentMeasureElement[LEXICON.sH],
                        };
                        contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);
                        _contentScrollSizeCache = contentScrollSize;

                        //refresh viewport size after correct measuring
                        _viewportSize = getViewportSize();

                        hostSize = getHostSize();
                        hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);
                        _hostSizeCache = hostSize;

                        var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);
                        var previousOverflowAmount = _overflowAmountCache;
                        var overflowBehaviorIsVS = {};
                        var overflowBehaviorIsVH = {};
                        var overflowBehaviorIsS = {};
                        var overflowAmount = {};
                        var hasOverflow = {};
                        var hideOverflow = {};
                        var canScroll = {};
                        var viewportRect = _paddingElementNative[LEXICON.bCR]();
                        var setOverflowVariables = function (horizontal) {
                            var scrollbarVars = getScrollbarVars(horizontal);
                            var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                            var xyI = scrollbarVarsInverted._x_y;
                            var xy = scrollbarVars._x_y;
                            var wh = scrollbarVars._w_h;
                            var widthHeight = scrollbarVars._width_height;
                            var scrollMax = _strScroll + scrollbarVars._Left_Top + 'Max';
                            var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;
                            var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;
                            overflowBehaviorIsVS[xy] = overflowBehavior[xy] === 'v-s';
                            overflowBehaviorIsVH[xy] = overflowBehavior[xy] === 'v-h';
                            overflowBehaviorIsS[xy] = overflowBehavior[xy] === 's';
                            overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);
                            overflowAmount[xy] *= (hideOverflowForceTextarea || (checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1)) ? 0 : 1;
                            hasOverflow[xy] = overflowAmount[xy] > 0;

                            //hideOverflow:
                            //x || y : true === overflow is hidden by "overflow: scroll" OR "overflow: hidden"
                            //xs || ys : true === overflow is hidden by "overflow: scroll"
                            hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? (hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI]) : hasOverflow[xy];
                            hideOverflow[xy + 's'] = hideOverflow[xy] ? (overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy]) : false;

                            canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + 's'];
                        };
                        setOverflowVariables(true);
                        setOverflowVariables(false);

                        overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);
                        _overflowAmountCache = overflowAmount;
                        hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);
                        _hasOverflowCache = hasOverflow;
                        hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);
                        _hideOverflowCache = hideOverflow;

                        //if native scrollbar is overlay at x OR y axis, prepare DOM
                        if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {
                            var borderDesign = 'px solid transparent';
                            var contentArrangeElementCSS = {};
                            var arrangeContent = {};
                            var arrangeChanged = force;
                            var setContentElementCSS;

                            if (hasOverflow.x || hasOverflow.y) {
                                arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;
                                arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;
                                arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);
                                _arrangeContentSizeCache = arrangeContent;
                            }

                            if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {
                                contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;
                                setContentElementCSS = function (horizontal) {
                                    var scrollbarVars = getScrollbarVars(horizontal);
                                    var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                                    var xy = scrollbarVars._x_y;
                                    var strDirection = horizontal ? _strBottom : isRTLLeft;
                                    var invertedAutoSize = horizontal ? heightAuto : widthAuto;

                                    if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + 's']) {
                                        contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? (ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy]) : _strEmpty;
                                        contentElementCSS[_strBorderMinus + strDirection] = ((horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding) ? (_overlayScrollbarDummySize[xy] + borderDesign) : _strEmpty;
                                    }
                                    else {
                                        arrangeContent[scrollbarVarsInverted._w_h] =
                                            contentElementCSS[_strMarginMinus + strDirection] =
                                            contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;
                                        arrangeChanged = true;
                                    }
                                };

                                if (_nativeScrollbarStyling) {
                                    addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding)
                                }
                                else {
                                    setContentElementCSS(true);
                                    setContentElementCSS(false);
                                }
                            }
                            if (ignoreOverlayScrollbarHiding) {
                                arrangeContent.w = arrangeContent.h = _strEmpty;
                                arrangeChanged = true;
                            }
                            if (arrangeChanged && !_nativeScrollbarStyling) {
                                contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;
                                contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;

                                if (!_contentArrangeElement) {
                                    _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));
                                    _viewportElement.prepend(_contentArrangeElement);
                                }
                                _contentArrangeElement.css(contentArrangeElementCSS);
                            }
                            _contentElement.css(contentElementCSS);
                        }

                        var viewportElementCSS = {};
                        var paddingElementCSS = {};
                        var setViewportCSS;
                        if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {
                            viewportElementCSS[isRTLRight] = _strEmpty;
                            setViewportCSS = function (horizontal) {
                                var scrollbarVars = getScrollbarVars(horizontal);
                                var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                                var xy = scrollbarVars._x_y;
                                var XY = scrollbarVars._X_Y;
                                var strDirection = horizontal ? _strBottom : isRTLLeft;

                                var reset = function () {
                                    viewportElementCSS[strDirection] = _strEmpty;
                                    _contentBorderSize[scrollbarVarsInverted._w_h] = 0;
                                };
                                if (hasOverflow[xy] && hideOverflow[xy + 's']) {
                                    viewportElementCSS[strOverflow + XY] = _strScroll;
                                    if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {
                                        reset();
                                    }
                                    else {
                                        viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);
                                        _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;
                                    }
                                } else {
                                    viewportElementCSS[strOverflow + XY] = _strEmpty;
                                    reset();
                                }
                            };
                            setViewportCSS(true);
                            setViewportCSS(false);

                            // if the scroll container is too small and if there is any overflow with no overlay scrollbar (and scrollbar styling isn't possible),
                            // make viewport element greater in size (Firefox hide Scrollbars fix)
                            // because firefox starts hiding scrollbars on too small elements
                            // with this behavior the overflow calculation may be incorrect or the scrollbars would appear suddenly
                            // https://bugzilla.mozilla.org/show_bug.cgi?id=292284
                            if (!_nativeScrollbarStyling
                                && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y)
                                && ((hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x) || (hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y))) {
                                viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;
                                viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;

                                viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;
                                viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;
                            }
                            else {
                                viewportElementCSS[_strPaddingMinus + _strTop] =
                                    viewportElementCSS[_strMarginMinus + _strTop] =
                                    viewportElementCSS[_strPaddingMinus + isRTLRight] =
                                    viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;
                            }
                            viewportElementCSS[_strPaddingMinus + isRTLLeft] =
                                viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty;

                            //if there is any overflow (x OR y axis) and this overflow shall be hidden, make overflow hidden, else overflow visible
                            if ((hasOverflow.x && hideOverflow.x) || (hasOverflow.y && hideOverflow.y) || hideOverflowForceTextarea) {
                                //only hide if is Textarea
                                if (_isTextarea && hideOverflowForceTextarea) {
                                    paddingElementCSS[strOverflowX] =
                                        paddingElementCSS[strOverflowY] = strHidden;
                                }
                            }
                            else {
                                if (!clipAlways || (overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y)) {
                                    //only un-hide if Textarea
                                    if (_isTextarea) {
                                        paddingElementCSS[strOverflowX] =
                                            paddingElementCSS[strOverflowY] = _strEmpty;
                                    }
                                    viewportElementCSS[strOverflowX] =
                                        viewportElementCSS[strOverflowY] = strVisible;
                                }
                            }

                            _paddingElement.css(paddingElementCSS);
                            _viewportElement.css(viewportElementCSS);
                            viewportElementCSS = {};

                            //force soft redraw in webkit because without the scrollbars will may appear because DOM wont be redrawn under special conditions
                            if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                                var elementStyle = _contentElementNative[LEXICON.s];
                                var dump;
                                elementStyle.webkitTransform = 'scale(1)';
                                elementStyle.display = 'run-in';
                                dump = _contentElementNative[LEXICON.oH];
                                elementStyle.display = _strEmpty; //|| dump; //use dump to prevent it from deletion if minify
                                elementStyle.webkitTransform = _strEmpty;
                            }
                            /*
                            //force hard redraw in webkit if native overlaid scrollbars shall appear
                            if (ignoreOverlayScrollbarHidingChanged && ignoreOverlayScrollbarHiding) {
                                _hostElement.hide();
                                var dump = _hostElementNative[LEXICON.oH];
                                _hostElement.show();
                            }
                            */
                        }

                        //change to direction RTL and width auto Bugfix in Webkit
                        //without this fix, the DOM still thinks the scrollbar is LTR and thus the content is shifted to the left
                        contentElementCSS = {};
                        if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {
                            if (_isRTL && widthAuto) {
                                var floatTmp = _contentElement.css(_strFloat);
                                var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);
                                _contentElement.css(_strFloat, floatTmp);
                                var posLeftWithFloat = MATH.round(_contentElement.position().left);

                                if (posLeftWithoutFloat !== posLeftWithFloat)
                                    contentElementCSS[_strLeft] = posLeftWithoutFloat;
                            }
                            else {
                                contentElementCSS[_strLeft] = _strEmpty;
                            }
                        }
                        _contentElement.css(contentElementCSS);

                        //handle scroll position
                        if (_isTextarea && contentSizeChanged) {
                            var textareaInfo = getTextareaInfo();
                            if (textareaInfo) {
                                var textareaRowsChanged = _textareaInfoCache === undefined ? true : textareaInfo._rows !== _textareaInfoCache._rows;
                                var cursorRow = textareaInfo._cursorRow;
                                var cursorCol = textareaInfo._cursorColumn;
                                var widestRow = textareaInfo._widestRow;
                                var lastRow = textareaInfo._rows;
                                var lastCol = textareaInfo._columns;
                                var cursorPos = textareaInfo._cursorPosition;
                                var cursorMax = textareaInfo._cursorMax;
                                var cursorIsLastPosition = (cursorPos >= cursorMax && _textareaHasFocus);
                                var textareaScrollAmount = {
                                    x: (!textareaAutoWrapping && (cursorCol === lastCol && cursorRow === widestRow)) ? _overflowAmountCache.x : -1,
                                    y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? (currScroll.y === previousOverflowAmount.y) : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1
                                };
                                currScroll.x = textareaScrollAmount.x > -1 ? (_isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x) : currScroll.x; //if inverted, scroll to 0 -> normalized this means to max scroll offset.
                                currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;
                            }
                            _textareaInfoCache = textareaInfo;
                        }
                        if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache)
                            currScroll.x += _contentBorderSize.w || 0;
                        if (widthAuto)
                            _hostElement[_strScrollLeft](0);
                        if (heightAuto)
                            _hostElement[_strScrollTop](0);
                        _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y);

                        //scrollbars management:
                        var scrollbarsVisibilityVisible = scrollbarsVisibility === 'v';
                        var scrollbarsVisibilityHidden = scrollbarsVisibility === 'h';
                        var scrollbarsVisibilityAuto = scrollbarsVisibility === 'a';
                        var refreshScrollbarsVisibility = function (showX, showY) {
                            showY = showY === undefined ? showX : showY;
                            refreshScrollbarAppearance(true, showX, canScroll.x)
                            refreshScrollbarAppearance(false, showY, canScroll.y)
                        };

                        //manage class name which indicates scrollable overflow
                        addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);
                        addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);
                        addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y);

                        //add or remove rtl class name for styling purposes except when its body, then the scrollbar stays
                        if (cssDirectionChanged && !_isBody) {
                            addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);
                        }

                        //manage the resize feature (CSS3 resize "polyfill" for this plugin)
                        if (_isBody)
                            addClass(_hostElement, _classNameHostResizeDisabled);
                        if (resizeChanged) {
                            addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);
                        }

                        //manage the scrollbars general visibility + the scrollbar interactivity (unusable class name)
                        if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {
                            if (ignoreOverlayScrollbarHiding) {
                                if (ignoreOverlayScrollbarHidingChanged) {
                                    removeClass(_hostElement, _classNameHostScrolling);
                                    if (ignoreOverlayScrollbarHiding) {
                                        refreshScrollbarsVisibility(false);
                                    }
                                }
                            }
                            else if (scrollbarsVisibilityAuto) {
                                refreshScrollbarsVisibility(canScroll.x, canScroll.y);
                            }
                            else if (scrollbarsVisibilityVisible) {
                                refreshScrollbarsVisibility(true);
                            }
                            else if (scrollbarsVisibilityHidden) {
                                refreshScrollbarsVisibility(false);
                            }
                        }

                        //manage the scrollbars auto hide feature (auto hide them after specific actions)
                        if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {
                            setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);
                            refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);
                        }

                        //manage scrollbars handle length & offset - don't remove!
                        if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {
                            refreshScrollbarHandleLength(true);
                            refreshScrollbarHandleOffset(true);
                            refreshScrollbarHandleLength(false);
                            refreshScrollbarHandleOffset(false);
                        }

                        //manage interactivity
                        if (scrollbarsClickScrollingChanged)
                            refreshScrollbarsInteractive(true, scrollbarsClickScrolling);
                        if (scrollbarsDragScrollingChanged)
                            refreshScrollbarsInteractive(false, scrollbarsDragScrolling);

                        //callbacks:
                        dispatchCallback('onDirectionChanged', {
                            isRTL: _isRTL,
                            dir: cssDirection
                        }, cssDirectionChanged);
                        dispatchCallback('onHostSizeChanged', {
                            width: _hostSizeCache.w,
                            height: _hostSizeCache.h
                        }, hostSizeChanged);
                        dispatchCallback('onContentSizeChanged', {
                            width: _contentScrollSizeCache.w,
                            height: _contentScrollSizeCache.h
                        }, contentSizeChanged);
                        dispatchCallback('onOverflowChanged', {
                            x: hasOverflow.x,
                            y: hasOverflow.y,
                            xScrollable: hideOverflow.xs,
                            yScrollable: hideOverflow.ys,
                            clipped: hideOverflow.x || hideOverflow.y
                        }, hasOverflow.c || hideOverflow.c);
                        dispatchCallback('onOverflowAmountChanged', {
                            x: overflowAmount.x,
                            y: overflowAmount.y
                        }, overflowAmount.c);
                    }

                    //fix body min size
                    if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {
                        //its possible that no min size was measured until now, because the content arrange element was just added now, in this case, measure now the min size.
                        if (!_bodyMinSizeCache.f)
                            bodyMinSizeChanged();
                        if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x)
                            _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);
                        if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y)
                            _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);
                        _bodyMinSizeCache.c = false;
                    }

                    if (_initialized && changedOptions.updateOnLoad) {
                        updateElementsOnLoad();
                    }

                    //freezeResizeObserver(_sizeObserverElement, false);
                    //freezeResizeObserver(_sizeAutoObserverElement, false);

                    dispatchCallback('onUpdated', { forced: force });
                }

                /**
                 * Updates the found elements of which the load event shall be handled.
                 */
                function updateElementsOnLoad() {
                    if (!_isTextarea) {
                        eachUpdateOnLoad(function (i, updateOnLoadSelector) {
                            _contentElement.find(updateOnLoadSelector).each(function (i, el) {
                                // if element doesn't have a updateOnLoadCallback applied
                                if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {
                                    _updateOnLoadElms.push(el);
                                    FRAMEWORK(el)
                                        .off(_updateOnLoadEventName, updateOnLoadCallback)
                                        .on(_updateOnLoadEventName, updateOnLoadCallback);
                                }
                            });
                        });
                    }
                }

                //==== Options ====//

                /**
                 * Sets new options but doesn't call the update method.
                 * @param newOptions The object which contains the new options.
                 * @returns {*} A object which contains the changed options.
                 */
                function setOptions(newOptions) {
                    var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions)

                    _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);
                    _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);

                    return validatedOpts._prepared;
                }


                //==== Structure ====//

                /**
                 * Builds or destroys the wrapper and helper DOM elements.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                /**
                 * Builds or destroys the wrapper and helper DOM elements.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupStructureDOM(destroy) {
                    var strParent = 'parent';
                    var classNameResizeObserverHost = 'os-resize-observer-host';
                    var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;
                    var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;
                    var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;
                    var adoptAttrsMap = {};
                    var applyAdoptedAttrs = function () {
                        var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;
                        each(adoptAttrsMap, function (key, value) {
                            if (type(value) == TYPES.s) {
                                if (key == LEXICON.c)
                                    applyAdoptedAttrsElm.addClass(value);
                                else
                                    applyAdoptedAttrsElm.attr(key, value);
                            }
                        });
                    };
                    var hostElementClassNames = [
                        _classNameHostElement,
                        _classNameHostElementForeign,
                        _classNameHostTextareaElement,
                        _classNameHostResizeDisabled,
                        _classNameHostRTL,
                        _classNameHostScrollbarHorizontalHidden,
                        _classNameHostScrollbarVerticalHidden,
                        _classNameHostTransition,
                        _classNameHostScrolling,
                        _classNameHostOverflow,
                        _classNameHostOverflowX,
                        _classNameHostOverflowY,
                        _classNameThemeNone,
                        _classNameTextareaElement,
                        _classNameTextInherit,
                        _classNameCache].join(_strSpace);
                    var hostElementCSS = {};

                    //get host element as first element, because that's the most upper element and required for the other elements
                    _hostElement = _hostElement || (_isTextarea ? (_domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement))) : _targetElement);
                    _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);
                    _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);
                    _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);
                    _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);
                    _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined);

                    //add this class to workaround class changing issues with UI frameworks especially Vue
                    if (_domExists)
                        addClass(_hostElement, _classNameHostElementForeign);

                    //on destroy, remove all generated class names from the host element before collecting the adopted attributes
                    //to prevent adopting generated class names
                    if (destroy)
                        removeClass(_hostElement, hostElementClassNames);

                    //collect all adopted attributes
                    adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;
                    if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {
                        each(adoptAttrs, function (i, v) {
                            if (type(v) == TYPES.s) {
                                adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);
                            }
                        });
                    }

                    if (!destroy) {
                        if (_isTextarea) {
                            if (!_currentPreparedOptions.sizeAutoCapable) {
                                hostElementCSS[_strWidth] = _targetElement.css(_strWidth);
                                hostElementCSS[_strHeight] = _targetElement.css(_strHeight);
                            }

                            if (!_domExists)
                                _targetElement.addClass(_classNameTextInherit).wrap(_hostElement);

                            //jQuery clones elements in wrap functions, so we have to select them again
                            _hostElement = _targetElement[strParent]().css(hostElementCSS);
                        }

                        if (!_domExists) {
                            //add the correct class to the target element
                            addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement);

                            //wrap the content into the generated elements to create the required DOM
                            _hostElement.wrapInner(_contentElement)
                                .wrapInner(_viewportElement)
                                .wrapInner(_paddingElement)
                                .prepend(_sizeObserverElement);

                            //jQuery clones elements in wrap functions, so we have to select them again
                            _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);
                            _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);
                            _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);

                            if (_isTextarea) {
                                _contentElement.prepend(_textareaCoverElement);
                                applyAdoptedAttrs();
                            }
                        }

                        if (_nativeScrollbarStyling)
                            addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
                        if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)
                            addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);
                        if (_isBody)
                            addClass(_htmlElement, _classNameHTMLElement);

                        _sizeObserverElementNative = _sizeObserverElement[0];
                        _hostElementNative = _hostElement[0];
                        _paddingElementNative = _paddingElement[0];
                        _viewportElementNative = _viewportElement[0];
                        _contentElementNative = _contentElement[0];

                        updateViewportAttrsFromTarget();
                    }
                    else {
                        if (_domExists && _initialized) {
                            //clear size observer
                            _sizeObserverElement.children().remove();

                            //remove the style property and classes from already generated elements
                            each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function (i, elm) {
                                if (elm) {
                                    removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                                }
                            });

                            //add classes to the host element which was removed previously to match the expected DOM
                            addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);
                        }
                        else {
                            //remove size observer
                            remove(_sizeObserverElement);

                            //unwrap the content to restore DOM
                            _contentElement.contents()
                                .unwrap()
                                .unwrap()
                                .unwrap();

                            if (_isTextarea) {
                                _targetElement.unwrap();
                                remove(_hostElement);
                                remove(_textareaCoverElement);
                                applyAdoptedAttrs();
                            }
                        }

                        if (_isTextarea)
                            _targetElement.removeAttr(LEXICON.s);

                        if (_isBody)
                            removeClass(_htmlElement, _classNameHTMLElement);
                    }
                }

                /**
                 * Adds or removes all wrapper elements interactivity events.
                 * @param destroy Indicates whether the Events shall be added or removed.
                 */
                function setupStructureEvents() {
                    var textareaKeyDownRestrictedKeyCodes = [
                        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123,    //F1 to F12
                        33, 34,                                                   //page up, page down
                        37, 38, 39, 40,                                           //left, up, right, down arrows
                        16, 17, 18, 19, 20, 144                                   //Shift, Ctrl, Alt, Pause, CapsLock, NumLock
                    ];
                    var textareaKeyDownKeyCodesList = [];
                    var textareaUpdateIntervalID;
                    var scrollStopTimeoutId;
                    var scrollStopDelay = 175;
                    var strFocus = 'focus';

                    function updateTextarea(doClearInterval) {
                        textareaUpdate();
                        _base.update(_strAuto);
                        if (doClearInterval && _autoUpdateRecommended)
                            clearInterval(textareaUpdateIntervalID);
                    }
                    function textareaOnScroll(event) {
                        _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);
                        _targetElement[_strScrollTop](0);
                        COMPATIBILITY.prvD(event);
                        COMPATIBILITY.stpP(event);
                        return false;
                    }
                    function textareaOnDrop(event) {
                        setTimeout(function () {
                            if (!_destroyed)
                                updateTextarea();
                        }, 50);
                    }
                    function textareaOnFocus() {
                        _textareaHasFocus = true;
                        addClass(_hostElement, strFocus);
                    }
                    function textareaOnFocusout() {
                        _textareaHasFocus = false;
                        textareaKeyDownKeyCodesList = [];
                        removeClass(_hostElement, strFocus);
                        updateTextarea(true);
                    }
                    function textareaOnKeyDown(event) {
                        var keyCode = event.keyCode;

                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                            if (!textareaKeyDownKeyCodesList[LEXICON.l]) {
                                updateTextarea();
                                textareaUpdateIntervalID = setInterval(updateTextarea, 1000 / 60);
                            }
                            if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0)
                                textareaKeyDownKeyCodesList.push(keyCode);
                        }
                    }
                    function textareaOnKeyUp(event) {
                        var keyCode = event.keyCode;
                        var index = inArray(keyCode, textareaKeyDownKeyCodesList);

                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                            if (index > -1)
                                textareaKeyDownKeyCodesList.splice(index, 1);
                            if (!textareaKeyDownKeyCodesList[LEXICON.l])
                                updateTextarea(true);
                        }
                    }
                    function contentOnTransitionEnd(event) {
                        if (_autoUpdateCache === true)
                            return;
                        event = event.originalEvent || event;
                        if (isSizeAffectingCSSProperty(event.propertyName))
                            _base.update(_strAuto);
                    }
                    function viewportOnScroll(event) {
                        if (!_sleeping) {
                            if (scrollStopTimeoutId !== undefined)
                                clearTimeout(scrollStopTimeoutId);
                            else {
                                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                    refreshScrollbarsAutoHide(true);

                                if (!nativeOverlayScrollbarsAreActive())
                                    addClass(_hostElement, _classNameHostScrolling);

                                dispatchCallback('onScrollStart', event);
                            }

                            //if a scrollbars handle gets dragged, the mousemove event is responsible for refreshing the handle offset
                            //because if CSS scroll-snap is used, the handle offset gets only refreshed on every snap point
                            //this looks laggy & clunky, it looks much better if the offset refreshes with the mousemove
                            if (!_scrollbarsHandlesDefineScrollPos) {
                                refreshScrollbarHandleOffset(true);
                                refreshScrollbarHandleOffset(false);
                            }
                            dispatchCallback('onScroll', event);

                            scrollStopTimeoutId = setTimeout(function () {
                                if (!_destroyed) {
                                    //OnScrollStop:
                                    clearTimeout(scrollStopTimeoutId);
                                    scrollStopTimeoutId = undefined;

                                    if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                        refreshScrollbarsAutoHide(false);

                                    if (!nativeOverlayScrollbarsAreActive())
                                        removeClass(_hostElement, _classNameHostScrolling);

                                    dispatchCallback('onScrollStop', event);
                                }
                            }, scrollStopDelay);
                        }
                    }


                    if (_isTextarea) {
                        if (_msieVersion > 9 || !_autoUpdateRecommended) {
                            addDestroyEventListener(_targetElement, 'input', updateTextarea);
                        }
                        else {
                            addDestroyEventListener(_targetElement,
                                [_strKeyDownEvent, _strKeyUpEvent],
                                [textareaOnKeyDown, textareaOnKeyUp]);
                        }

                        addDestroyEventListener(_targetElement,
                            [_strScroll, 'drop', strFocus, strFocus + 'out'],
                            [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]);
                    }
                    else {
                        addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);
                    }
                    addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);
                }


                //==== Scrollbars ====//

                /**
                 * Builds or destroys all scrollbar DOM elements (scrollbar, track, handle)
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupScrollbarsDOM(destroy) {
                    var selectOrGenerateScrollbarDOM = function (isHorizontal) {
                        var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;
                        var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);
                        var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);
                        var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);

                        if (!_domExists && !destroy) {
                            scrollbar.append(track);
                            track.append(handle);
                        }

                        return {
                            _scrollbar: scrollbar,
                            _track: track,
                            _handle: handle
                        };
                    };
                    function resetScrollbarDOM(isHorizontal) {
                        var scrollbarVars = getScrollbarVars(isHorizontal);
                        var scrollbar = scrollbarVars._scrollbar;
                        var track = scrollbarVars._track;
                        var handle = scrollbarVars._handle;

                        if (_domExists && _initialized) {
                            each([scrollbar, track, handle], function (i, elm) {
                                removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                            });
                        }
                        else {
                            remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);
                        }
                    }
                    var horizontalElements;
                    var verticalElements;

                    if (!destroy) {
                        horizontalElements = selectOrGenerateScrollbarDOM(true);
                        verticalElements = selectOrGenerateScrollbarDOM();

                        _scrollbarHorizontalElement = horizontalElements._scrollbar;
                        _scrollbarHorizontalTrackElement = horizontalElements._track;
                        _scrollbarHorizontalHandleElement = horizontalElements._handle;
                        _scrollbarVerticalElement = verticalElements._scrollbar;
                        _scrollbarVerticalTrackElement = verticalElements._track;
                        _scrollbarVerticalHandleElement = verticalElements._handle;

                        if (!_domExists) {
                            _paddingElement.after(_scrollbarVerticalElement);
                            _paddingElement.after(_scrollbarHorizontalElement);
                        }
                    }
                    else {
                        resetScrollbarDOM(true);
                        resetScrollbarDOM();
                    }
                }

                /**
                 * Initializes all scrollbar interactivity events. (track and handle dragging, clicking, scrolling)
                 * @param isHorizontal True if the target scrollbar is the horizontal scrollbar, false if the target scrollbar is the vertical scrollbar.
                 */
                function setupScrollbarEvents(isHorizontal) {
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var insideIFrame = _windowElementNative.top !== _windowElementNative;
                    var xy = scrollbarVars._x_y;
                    var XY = scrollbarVars._X_Y;
                    var scroll = _strScroll + scrollbarVars._Left_Top;
                    var strActive = 'active';
                    var strSnapHandle = 'snapHandle';
                    var strClickEvent = 'click';
                    var scrollDurationFactor = 1;
                    var increaseDecreaseScrollAmountKeyCodes = [16, 17]; //shift, ctrl
                    var trackTimeout;
                    var mouseDownScroll;
                    var mouseDownOffset;
                    var mouseDownInvertedScale;

                    function getPointerPosition(event) {
                        return _msieVersion && insideIFrame ? event['screen' + XY] : COMPATIBILITY.page(event)[xy]; //use screen coordinates in EDGE & IE because the page values are incorrect in frames.
                    }
                    function getPreparedScrollbarsOption(name) {
                        return _currentPreparedOptions.scrollbars[name];
                    }
                    function increaseTrackScrollAmount() {
                        scrollDurationFactor = 0.5;
                    }
                    function decreaseTrackScrollAmount() {
                        scrollDurationFactor = 1;
                    }
                    function stopClickEventPropagation(event) {
                        COMPATIBILITY.stpP(event);
                    }
                    function documentKeyDown(event) {
                        if (inArray(event.keyCodereaseDecreaseScrollAmountKeyCodes) > -1)
                            increaseTrackScrollAmount();
                    }
                    function documentKeyUp(event) {
                        if (inArray(event.keyCodereaseDecreaseScrollAmountKeyCodes) > -1)
                            decreaseTrackScrollAmount();
                    }
                    function onMouseTouchDownContinue(event) {
                        var originalEvent = event.originalEvent || event;
                        var isTouchEvent = originalEvent.touches !== undefined;
                        return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || (isTouchEvent && !getPreparedScrollbarsOption('touchSupport')) ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                    }
                    function documentDragMove(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var trackLength = scrollbarVarsInfo._trackLength;
                            var handleLength = scrollbarVarsInfo._handleLength;
                            var scrollRange = scrollbarVarsInfo._maxScroll;
                            var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;
                            var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);
                            var scrollDelta = (scrollRange * scrollDeltaPercent);
                            scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;
                            if (_isRTL && isHorizontal && !_rtlScrollBehavior.i)
                                scrollDelta *= -1;

                            _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));

                            if (_scrollbarsHandlesDefineScrollPos)
                                refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);

                            if (!_supportPassiveEvents)
                                COMPATIBILITY.prvD(event);
                        }
                        else
                            documentMouseTouchUp(event);
                    }
                    function documentMouseTouchUp(event) {
                        event = event || event.originalEvent;

                        setupResponsiveEventListener(_documentElement,
                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                            [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart],
                            true);
                        COMPATIBILITY.rAF()(function() {
                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, true, { _capture: true });
                        });


                        if (_scrollbarsHandlesDefineScrollPos)
                            refreshScrollbarHandleOffset(isHorizontal, true);

                        _scrollbarsHandlesDefineScrollPos = false;
                        removeClass(_bodyElement, _classNameDragging);
                        removeClass(scrollbarVars._handle, strActive);
                        removeClass(scrollbarVars._track, strActive);
                        removeClass(scrollbarVars._scrollbar, strActive);

                        mouseDownScroll = undefined;
                        mouseDownOffset = undefined;
                        mouseDownInvertedScale = 1;

                        decreaseTrackScrollAmount();

                        if (trackTimeout !== undefined) {
                            _base.scrollStop();
                            clearTimeout(trackTimeout);
                            trackTimeout = undefined;
                        }

                        if (event) {
                            var rect = _hostElementNative[LEXICON.bCR]();
                            var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;

                            //if mouse is outside host element
                            if (!mouseInsideHost)
                                hostOnMouseLeave();

                            if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                refreshScrollbarsAutoHide(false);
                        }
                    }
                    function onHandleMouseTouchDown(event) {
                        if (onMouseTouchDownContinue(event))
                            onHandleMouseTouchDownAction(event);
                    }
                    function onHandleMouseTouchDownAction(event) {
                        mouseDownScroll = _viewportElement[scroll]();
                        mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;
                        if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL)
                            mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;

                        mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                        mouseDownOffset = getPointerPosition(event);

                        _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                        addClass(_bodyElement, _classNameDragging);
                        addClass(scrollbarVars._handle, strActive);
                        addClass(scrollbarVars._scrollbar, strActive);

                        setupResponsiveEventListener(_documentElement,
                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent],
                            [documentDragMove, documentMouseTouchUp, documentOnSelectStart]);
                        COMPATIBILITY.rAF()(function() {
                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, false, { _capture: true });
                        });


                        if (_msieVersion || !_documentMixed)
                            COMPATIBILITY.prvD(event);
                        COMPATIBILITY.stpP(event);
                    }
                    function onTrackMouseTouchDown(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var handleToViewportRatio = scrollbarVars._info._handleLength / Math.round(MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]) * scrollbarVars._info._trackLength);
                            var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h] * handleToViewportRatio);
                            var scrollBaseDuration = 270 * handleToViewportRatio;
                            var scrollFirstIterationDelay = 400 * handleToViewportRatio;
                            var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];
                            var ctrlKey = event.ctrlKey;
                            var instantScroll = event.shiftKey;
                            var instantScrollTransition = instantScroll && ctrlKey;
                            var isFirstIteration = true;
                            var easing = 'linear';
                            var decreaseScroll;
                            var finishedCondition;
                            var scrollActionFinsished = function (transition) {
                                if (_scrollbarsHandlesDefineScrollPos)
                                    refreshScrollbarHandleOffset(isHorizontal, transition);
                            };
                            var scrollActionInstantFinished = function () {
                                scrollActionFinsished();
                                onHandleMouseTouchDownAction(event);
                            };
                            var scrollAction = function () {
                                if (!_destroyed) {
                                    var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;
                                    var handleOffset = scrollbarVarsInfo._handleOffset;
                                    var trackLength = scrollbarVarsInfo._trackLength;
                                    var handleLength = scrollbarVarsInfo._handleLength;
                                    var scrollRange = scrollbarVarsInfo._maxScroll;
                                    var currScroll = scrollbarVarsInfo._currentScroll;
                                    var scrollDuration = scrollBaseDuration * scrollDurationFactor;
                                    var timeoutDelay = isFirstIteration ? MATH.max(scrollFirstIterationDelay, scrollDuration) : scrollDuration;
                                    var instantScrollPosition = scrollRange * ((mouseOffset - (handleLength / 2)) / (trackLength - handleLength)); // 100% * positionPercent
                                    var rtlIsNormal = _isRTL && isHorizontal && ((!_rtlScrollBehavior.i && !_rtlScrollBehavior.n) || _normalizeRTLCache);
                                    var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;
                                    var scrollObj = {};
                                    var animationObj = {
                                        easing: easing,
                                        step: function (now) {
                                            if (_scrollbarsHandlesDefineScrollPos) {
                                                _viewportElement[scroll](now); //https://github.com/jquery/jquery/issues/4340
                                                refreshScrollbarHandleOffset(isHorizontal, now);
                                            }
                                        }
                                    };
                                    instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;
                                    instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;

                                    //_base.scrollStop();

                                    if (instantScroll) {
                                        _viewportElement[scroll](instantScrollPosition); //scroll instantly to new position
                                        if (instantScrollTransition) {
                                            //get the scroll position after instant scroll (in case CSS Snap Points are used) to get the correct snapped scroll position
                                            //and the animation stops at the correct point
                                            instantScrollPosition = _viewportElement[scroll]();
                                            //scroll back to the position before instant scrolling so animation can be performed
                                            _viewportElement[scroll](currScroll);

                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;
                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;

                                            scrollObj[xy] = instantScrollPosition;
                                            _base.scroll(scrollObj, extendDeep(animationObj, {
                                                duration: 130,
                                                complete: scrollActionInstantFinished
                                            }));
                                        }
                                        else
                                            scrollActionInstantFinished();
                                    }
                                    else {
                                        decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;
                                        finishedCondition = rtlIsNormal
                                            ? (decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset)
                                            : (decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset);

                                        if (finishedCondition) {
                                            clearTimeout(trackTimeout);
                                            _base.scrollStop();
                                            trackTimeout = undefined;
                                            scrollActionFinsished(true);
                                        }
                                        else {
                                            trackTimeout = setTimeout(scrollAction, timeoutDelay);

                                            scrollObj[xy] = (decreaseScroll ? '-=' : '+=') + scrollDistance;
                                            _base.scroll(scrollObj, extendDeep(animationObj, {
                                                duration: scrollDuration
                                            }));
                                        }
                                        isFirstIteration = false;
                                    }
                                }
                            };
                            if (ctrlKey)
                                increaseTrackScrollAmount();

                            mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                            mouseDownOffset = COMPATIBILITY.page(event)[xy];

                            _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                            addClass(_bodyElement, _classNameDragging);
                            addClass(scrollbarVars._track, strActive);
                            addClass(scrollbarVars._scrollbar, strActive);

                            setupResponsiveEventListener(_documentElement,
                                [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                                [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]);

                            scrollAction();
                            COMPATIBILITY.prvD(event);
                            COMPATIBILITY.stpP(event);
                        }
                    }
                    function onTrackMouseTouchEnter(event) {
                        //make sure both scrollbars will stay visible if one scrollbar is hovered if autoHide is "scroll" or "move".
                        _scrollbarsHandleHovered = true;
                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                            refreshScrollbarsAutoHide(true);
                    }
                    function onTrackMouseTouchLeave(event) {
                        _scrollbarsHandleHovered = false;
                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                            refreshScrollbarsAutoHide(false);
                    }
                    function onScrollbarMouseTouchDown(event) {
                        COMPATIBILITY.stpP(event);
                    }

                    addDestroyEventListener(scrollbarVars._handle,
                        _strMouseTouchDownEvent,
                        onHandleMouseTouchDown);
                    addDestroyEventListener(scrollbarVars._track,
                        [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave],
                        [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]);
                    addDestroyEventListener(scrollbarVars._scrollbar,
                        _strMouseTouchDownEvent,
                        onScrollbarMouseTouchDown);

                    if (_supportTransition) {
                        addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function (event) {
                            if (event.target !== scrollbarVars._scrollbar[0])
                                return;
                            refreshScrollbarHandleLength(isHorizontal);
                            refreshScrollbarHandleOffset(isHorizontal);
                        });
                    }
                }

                /**
                 * Shows or hides the given scrollbar and applied a class name which indicates if the scrollbar is scrollable or not.
                 * @param isHorizontal True if the horizontal scrollbar is the target, false if the vertical scrollbar is the target.
                 * @param shallBeVisible True if the scrollbar shall be shown, false if hidden.
                 * @param canScroll True if the scrollbar is scrollable, false otherwise.
                 */
                function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {
                    var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;
                    var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;

                    addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);
                    addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);
                }

                /**
                 * Autoshows / autohides both scrollbars with.
                 * @param shallBeVisible True if the scrollbars shall be autoshown (only the case if they are hidden by a autohide), false if the shall be auto hidden.
                 * @param delayfree True if the scrollbars shall be hidden without a delay, false or undefined otherwise.
                 */
                function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {
                    clearTimeout(_scrollbarsAutoHideTimeoutId);
                    if (shallBeVisible) {
                        //if(_hasOverflowCache.x && _hideOverflowCache.xs)
                        removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                        //if(_hasOverflowCache.y && _hideOverflowCache.ys)
                        removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                    }
                    else {
                        var anyActive;
                        var strActive = 'active';
                        var hide = function () {
                            if (!_scrollbarsHandleHovered && !_destroyed) {
                                anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);
                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                    addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                    addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                            }
                        };
                        if (_scrollbarsAutoHideDelay > 0 && delayfree !== true)
                            _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);
                        else
                            hide();
                    }
                }

                /**
                 * Refreshes the handle length of the given scrollbar.
                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
                 */
                function refreshScrollbarHandleLength(isHorizontal) {
                    var handleCSS = {};
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var digit = 1000000;
                    //get and apply intended handle length
                    var handleRatio = MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]);
                    handleCSS[scrollbarVars._width_height] = (MATH.floor(handleRatio * 100 * digit) / digit) + '%'; //the last * digit / digit is for flooring to the 4th digit

                    if (!nativeOverlayScrollbarsAreActive())
                        scrollbarVars._handle.css(handleCSS);

                    //measure the handle length to respect min & max length
                    scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]['offset' + scrollbarVars._Width_Height];
                    scrollbarVarsInfo._handleLengthRatio = handleRatio;
                }

                /**
                 * Refreshes the handle offset of the given scrollbar.
                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
                 * @param scrollOrTransition The scroll position of the given scrollbar axis to which the handle shall be moved or a boolean which indicates whether a transition shall be applied. If undefined or boolean if the current scroll-offset is taken. (if isHorizontal ? scrollLeft : scrollTop)
                 */
                function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {
                    var transition = type(scrollOrTransition) == TYPES.b;
                    var transitionDuration = 250;
                    var isRTLisHorizontal = _isRTL && isHorizontal;
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var strTranslateBrace = 'translate(';
                    var strTransform = VENDORS._cssProperty('transform');
                    var strTransition = VENDORS._cssProperty('transition');
                    var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();
                    var currentScroll = scrollOrTransition === undefined || transition ? nativeScroll : scrollOrTransition;

                    //measure the handle length to respect min & max length
                    var handleLength = scrollbarVarsInfo._handleLength;
                    var trackLength = scrollbarVars._track[0]['offset' + scrollbarVars._Width_Height];
                    var handleTrackDiff = trackLength - handleLength;
                    var handleCSS = {};
                    var transformOffset;
                    var translateValue;

                    //DONT use the variable '_contentScrollSizeCache[scrollbarVars._w_h]' instead of '_viewportElement[0]['scroll' + scrollbarVars._Width_Height]'
                    // because its a bit behind during the small delay when content size updates
                    //(delay = mutationObserverContentLag, if its 0 then this var could be used)
                    var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative['client' + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1); //* -1 if rtl scroll max is negative
                    var getScrollRatio = function (base) {
                        return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));
                    };
                    var getHandleOffset = function (scrollRatio) {
                        var offset = handleTrackDiff * scrollRatio;
                        offset = isNaN(offset) ? 0 : offset;
                        offset = (isRTLisHorizontal && !_rtlScrollBehavior.i) ? (trackLength - handleLength - offset) : offset;
                        offset = MATH.max(0, offset);
                        return offset;
                    };
                    var scrollRatio = getScrollRatio(nativeScroll);
                    var unsnappedScrollRatio = getScrollRatio(currentScroll);
                    var handleOffset = getHandleOffset(unsnappedScrollRatio);
                    var snappedHandleOffset = getHandleOffset(scrollRatio);

                    scrollbarVarsInfo._maxScroll = maxScroll;
                    scrollbarVarsInfo._currentScroll = nativeScroll;
                    scrollbarVarsInfo._currentScrollRatio = scrollRatio;

                    if (_supportTransform) {
                        transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset; //in px
                        //transformOffset = (transformOffset / trackLength * 100) * (trackLength / handleLength); //in %
                        translateValue = isHorizontal ? strTranslateBrace + transformOffset + 'px, 0)' : strTranslateBrace + '0, ' + transformOffset + 'px)';

                        handleCSS[strTransform] = translateValue;

                        //apply or clear up transition
                        if (_supportTransition)
                            handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ', ' + (strTransform + _strSpace + transitionDuration + 'ms') : _strEmpty;
                    }
                    else
                        handleCSS[scrollbarVars._left_top] = handleOffset;


                    //only apply css if offset has changed and overflow exists.
                    if (!nativeOverlayScrollbarsAreActive()) {
                        scrollbarVars._handle.css(handleCSS);

                        //clear up transition
                        if (_supportTransform && _supportTransition && transition) {
                            scrollbarVars._handle.one(_strTransitionEndEvent, function () {
                                if (!_destroyed)
                                    scrollbarVars._handle.css(strTransition, _strEmpty);
                            });
                        }
                    }

                    scrollbarVarsInfo._handleOffset = handleOffset;
                    scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;
                    scrollbarVarsInfo._trackLength = trackLength;
                }

                /**
                 * Refreshes the interactivity of the given scrollbar element.
                 * @param isTrack True if the track element is the target, false if the handle element is the target.
                 * @param value True for interactivity false for no interactivity.
                 */
                function refreshScrollbarsInteractive(isTrack, value) {
                    var action = value ? 'removeClass' : 'addClass';
                    var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;
                    var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;
                    var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;

                    element1[action](className);
                    element2[action](className);
                }

                /**
                 * Returns a object which is used for fast access for specific variables.
                 * @param isHorizontal True if the horizontal scrollbar vars shall be accessed, false if the vertical scrollbar vars shall be accessed.
                 * @returns {{wh: string, WH: string, lt: string, _wh: string, _lt: string, t: *, h: *, c: {}, s: *}}
                 */
                function getScrollbarVars(isHorizontal) {
                    return {
                        _width_height: isHorizontal ? _strWidth : _strHeight,
                        _Width_Height: isHorizontal ? 'Width' : 'Height',
                        _left_top: isHorizontal ? _strLeft : _strTop,
                        _Left_Top: isHorizontal ? 'Left' : 'Top',
                        _x_y: isHorizontal ? _strX : _strY,
                        _X_Y: isHorizontal ? 'X' : 'Y',
                        _w_h: isHorizontal ? 'w' : 'h',
                        _l_t: isHorizontal ? 'l' : 't',
                        _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,
                        _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,
                        _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,
                        _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo
                    };
                }


                //==== Scrollbar Corner ====//

                /**
                 * Builds or destroys the scrollbar corner DOM element.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupScrollbarCornerDOM(destroy) {
                    _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);

                    if (!destroy) {
                        if (!_domExists) {
                            _hostElement.append(_scrollbarCornerElement);
                        }
                    }
                    else {
                        if (_domExists && _initialized) {
                            removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                        }
                        else {
                            remove(_scrollbarCornerElement);
                        }
                    }
                }

                /**
                 * Initializes all scrollbar corner interactivity events.
                 */
                function setupScrollbarCornerEvents() {
                    var insideIFrame = _windowElementNative.top !== _windowElementNative;
                    var mouseDownPosition = {};
                    var mouseDownSize = {};
                    var mouseDownInvertedScale = {};
                    var reconnectMutationObserver;

                    function documentDragMove(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var pageOffset = getCoordinates(event);
                            var hostElementCSS = {};
                            if (_resizeHorizontal || _resizeBoth)
                                hostElementCSS[_strWidth] = (mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x);
                            if (_resizeVertical || _resizeBoth)
                                hostElementCSS[_strHeight] = (mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y);
                            _hostElement.css(hostElementCSS);
                            COMPATIBILITY.stpP(event);
                        }
                        else {
                            documentMouseTouchUp(event);
                        }
                    }
                    function documentMouseTouchUp(event) {
                        var eventIsTrusted = event !== undefined;

                        setupResponsiveEventListener(_documentElement,
                            [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                            [documentOnSelectStart, documentDragMove, documentMouseTouchUp],
                            true);

                        removeClass(_bodyElement, _classNameDragging);
                        if (_scrollbarCornerElement.releaseCapture)
                            _scrollbarCornerElement.releaseCapture();

                        if (eventIsTrusted) {
                            if (reconnectMutationObserver)
                                connectMutationObservers();
                            _base.update(_strAuto);
                        }
                        reconnectMutationObserver = false;
                    }
                    function onMouseTouchDownContinue(event) {
                        var originalEvent = event.originalEvent || event;
                        var isTouchEvent = originalEvent.touches !== undefined;
                        return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                    }
                    function getCoordinates(event) {
                        return _msieVersion && insideIFrame ? { x: event.screenX, y: event.screenY } : COMPATIBILITY.page(event);
                    }

                    addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function (event) {
                        if (onMouseTouchDownContinue(event) && !_resizeNone) {
                            if (_mutationObserversConnected) {
                                reconnectMutationObserver = true;
                                disconnectMutationObservers();
                            }

                            mouseDownPosition = getCoordinates(event);

                            mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);
                            mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);
                            mouseDownInvertedScale = getHostElementInvertedScale();

                            setupResponsiveEventListener(_documentElement,
                                [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                                [documentOnSelectStart, documentDragMove, documentMouseTouchUp]);

                            addClass(_bodyElement, _classNameDragging);
                            if (_scrollbarCornerElement.setCapture)
                                _scrollbarCornerElement.setCapture();

                            COMPATIBILITY.prvD(event);
                            COMPATIBILITY.stpP(event);
                        }
                    });
                }


                //==== Utils ====//

                /**
                 * Calls the callback with the given name. The Context of this callback is always _base (this).
                 * @param name The name of the target which shall be called.
                 * @param args The args with which the callback shall be called.
                 * @param dependent Boolean which decides whether the callback shall be fired, undefined is like a "true" value.
                 */
                function dispatchCallback(name, args, dependent) {
                    if (dependent === false)
                        return;
                    if (_initialized) {
                        var callback = _currentPreparedOptions.callbacks[name];
                        var extensionOnName = name;
                        var ext;

                        if (extensionOnName.substr(0, 2) === 'on')
                            extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);

                        if (type(callback) == TYPES.f)
                            callback.call(_base, args);

                        each(_extensions, function () {
                            ext = this;
                            if (type(ext.on) == TYPES.f)
                                ext.on(extensionOnName, args);
                        });
                    }
                    else if (!_destroyed)
                        _callbacksInitQeueue.push({ n: name, a: args });
                }

                /**
                 * Sets the "top, right, bottom, left" properties, with a given prefix, of the given css object.
                 * @param targetCSSObject The css object to which the values shall be applied.
                 * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
                 * @param values A array of values which shall be applied to the "top, right, bottom, left" -properties. The array order is [top, right, bottom, left].
                 * If this argument is undefined the value '' (empty string) will be applied to all properties.
                 */
                function setTopRightBottomLeft(targetCSSObject, prefix, values) {
                    prefix = prefix || _strEmpty;
                    values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];

                    targetCSSObject[prefix + _strTop] = values[0];
                    targetCSSObject[prefix + _strRight] = values[1];
                    targetCSSObject[prefix + _strBottom] = values[2];
                    targetCSSObject[prefix + _strLeft] = values[3];
                }

                /**
                 * Gets the "top, right, bottom, left" CSS properties of the CSS property with the given prefix from the host element.
                 * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
                 * @param suffix The suffix of the "top, right, bottom, left" css properties. (example: 'border-' is a valid prefix with '-width' is a valid suffix)
                 * @param zeroX True if the x axis shall be 0.
                 * @param zeroY True if the y axis shall be 0.
                 * @returns {{}} The object which contains the numbers of the read CSS properties.
                 */
                function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {
                    suffix = suffix || _strEmpty;
                    prefix = prefix || _strEmpty;
                    return {
                        t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),
                        r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),
                        b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),
                        l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))
                    };
                }

                /**
                 * Returns the computed CSS transition string from the given element.
                 * @param element The element from which the transition string shall be returned.
                 * @returns {string} The CSS transition string from the given element.
                 */
                function getCSSTransitionString(element) {
                    var transitionStr = VENDORS._cssProperty('transition');
                    var assembledValue = element.css(transitionStr);
                    if (assembledValue)
                        return assembledValue;
                    var regExpString = '\\s*(' + '([^,(]+(\\(.+?\\))?)+' + ')[\\s,]*';
                    var regExpMain = new RegExp(regExpString);
                    var regExpValidate = new RegExp('^(' + regExpString + ')+$');
                    var properties = 'property duration timing-function delay'.split(' ');
                    var result = [];
                    var strResult;
                    var valueArray;
                    var i = 0;
                    var j;
                    var splitCssStyleByComma = function (str) {
                        strResult = [];
                        if (!str.match(regExpValidate))
                            return str;
                        while (str.match(regExpMain)) {
                            strResult.push(RegExp.$1);
                            str = str.replace(regExpMain, _strEmpty);
                        }

                        return strResult;
                    };
                    for (; i < properties[LEXICON.l]; i++) {
                        valueArray = splitCssStyleByComma(element.css(transitionStr + '-' + properties[i]));
                        for (j = 0; j < valueArray[LEXICON.l]; j++)
                            result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];
                    }
                    return result.join(', ');
                }

                /**
                 * Generates a Regular Expression which matches with a string which starts with 'os-host'.
                 * @param {boolean} withCurrClassNameOption The Regular Expression also matches if the string is the current ClassName option (multiple values splitted by space possible).
                 * @param {boolean} withOldClassNameOption The Regular Expression also matches if the string is the old ClassName option (multiple values splitted by space possible).
                 */
                function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {
                    var i;
                    var split;
                    var appendix;
                    var appendClasses = function (classes, condition) {
                        appendix = '';
                        if (condition && typeof classes == TYPES.s) {
                            split = classes.split(_strSpace);
                            for (i = 0; i < split[LEXICON.l]; i++)
                                appendix += '|' + split[i] + '$';
                            // split[i].replace(/[.*+?^${}()|[\]\\]/g, '\\$&') for escaping regex characters
                        }
                        return appendix;
                    };

                    return new RegExp(
                        '(^' + _classNameHostElement + '([-_].+|)$)' +
                        appendClasses(_classNameCache, withCurrClassNameOption) +
                        appendClasses(_oldClassName, withOldClassNameOption), 'g');
                }

                /**
                 * Calculates the host-elements inverted scale. (invertedScale = 1 / scale)
                 * @returns {{x: number, y: number}} The scale of the host-element.
                 */
                function getHostElementInvertedScale() {
                    var rect = _paddingElementNative[LEXICON.bCR]();
                    return {
                        x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,
                        y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1
                    };
                }

                /**
                 * Checks whether the given object is a HTMLElement.
                 * @param o The object which shall be checked.
                 * @returns {boolean} True the given object is a HTMLElement, false otherwise.
                 */
                function isHTMLElement(o) {
                    var strOwnerDocument = 'ownerDocument';
                    var strHTMLElement = 'HTMLElement';
                    var wnd = o && o[strOwnerDocument] ? (o[strOwnerDocument].parentWindow || window) : window;
                    return (
                        typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : //DOM2
                            o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s
                    );
                }

                /**
                 * Compares 2 arrays and returns the differences between them as a array.
                 * @param a1 The first array which shall be compared.
                 * @param a2 The second array which shall be compared.
                 * @returns {Array} The differences between the two arrays.
                 */
                function getArrayDifferences(a1, a2) {
                    var a = [];
                    var diff = [];
                    var i;
                    var k;
                    for (i = 0; i < a1.length; i++)
                        a[a1[i]] = true;
                    for (i = 0; i < a2.length; i++) {
                        if (a[a2[i]])
                            delete a[a2[i]];
                        else
                            a[a2[i]] = true;
                    }
                    for (k in a)
                        diff.push(k);
                    return diff;
                }

                /**
                 * Returns Zero or the number to which the value can be parsed.
                 * @param value The value which shall be parsed.
                 * @param toFloat Indicates whether the number shall be parsed to a float.
                 */
                function parseToZeroOrNumber(value, toFloat) {
                    var num = toFloat ? parseFloat(value) : parseInt(value, 10);
                    return isNaN(num) ? 0 : num;
                }

                /**
                 * Gets several information of the textarea and returns them as a object or undefined if the browser doesn't support it.
                 * @returns {{cursorRow: Number, cursorCol, rows: Number, cols: number, wRow: number, pos: number, max : number}} or undefined if not supported.
                 */
                function getTextareaInfo() {
                    //read needed values
                    var textareaCursorPosition = _targetElementNative.selectionStart;
                    if (textareaCursorPosition === undefined)
                        return;

                    var textareaValue = _targetElement.val();
                    var textareaLength = textareaValue[LEXICON.l];
                    var textareaRowSplit = textareaValue.split('\n');
                    var textareaLastRow = textareaRowSplit[LEXICON.l];
                    var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split('\n');
                    var widestRow = 0;
                    var textareaLastCol = 0;
                    var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];
                    var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];
                    var rowCols;
                    var i;

                    //get widest Row and the last column of the textarea
                    for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {
                        rowCols = textareaRowSplit[i][LEXICON.l];
                        if (rowCols > textareaLastCol) {
                            widestRow = i + 1;
                            textareaLastCol = rowCols;
                        }
                    }

                    return {
                        _cursorRow: cursorRow, //cursorRow
                        _cursorColumn: cursorCol, //cursorCol
                        _rows: textareaLastRow, //rows
                        _columns: textareaLastCol, //cols
                        _widestRow: widestRow, //wRow
                        _cursorPosition: textareaCursorPosition, //pos
                        _cursorMax: textareaLength //max
                    };
                }

                /**
                 * Determines whether native overlay scrollbars are active.
                 * @returns {boolean} True if native overlay scrollbars are active, false otherwise.
                 */
                function nativeOverlayScrollbarsAreActive() {
                    return (_ignoreOverlayScrollbarHidingCache && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y));
                }

                /**
                 * Gets the element which is used to measure the content size.
                 * @returns {*} TextareaCover if target element is textarea else the ContentElement.
                 */
                function getContentMeasureElement() {
                    return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;
                }

                /**
                 * Generates a string which represents a HTML div with the given classes or attributes.
                 * @param classesOrAttrs The class of the div as string or a object which represents the attributes of the div. (The class attribute can also be written as "className".)
                 * @param content The content of the div as string.
                 * @returns {string} The concated string which represents a HTML div and its content.
                 */
                function generateDiv(classesOrAttrs, content) {
                    return '<div ' + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ?
                        'class="' + classesOrAttrs + '"' :
                        (function () {
                            var key;
                            var attrs = _strEmpty;
                            if (FRAMEWORK.isPlainObject(classesOrAttrs)) {
                                for (key in classesOrAttrs)
                                    attrs += (key === 'c' ? 'class' : key) + '="' + classesOrAttrs[key] + '" ';
                            }
                            return attrs;
                        })() :
                        _strEmpty) +
                        '>' +
                        (content || _strEmpty) +
                        '</div>';
                }

                /**
                 * Selects or generates a div with the given class attribute.
                 * @param className The class names (divided by spaces) of the div which shall be selected or generated.
                 * @param selectParentOrOnlyChildren The parent element from which of the element shall be selected. (if undefined or boolean its hostElement)
                 * If its a boolean it decides whether only the children of the host element shall be selected.
                 * @returns {*} The generated or selected element.
                 */
                function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {
                    var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;
                    var selectParent = onlyChildren ? _hostElement : (selectParentOrOnlyChildren || _hostElement);

                    return (_domExists && !selectParent[LEXICON.l])
                        ? null
                        : _domExists
                            ? selectParent[onlyChildren ? 'children' : 'find'](_strDot + className.replace(/\s/g, _strDot)).eq(0)
                            : FRAMEWORK(generateDiv(className))
                }

                /**
                 * Gets the value of the given property from the given object.
                 * @param obj The object from which the property value shall be got.
                 * @param path The property of which the value shall be got.
                 * @returns {*} Returns the value of the searched property or undefined of the property wasn't found.
                 */
                function getObjectPropVal(obj, path) {
                    var splits = path.split(_strDot);
                    var i = 0;
                    var val;
                    for (; i < splits.length; i++) {
                        if (!obj[LEXICON.hOP](splits[i]))
                            return;
                        val = obj[splits[i]];
                        if (i < splits.length && type(val) == TYPES.o)
                            obj = val;
                    }
                    return val;
                }

                /**
                 * Sets the value of the given property from the given object.
                 * @param obj The object from which the property value shall be set.
                 * @param path The property of which the value shall be set.
                 * @param val The value of the property which shall be set.
                 */
                function setObjectPropVal(obj, path, val) {
                    var splits = path.split(_strDot);
                    var splitsLength = splits.length;
                    var i = 0;
                    var extendObj = {};
                    var extendObjRoot = extendObj;
                    for (; i < splitsLength; i++)
                        extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;
                    FRAMEWORK.extend(obj, extendObjRoot, true);
                }

                /**
                 * Runs a action for each selector inside the updateOnLoad option.
                 * @param {Function} action The action for each updateOnLoad selector, the arguments the function takes is the index and the value (the selector).
                 */
                function eachUpdateOnLoad(action) {
                    var updateOnLoad = _currentPreparedOptions.updateOnLoad;
                    updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;

                    if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {
                        each(updateOnLoad, action);
                    }
                }


                //==== Utils Cache ====//

                /**
                 * Compares two values or objects and returns true if they aren't equal.
                 * @param current The first value or object which shall be compared.
                 * @param cache The second value or object which shall be compared.
                 * @param force If true the returned value is always true.
                 * @returns {boolean} True if both values or objects aren't equal or force is true, false otherwise.
                 */
                function checkCache(current, cache, force) {
                    if (force)
                        return force;
                    if (type(current) == TYPES.o && type(cache) == TYPES.o) {
                        for (var prop in current) {
                            if (prop !== 'c') {
                                if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {
                                    if (checkCache(current[prop], cache[prop]))
                                        return true;
                                }
                                else {
                                    return true;
                                }
                            }
                        }
                    }
                    else {
                        return current !== cache;
                    }
                    return false;
                }


                //==== Shortcuts ====//

                /**
                 * jQuery extend method shortcut with a appended "true" as first argument.
                 */
                function extendDeep() {
                    return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));
                }

                /**
                 * jQuery addClass method shortcut.
                 */
                function addClass(el, classes) {
                    return _frameworkProto.addClass.call(el, classes);
                }

                /**
                 * jQuery removeClass method shortcut.
                 */
                function removeClass(el, classes) {
                    return _frameworkProto.removeClass.call(el, classes);
                }

                /**
                 * Adds or removes the given classes dependent on the boolean value. True for add, false for remove.
                 */
                function addRemoveClass(el, classes, doAdd) {
                    return doAdd ? addClass(el, classes) : removeClass(el, classes);
                }

                /**
                 * jQuery remove method shortcut.
                 */
                function remove(el) {
                    return _frameworkProto.remove.call(el);
                }

                /**
                 * Finds the first child element with the given selector of the given element.
                 * @param el The root element from which the selector shall be valid.
                 * @param selector The selector of the searched element.
                 * @returns {*} The first element which is a child of the given element and matches the givens selector.
                 */
                function findFirst(el, selector) {
                    return _frameworkProto.find.call(el, selector).eq(0);
                }


                //==== API ====//

                /**
                 * Puts the instance to sleep. It wont respond to any changes in the DOM and won't update. Scrollbar Interactivity is also disabled as well as the resize handle.
                 * This behavior can be reset by calling the update method.
                 */
                _base.sleep = function () {
                    _sleeping = true;
                };

                /**
                 * Updates the plugin and DOM to the current options.
                 * This method should only be called if a update is 100% required.
                 * @param force True if every property shall be updated and the cache shall be ignored.
                 * !INTERNAL USAGE! : force can be a string "auto", "sync" or "zoom" too
                 * if "auto" then before a real update the content size and host element attributes gets checked, and if they changed only then the update method will be called.
                 * if "sync" then the async update process (MutationObserver or UpdateLoop) gets synchronized and a corresponding update takes place if one was needed due to pending changes.
                 * if "zoom" then a update takes place where it's assumed that content and host size changed
                 * @returns {boolean|undefined}
                 * If force is "sync" then a boolean is returned which indicates whether a update was needed due to pending changes.
                 * If force is "auto" then a boolean is returned whether a update was needed due to attribute or size changes.
                 * undefined otherwise.
                 */
                _base.update = function (force) {
                    if (_destroyed)
                        return;

                    var attrsChanged;
                    var contentSizeC;
                    var isString = type(force) == TYPES.s;
                    var doUpdateAuto;
                    var mutHost;
                    var mutContent;

                    if (isString) {
                        if (force === _strAuto) {
                            attrsChanged = meaningfulAttrsChanged();
                            contentSizeC = updateAutoContentSizeChanged();
                            doUpdateAuto = attrsChanged || contentSizeC;
                            if (doUpdateAuto) {
                                update({
                                    _contentSizeChanged: contentSizeC,
                                    _changedOptions: _initialized ? undefined : _currentPreparedOptions
                                });
                            }
                        }
                        else if (force === _strSync) {
                            if (_mutationObserversConnected) {
                                mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());
                                mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());
                            }
                            else {
                                mutHost = _base.update(_strAuto);
                            }
                        }
                        else if (force === 'zoom') {
                            update({
                                _hostSizeChanged: true,
                                _contentSizeChanged: true
                            });
                        }
                    }
                    else {
                        force = _sleeping || force;
                        _sleeping = false;
                        if (!_base.update(_strSync) || force)
                            update({ _force: force });
                    }

                    updateElementsOnLoad();

                    return doUpdateAuto || mutHost || mutContent;
                };

                /**
                 Gets or sets the current options. The update method will be called automatically if new options were set.
                 * @param newOptions If new options are given, then the new options will be set, if new options aren't given (undefined or a not a plain object) then the current options will be returned.
                 * @param value If new options is a property path string, then this value will be used to set the option to which the property path string leads.
                 * @returns {*}
                 */
                _base.options = function (newOptions, value) {
                    var option = {};
                    var changedOps;

                    //return current options if newOptions are undefined or empty
                    if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {
                        if (type(newOptions) == TYPES.s) {
                            if (arguments.length > 1) {
                                setObjectPropVal(option, newOptions, value);
                                changedOps = setOptions(option);
                            }
                            else
                                return getObjectPropVal(_currentOptions, newOptions);
                        }
                        else
                            return _currentOptions;
                    }
                    else {
                        changedOps = setOptions(newOptions);
                    }

                    if (!FRAMEWORK.isEmptyObject(changedOps)) {
                        update({ _changedOptions: changedOps });
                    }
                };

                /**
                 * Restore the DOM, disconnects all observers, remove all resize observers and put the instance to sleep.
                 */
                _base.destroy = function () {
                    if (_destroyed)
                        return;

                    //remove this instance from auto update loop
                    autoUpdateLoop.remove(_base);

                    //disconnect all mutation observers
                    disconnectMutationObservers();

                    //remove all resize observers
                    setupResizeObserver(_sizeObserverElement);
                    setupResizeObserver(_sizeAutoObserverElement);

                    //remove all extensions
                    for (var extName in _extensions)
                        _base.removeExt(extName);

                    //remove all 'destroy' events
                    while (_destroyEvents[LEXICON.l] > 0)
                        _destroyEvents.pop()();

                    //remove all events from host element
                    setupHostMouseTouchEvents(true);

                    //remove all helper / detection elements
                    if (_contentGlueElement)
                        remove(_contentGlueElement);
                    if (_contentArrangeElement)
                        remove(_contentArrangeElement);
                    if (_sizeAutoObserverAdded)
                        remove(_sizeAutoObserverElement);

                    //remove all generated DOM
                    setupScrollbarsDOM(true);
                    setupScrollbarCornerDOM(true);
                    setupStructureDOM(true);

                    //remove all generated image load events
                    for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++)
                        FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);
                    _updateOnLoadElms = undefined;

                    _destroyed = true;
                    _sleeping = true;

                    //remove this instance from the instances list
                    INSTANCES(pluginTargetElement, 0);
                    dispatchCallback('onDestroyed');

                    //remove all properties and methods
                    //for (var property in _base)
                    //    delete _base[property];
                    //_base = undefined;
                };

                /**
                 * Scrolls to a given position or element.
                 * @param coordinates
                 * 1. Can be "coordinates" which looks like:
                 *    { x : ?, y : ? } OR          Object with x and y properties
                 *    { left : ?, top : ? } OR     Object with left and top properties
                 *    { l : ?, t : ? } OR          Object with l and t properties
                 *    [ ?, ? ] OR                  Array where the first two element are the coordinates (first is x, second is y)
                 *    ?                            A single value which stays for both axis
                 *    A value can be a number, a string or a calculation.
                 *
                 *    Operators:
                 *    [NONE]  The current scroll will be overwritten by the value.
                 *    '+='    The value will be added to the current scroll offset
                 *    '-='    The value will be subtracted from the current scroll offset
                 *    '*='    The current scroll wil be multiplicated by the value.
                 *    '/='    The current scroll wil be divided by the value.
                 *
                 *    Units:
                 *    [NONE]  The value is the final scroll amount.                   final = (value * 1)
                 *    'px'    Same as none
                 *    '%'     The value is dependent on the current scroll value.     final = ((currentScrollValue / 100) * value)
                 *    'vw'    The value is multiplicated by the viewport width.       final = (value * viewportWidth)
                 *    'vh'    The value is multiplicated by the viewport height.      final = (value * viewportHeight)
                 *
                 *    example final values:
                 *    200, '200px', '50%', '1vw', '1vh', '+=200', '/=1vw', '*=2px', '-=5vh', '+=33%', '+= 50% - 2px', '-= 1vw - 50%'
                 *
                 * 2. Can be a HTML or jQuery element:
                 *    The final scroll offset is the offset (without margin) of the given HTML / jQuery element.
                 *
                 * 3. Can be a object with a HTML or jQuery element with additional settings:
                 *    {
                 *      el : [HTMLElement, jQuery element],             MUST be specified, else this object isn't valid.
                 *      scroll : [string, array, object],               Default value is 'always'.
                 *      block : [string, array, object],                Default value is 'begin'.
                 *      margin : [number, boolean, array, object]       Default value is false.
                 *    }
                 *
                 *    Possible scroll settings are:
                 *    'always'      Scrolls always.
                 *    'ifneeded'    Scrolls only if the element isnt fully in view.
                 *    'never'       Scrolls never.
                 *
                 *    Possible block settings are:
                 *    'begin'   Both axis shall be docked to the "begin" edge. - The element will be docked to the top and left edge of the viewport.
                 *    'end'     Both axis shall be docked to the "end" edge. - The element will be docked to the bottom and right edge of the viewport. (If direction is RTL to the bottom and left edge.)
                 *    'center'  Both axis shall be docked to "center". - The element will be centered in the viewport.
                 *    'nearest' The element will be docked to the nearest edge(s).
                 *
                 *    Possible margin settings are: -- The actual margin of the element wont be affect, this option affects only the final scroll offset.
                 *    [BOOLEAN]                                         If true the css margin of the element will be used, if false no margin will be used.
                 *    [NUMBER]                                          The margin will be used for all edges.
                 *
                 * @param duration The duration of the scroll animation, OR a jQuery animation configuration object.
                 * @param easing The animation easing.
                 * @param complete The animation complete callback.
                 * @returns {{
                 *   position: {x: number, y: number},
                 *   ratio: {x: number, y: number},
                 *   max: {x: number, y: number},
                 *   handleOffset: {x: number, y: number},
                 *   handleLength: {x: number, y: number},
                 *   handleLengthRatio: {x: number, y: number}, t
                 *   rackLength: {x: number, y: number},
                 *   isRTL: boolean,
                 *   isRTLNormalized: boolean
                 *  }}
                 */
                _base.scroll = function (coordinates, duration, easing, complete) {
                    if (arguments.length === 0 || coordinates === undefined) {
                        var infoX = _scrollHorizontalInfo;
                        var infoY = _scrollVerticalInfo;
                        var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;
                        var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;
                        var scrollX = infoX._currentScroll;
                        var scrollXRatio = infoX._currentScrollRatio;
                        var maxScrollX = infoX._maxScroll;
                        scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;
                        scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;
                        scrollX *= normalizeNegate ? -1 : 1;
                        maxScrollX *= normalizeNegate ? -1 : 1;

                        return {
                            position: {
                                x: scrollX,
                                y: infoY._currentScroll
                            },
                            ratio: {
                                x: scrollXRatio,
                                y: infoY._currentScrollRatio
                            },
                            max: {
                                x: maxScrollX,
                                y: infoY._maxScroll
                            },
                            handleOffset: {
                                x: infoX._handleOffset,
                                y: infoY._handleOffset
                            },
                            handleLength: {
                                x: infoX._handleLength,
                                y: infoY._handleLength
                            },
                            handleLengthRatio: {
                                x: infoX._handleLengthRatio,
                                y: infoY._handleLengthRatio
                            },
                            trackLength: {
                                x: infoX._trackLength,
                                y: infoY._trackLength
                            },
                            snappedHandleOffset: {
                                x: infoX._snappedHandleOffset,
                                y: infoY._snappedHandleOffset
                            },
                            isRTL: _isRTL,
                            isRTLNormalized: _normalizeRTLCache
                        };
                    }

                    _base.update(_strSync);

                    var normalizeRTL = _normalizeRTLCache;
                    var coordinatesXAxisProps = [_strX, _strLeft, 'l'];
                    var coordinatesYAxisProps = [_strY, _strTop, 't'];
                    var coordinatesOperators = ['+=', '-=', '*=', '/='];
                    var durationIsObject = type(duration) == TYPES.o;
                    var completeCallback = durationIsObject ? duration.complete : complete;
                    var i;
                    var finalScroll = {};
                    var specialEasing = {};
                    var doScrollLeft;
                    var doScrollTop;
                    var animationOptions;
                    var strEnd = 'end';
                    var strBegin = 'begin';
                    var strCenter = 'center';
                    var strNearest = 'nearest';
                    var strAlways = 'always';
                    var strNever = 'never';
                    var strIfNeeded = 'ifneeded';
                    var strLength = LEXICON.l;
                    var settingsAxis;
                    var settingsScroll;
                    var settingsBlock;
                    var settingsMargin;
                    var finalElement;
                    var elementObjSettingsAxisValues = [_strX, _strY, 'xy', 'yx'];
                    var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];
                    var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];
                    var coordinatesIsElementObj = coordinates[LEXICON.hOP]('el');
                    var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;
                    var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;
                    var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);
                    var updateScrollbarInfos = function () {
                        if (doScrollLeft)
                            refreshScrollbarHandleOffset(true);
                        if (doScrollTop)
                            refreshScrollbarHandleOffset(false);
                    };
                    var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined : function () {
                        updateScrollbarInfos();
                        completeCallback();
                    };
                    function checkSettingsStringValue(currValue, allowedValues) {
                        for (i = 0; i < allowedValues[strLength]; i++) {
                            if (currValue === allowedValues[i])
                                return true;
                        }
                        return false;
                    }
                    function getRawScroll(isX, coordinates) {
                        var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;
                        coordinates = type(coordinates) == TYPES.s || type(coordinates) == TYPES.n ? [coordinates, coordinates] : coordinates;

                        if (COMPATIBILITY.isA(coordinates))
                            return isX ? coordinates[0] : coordinates[1];
                        else if (type(coordinates) == TYPES.o) {
                            //decides RTL normalization "hack" with .n
                            //normalizeRTL = type(coordinates.n) == TYPES.b ? coordinates.n : normalizeRTL;
                            for (i = 0; i < coordinateProps[strLength]; i++)
                                if (coordinateProps[i] in coordinates)
                                    return coordinates[coordinateProps[i]];
                        }
                    }
                    function getFinalScroll(isX, rawScroll) {
                        var isString = type(rawScroll) == TYPES.s;
                        var operator;
                        var amount;
                        var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;
                        var currScroll = scrollInfo._currentScroll;
                        var maxScroll = scrollInfo._maxScroll;
                        var mult = ' * ';
                        var finalValue;
                        var isRTLisX = _isRTL && isX;
                        var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;
                        var strReplace = 'replace';
                        var evalFunc = eval;
                        var possibleOperator;
                        if (isString) {
                            //check operator
                            if (rawScroll[strLength] > 2) {
                                possibleOperator = rawScroll.substr(0, 2);
                                if (inArray(possibleOperator, coordinatesOperators) > -1)
                                    operator = possibleOperator;
                            }

                            //calculate units and shortcuts
                            rawScroll = operator ? rawScroll.substr(2) : rawScroll;
                            rawScroll = rawScroll
                            [strReplace](/min/g, 0) //'min' = 0%
                            [strReplace](/</g, 0)   //'<'   = 0%
                            [strReplace](/max/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)    //'max' = 100%
                            [strReplace](/>/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)      //'>'   = 100%
                            [strReplace](/px/g, _strEmpty)
                            [strReplace](/%/g, mult + (maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100.0))
                            [strReplace](/vw/g, mult + _viewportSize.w)
                            [strReplace](/vh/g, mult + _viewportSize.h);
                            amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);
                        }
                        else {
                            amount = rawScroll;
                        }

                        if (amount !== undefined && !isNaN(amount) && type(amount) == TYPES.n) {
                            var normalizeIsRTLisX = normalizeRTL && isRTLisX;
                            var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);
                            var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;
                            var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;
                            operatorCurrScroll = invert ? (maxScroll - operatorCurrScroll) : operatorCurrScroll;
                            switch (operator) {
                                case '+=':
                                    finalValue = operatorCurrScroll + amount;
                                    break;
                                case '-=':
                                    finalValue = operatorCurrScroll - amount;
                                    break;
                                case '*=':
                                    finalValue = operatorCurrScroll * amount;
                                    break;
                                case '/=':
                                    finalValue = operatorCurrScroll / amount;
                                    break;
                                default:
                                    finalValue = amount;
                                    break;
                            }
                            finalValue = invert ? maxScroll - finalValue : finalValue;
                            finalValue *= negate ? -1 : 1;
                            finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));
                        }
                        return finalValue === currScroll ? undefined : finalValue;
                    }
                    function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {
                        var resultDefault = [defaultValue, defaultValue];
                        var valueType = type(value);
                        var valueArrLength;
                        var valueArrItem;

                        //value can be [ string, or array of two strings ]
                        if (valueType == valueInternalType) {
                            value = [value, value];
                        }
                        else if (valueType == TYPES.a) {
                            valueArrLength = value[strLength];
                            if (valueArrLength > 2 || valueArrLength < 1)
                                value = resultDefault;
                            else {
                                if (valueArrLength === 1)
                                    value[1] = defaultValue;
                                for (i = 0; i < valueArrLength; i++) {
                                    valueArrItem = value[i];
                                    if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {
                                        value = resultDefault;
                                        break;
                                    }
                                }
                            }
                        }
                        else if (valueType == TYPES.o)
                            value = [value[_strX] || defaultValue, value[_strY] || defaultValue];
                        else
                            value = resultDefault;
                        return { x: value[0], y: value[1] };
                    }
                    function generateMargin(marginTopRightBottomLeftArray) {
                        var result = [];
                        var currValue;
                        var currValueType;
                        var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];
                        for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {
                            if (i === valueDirections[strLength])
                                break;
                            currValue = marginTopRightBottomLeftArray[i];
                            currValueType = type(currValue);
                            if (currValueType == TYPES.b)
                                result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);
                            else
                                result.push(currValueType == TYPES.n ? currValue : 0);
                        }
                        return result;
                    }

                    if (possibleElementIsJQuery || possibleElementIsHTMLElement) {
                        //get settings
                        var margin = coordinatesIsElementObj ? coordinates.margin : 0;
                        var axis = coordinatesIsElementObj ? coordinates.axis : 0;
                        var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;
                        var block = coordinatesIsElementObj ? coordinates.block : 0;
                        var marginDefault = [0, 0, 0, 0];
                        var marginType = type(margin);
                        var marginLength;
                        finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);

                        if (finalElement[strLength] > 0) {
                            //margin can be [ boolean, number, array of 2, array of 4, object ]
                            if (marginType == TYPES.n || marginType == TYPES.b)
                                margin = generateMargin([margin, margin, margin, margin]);
                            else if (marginType == TYPES.a) {
                                marginLength = margin[strLength];
                                if (marginLength === 2)
                                    margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);
                                else if (marginLength >= 4)
                                    margin = generateMargin(margin);
                                else
                                    margin = marginDefault;
                            }
                            else if (marginType == TYPES.o)
                                margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);
                            else
                                margin = marginDefault;

                            //block = type(block) === TYPES.b ? block ? [ strNearest, strBegin ] : [ strNearest, strEnd ] : block;
                            settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : 'xy';
                            settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);
                            settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);
                            settingsMargin = margin;

                            var viewportScroll = {
                                l: _scrollHorizontalInfo._currentScroll,
                                t: _scrollVerticalInfo._currentScroll
                            };
                            // use padding element instead of viewport element because padding element has never padding, margin or position applied.
                            var viewportOffset = _paddingElement.offset();

                            //get coordinates
                            var elementOffset = finalElement.offset();
                            var doNotScroll = {
                                x: settingsScroll.x == strNever || settingsAxis == _strY,
                                y: settingsScroll.y == strNever || settingsAxis == _strX
                            };
                            elementOffset[_strTop] -= settingsMargin[0];
                            elementOffset[_strLeft] -= settingsMargin[3];
                            var elementScrollCoordinates = {
                                x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),
                                y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)
                            };
                            if (_isRTL) {
                                if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i)
                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);
                                if (_rtlScrollBehavior.n && normalizeRTL)
                                    elementScrollCoordinates.x *= -1;
                                if (_rtlScrollBehavior.i && normalizeRTL)
                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));
                            }

                            //measuring is required
                            if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {
                                var measuringElm = finalElement[0];
                                var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {
                                    width: measuringElm[LEXICON.oW],
                                    height: measuringElm[LEXICON.oH]
                                };
                                var elementSize = {
                                    w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],
                                    h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]
                                };
                                var finalizeBlock = function (isX) {
                                    var vars = getScrollbarVars(isX);
                                    var wh = vars._w_h;
                                    var lt = vars._left_top;
                                    var xy = vars._x_y;
                                    var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);
                                    var blockIsCenter = settingsBlock[xy] == strCenter;
                                    var blockIsNearest = settingsBlock[xy] == strNearest;
                                    var scrollNever = settingsScroll[xy] == strNever;
                                    var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;
                                    var vpSize = _viewportSize[wh];
                                    var vpOffset = viewportOffset[lt];
                                    var elSize = elementSize[wh];
                                    var elOffset = elementOffset[lt];
                                    var divide = blockIsCenter ? 2 : 1;
                                    var elementCenterOffset = elOffset + (elSize / 2);
                                    var viewportCenterOffset = vpOffset + (vpSize / 2);
                                    var isInView =
                                        elSize <= vpSize
                                        && elOffset >= vpOffset
                                        && elOffset + elSize <= vpOffset + vpSize;

                                    if (scrollNever)
                                        doNotScroll[xy] = true;
                                    else if (!doNotScroll[xy]) {
                                        if (blockIsNearest || scrollIfNeeded) {
                                            doNotScroll[xy] = scrollIfNeeded ? isInView : false;
                                            blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;
                                        }
                                        elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? ((vpSize / divide) - (elSize / divide)) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;
                                    }
                                };
                                finalizeBlock(true);
                                finalizeBlock(false);
                            }

                            if (doNotScroll.y)
                                delete elementScrollCoordinates.y;
                            if (doNotScroll.x)
                                delete elementScrollCoordinates.x;

                            coordinates = elementScrollCoordinates;
                        }
                    }

                    finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));
                    finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));
                    doScrollLeft = finalScroll[_strScrollLeft] !== undefined;
                    doScrollTop = finalScroll[_strScrollTop] !== undefined;

                    if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {
                        if (durationIsObject) {
                            duration.complete = proxyCompleteCallback;
                            _viewportElement.animate(finalScroll, duration);
                        }
                        else {
                            animationOptions = {
                                duration: duration,
                                complete: proxyCompleteCallback
                            };
                            if (COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing)) {
                                specialEasing[_strScrollLeft] = easing[0] || easing.x;
                                specialEasing[_strScrollTop] = easing[1] || easing.y;
                                animationOptions.specialEasing = specialEasing;
                            }
                            else {
                                animationOptions.easing = easing;
                            }
                            _viewportElement.animate(finalScroll, animationOptions);
                        }
                    }
                    else {
                        if (doScrollLeft)
                            _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);
                        if (doScrollTop)
                            _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);
                        updateScrollbarInfos();
                    }
                };

                /**
                 * Stops all scroll animations.
                 * @returns {*} The current OverlayScrollbars instance (for chaining).
                 */
                _base.scrollStop = function (param1, param2, param3) {
                    _viewportElement.stop(param1, param2, param3);
                    return _base;
                };

                /**
                 * Returns all relevant elements.
                 * @param elementName The name of the element which shall be returned.
                 * @returns {{target: *, host: *, padding: *, viewport: *, content: *, scrollbarHorizontal: {scrollbar: *, track: *, handle: *}, scrollbarVertical: {scrollbar: *, track: *, handle: *}, scrollbarCorner: *} | *}
                 */
                _base.getElements = function (elementName) {
                    var obj = {
                        target: _targetElementNative,
                        host: _hostElementNative,
                        padding: _paddingElementNative,
                        viewport: _viewportElementNative,
                        content: _contentElementNative,
                        scrollbarHorizontal: {
                            scrollbar: _scrollbarHorizontalElement[0],
                            track: _scrollbarHorizontalTrackElement[0],
                            handle: _scrollbarHorizontalHandleElement[0]
                        },
                        scrollbarVertical: {
                            scrollbar: _scrollbarVerticalElement[0],
                            track: _scrollbarVerticalTrackElement[0],
                            handle: _scrollbarVerticalHandleElement[0]
                        },
                        scrollbarCorner: _scrollbarCornerElement[0]
                    };
                    return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;
                };

                /**
                 * Returns a object which describes the current state of this instance.
                 * @param stateProperty A specific property from the state object which shall be returned.
                 * @returns {{widthAuto, heightAuto, overflowAmount, hideOverflow, hasOverflow, contentScrollSize, viewportSize, hostSize, autoUpdate} | *}
                 */
                _base.getState = function (stateProperty) {
                    function prepare(obj) {
                        if (!FRAMEWORK.isPlainObject(obj))
                            return obj;
                        var extended = extendDeep({}, obj);
                        var changePropertyName = function (from, to) {
                            if (extended[LEXICON.hOP](from)) {
                                extended[to] = extended[from];
                                delete extended[from];
                            }
                        };
                        changePropertyName('w', _strWidth); //change w to width
                        changePropertyName('h', _strHeight); //change h to height
                        delete extended.c; //delete c (the 'changed' prop)
                        return extended;
                    };
                    var obj = {
                        destroyed: !!prepare(_destroyed),
                        sleeping: !!prepare(_sleeping),
                        autoUpdate: prepare(!_mutationObserversConnected),
                        widthAuto: prepare(_widthAutoCache),
                        heightAuto: prepare(_heightAutoCache),
                        padding: prepare(_cssPaddingCache),
                        overflowAmount: prepare(_overflowAmountCache),
                        hideOverflow: prepare(_hideOverflowCache),
                        hasOverflow: prepare(_hasOverflowCache),
                        contentScrollSize: prepare(_contentScrollSizeCache),
                        viewportSize: prepare(_viewportSize),
                        hostSize: prepare(_hostSizeCache),
                        documentMixed: prepare(_documentMixed)
                    };
                    return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;
                };

                /**
                 * Gets all or specific extension instance.
                 * @param extName The name of the extension from which the instance shall be got.
                 * @returns {{}} The instance of the extension with the given name or undefined if the instance couldn't be found.
                 */
                _base.ext = function (extName) {
                    var result;
                    var privateMethods = _extensionsPrivateMethods.split(' ');
                    var i = 0;
                    if (type(extName) == TYPES.s) {
                        if (_extensions[LEXICON.hOP](extName)) {
                            result = extendDeep({}, _extensions[extName]);
                            for (; i < privateMethods.length; i++)
                                delete result[privateMethods[i]];
                        }
                    }
                    else {
                        result = {};
                        for (i in _extensions)
                            result[i] = extendDeep({}, _base.ext(i));
                    }
                    return result;
                };

                /**
                 * Adds a extension to this instance.
                 * @param extName The name of the extension which shall be added.
                 * @param extensionOptions The extension options which shall be used.
                 * @returns {{}} The instance of the added extension or undefined if the extension couldn't be added properly.
                 */
                _base.addExt = function (extName, extensionOptions) {
                    var registeredExtensionObj = _plugin.extension(extName);
                    var instance;
                    var instanceAdded;
                    var instanceContract;
                    var contractResult;
                    var contractFulfilled = true;
                    if (registeredExtensionObj) {
                        if (!_extensions[LEXICON.hOP](extName)) {
                            instance = registeredExtensionObj.extensionFactory.call(_base,
                                extendDeep({}, registeredExtensionObj.defaultOptions),
                                FRAMEWORK,
                                COMPATIBILITY);

                            if (instance) {
                                instanceContract = instance.contract;
                                if (type(instanceContract) == TYPES.f) {
                                    contractResult = instanceContract(window);
                                    contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;
                                }
                                if (contractFulfilled) {
                                    _extensions[extName] = instance;
                                    instanceAdded = instance.added;
                                    if (type(instanceAdded) == TYPES.f)
                                        instanceAdded(extensionOptions);

                                    return _base.ext(extName);
                                }
                            }
                        }
                        else
                            return _base.ext(extName);
                    }
                    else
                        console.warn("A extension with the name \"" + extName + "\" isn't registered.");
                };

                /**
                 * Removes a extension from this instance.
                 * @param extName The name of the extension which shall be removed.
                 * @returns {boolean} True if the extension was removed, false otherwise e.g. if the extension wasn't added before.
                 */
                _base.removeExt = function (extName) {
                    var instance = _extensions[extName];
                    var instanceRemoved;
                    if (instance) {
                        delete _extensions[extName];

                        instanceRemoved = instance.removed;
                        if (type(instanceRemoved) == TYPES.f)
                            instanceRemoved();

                        return true;
                    }
                    return false;
                };

                /**
                 * Constructs the plugin.
                 * @param targetElement The element to which the plugin shall be applied.
                 * @param options The initial options of the plugin.
                 * @param extensions The extension(s) which shall be added right after the initialization.
                 * @returns {boolean} True if the plugin was successfully initialized, false otherwise.
                 */
                function construct(targetElement, options, extensions) {
                    _defaultOptions = globals.defaultOptions;
                    _nativeScrollbarStyling = globals.nativeScrollbarStyling;
                    _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                    _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);
                    _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);
                    _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior);

                    //parse & set options but don't update
                    setOptions(extendDeep({}, _defaultOptions, options));

                    _cssCalc = globals.cssCalc;
                    _msieVersion = globals.msie;
                    _autoUpdateRecommended = globals.autoUpdateRecommended;
                    _supportTransition = globals.supportTransition;
                    _supportTransform = globals.supportTransform;
                    _supportPassiveEvents = globals.supportPassiveEvents;
                    _supportResizeObserver = globals.supportResizeObserver;
                    _supportMutationObserver = globals.supportMutationObserver;
                    _restrictedMeasuring = globals.restrictedMeasuring;
                    _documentElement = FRAMEWORK(targetElement.ownerDocument);
                    _documentElementNative = _documentElement[0];
                    _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);
                    _windowElementNative = _windowElement[0];
                    _htmlElement = findFirst(_documentElement, 'html');
                    _bodyElement = findFirst(_htmlElement, 'body');
                    _targetElement = FRAMEWORK(targetElement);
                    _targetElementNative = _targetElement[0];
                    _isTextarea = _targetElement.is('textarea');
                    _isBody = _targetElement.is('body');
                    _documentMixed = _documentElementNative !== document;

                    /* On a div Element The if checks only whether:
                     * - the targetElement has the class "os-host"
                     * - the targetElement has a a child with the class "os-padding"
                     *
                     * If that's the case, its assumed the DOM has already the following structure:
                     * (The ".os-host" element is the targetElement)
                     *
                     *  <div class="os-host">
                     *      <div class="os-resize-observer-host"></div>
                     *      <div class="os-padding">
                     *          <div class="os-viewport">
                     *              <div class="os-content"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-horizontal ">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-vertical">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar-corner"></div>
                     *  </div>
                     *
                     * =====================================================================================
                     *
                     * On a Textarea Element The if checks only whether:
                     * - the targetElement has the class "os-textarea"
                     * - the targetElement is inside a element with the class "os-content"
                     *
                     * If that's the case, its assumed the DOM has already the following structure:
                     * (The ".os-textarea" (textarea) element is the targetElement)
                     *
                     *  <div class="os-host-textarea">
                     *      <div class="os-resize-observer-host"></div>
                     *      <div class="os-padding os-text-inherit">
                     *          <div class="os-viewport os-text-inherit">
                     *              <div class="os-content os-text-inherit">
                     *                  <div class="os-textarea-cover"></div>
                     *                  <textarea class="os-textarea os-text-inherit"></textarea>
                     *              </div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-horizontal ">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-vertical">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar-corner"></div>
                     *  </div>
                     */
                    _domExists = _isTextarea
                        ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement)
                        : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];

                    var initBodyScroll;
                    var bodyMouseTouchDownListener;

                    //check if the plugin hasn't to be initialized
                    if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {
                        _initialized = true; // workaround so the onInitializationWithdrawn callback below is fired
                        dispatchCallback('onInitializationWithdrawn');
                        if (_domExists) {
                            setupStructureDOM(true);
                            setupScrollbarsDOM(true);
                            setupScrollbarCornerDOM(true);
                        }

                        _initialized = false;
                        _destroyed = true;
                        _sleeping = true;

                        return _base;
                    }

                    if (_isBody) {
                        initBodyScroll = {};
                        initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());
                        initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());

                        bodyMouseTouchDownListener = function () {
                            _viewportElement.removeAttr(LEXICON.ti);
                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);
                        }
                    }

                    //build OverlayScrollbars DOM
                    setupStructureDOM();
                    setupScrollbarsDOM();
                    setupScrollbarCornerDOM();

                    //create OverlayScrollbars events
                    setupStructureEvents();
                    setupScrollbarEvents(true);
                    setupScrollbarEvents(false);
                    setupScrollbarCornerEvents();

                    //create mutation observers
                    createMutationObservers();

                    //build resize observer for the host element
                    setupResizeObserver(_sizeObserverElement, hostOnResized);

                    if (_isBody) {
                        //apply the body scroll to handle it right in the update method
                        _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t);

                        //set the focus on the viewport element so you dont have to click on the page to use keyboard keys (up / down / space) for scrolling
                        if (document.activeElement == targetElement && _viewportElementNative.focus) {
                            //set a tabindex to make the viewportElement focusable
                            _viewportElement.attr(LEXICON.ti, '-1');
                            _viewportElementNative.focus();

                            /* the tabindex has to be removed due to;
                             * If you set the tabindex attribute on an <div>, then its child content cannot be scrolled with the arrow keys unless you set tabindex on the content, too
                             * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
                             */
                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);
                        }
                    }

                    //update for the first time & initialize cache
                    _base.update(_strAuto);

                    //the plugin is initialized now!
                    _initialized = true;
                    dispatchCallback('onInitialized');

                    //call all callbacks which would fire before the initialized was complete
                    each(_callbacksInitQeueue, function (index, value) { dispatchCallback(value.n, value.a); });
                    _callbacksInitQeueue = [];

                    //add extensions
                    if (type(extensions) == TYPES.s)
                        extensions = [extensions];
                    if (COMPATIBILITY.isA(extensions))
                        each(extensions, function (index, value) { _base.addExt(value); });
                    else if (FRAMEWORK.isPlainObject(extensions))
                        each(extensions, function (key, value) { _base.addExt(key, value); });

                    //add the transition class for transitions AFTER the first update & AFTER the applied extensions (for preventing unwanted transitions)
                    setTimeout(function () {
                        if (_supportTransition && !_destroyed)
                            addClass(_hostElement, _classNameHostTransition);
                    }, 333);

                    return _base;
                }

                if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {
                    INSTANCES(pluginTargetElement, _base);
                }

                return _base;
            }

            /**
             * Initializes a new OverlayScrollbarsInstance object or changes options if already initialized or returns the current instance.
             * @param pluginTargetElements The elements to which the Plugin shall be initialized.
             * @param options The custom options with which the plugin shall be initialized.
             * @param extensions The extension(s) which shall be added right after initialization.
             * @returns {*}
             */
            _plugin = window[PLUGINNAME] = function (pluginTargetElements, options, extensions) {
                if (arguments[LEXICON.l] === 0)
                    return this;

                var arr = [];
                var optsIsPlainObj = FRAMEWORK.isPlainObject(options);
                var inst;
                var result;

                //pluginTargetElements is null or undefined
                if (!pluginTargetElements)
                    return optsIsPlainObj || !options ? result : arr;

                /*
                   pluginTargetElements will be converted to:
                   1. A jQueryElement Array
                   2. A HTMLElement Array
                   3. A Array with a single HTML Element
                   so pluginTargetElements is always a array.
                */
                pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];
                initOverlayScrollbarsStatics();

                if (pluginTargetElements[LEXICON.l] > 0) {
                    if (optsIsPlainObj) {
                        FRAMEWORK.each(pluginTargetElements, function (i, v) {
                            inst = v;
                            if (inst !== undefined)
                                arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));
                        });
                    }
                    else {
                        FRAMEWORK.each(pluginTargetElements, function (i, v) {
                            inst = INSTANCES(v);
                            if ((options === '!' && _plugin.valid(inst)) || (COMPATIBILITY.type(options) == TYPES.f && options(v, inst)))
                                arr.push(inst);
                            else if (options === undefined)
                                arr.push(inst);
                        });
                    }
                    result = arr[LEXICON.l] === 1 ? arr[0] : arr;
                }
                return result;
            };

            /**
             * Returns a object which contains global information about the plugin and each instance of it.
             * The returned object is just a copy, that means that changes to the returned object won't have any effect to the original object.
             */
            _plugin.globals = function () {
                initOverlayScrollbarsStatics();
                var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);
                delete globals['msie'];
                return globals;
            };

            /**
             * Gets or Sets the default options for each new plugin initialization.
             * @param newDefaultOptions The object with which the default options shall be extended.
             */
            _plugin.defaultOptions = function (newDefaultOptions) {
                initOverlayScrollbarsStatics();
                var currDefaultOptions = _pluginsGlobals.defaultOptions;
                if (newDefaultOptions === undefined)
                    return FRAMEWORK.extend(true, {}, currDefaultOptions);

                //set the new default options
                _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);
            };

            /**
             * Checks whether the passed instance is a non-destroyed OverlayScrollbars instance.
             * @param osInstance The potential OverlayScrollbars instance which shall be checked.
             * @returns {boolean} True if the passed value is a non-destroyed OverlayScrollbars instance, false otherwise.
             */
            _plugin.valid = function (osInstance) {
                return osInstance instanceof _plugin && !osInstance.getState().destroyed;
            };

            /**
             * Registers, Unregisters or returns a extension.
             * Register: Pass the name and the extension. (defaultOptions is optional)
             * Unregister: Pass the name and anything except a function as extension parameter.
             * Get extension: Pass the name of the extension which shall be got.
             * Get all extensions: Pass no arguments.
             * @param extensionName The name of the extension which shall be registered, unregistered or returned.
             * @param extension A function which generates the instance of the extension or anything other to remove a already registered extension.
             * @param defaultOptions The default options which shall be used for the registered extension.
             */
            _plugin.extension = function (extensionName, extension, defaultOptions) {
                var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;
                var argLen = arguments[LEXICON.l];
                var i = 0;
                if (argLen < 1 || !extNameTypeString) {
                    //return a copy of all extension objects
                    return FRAMEWORK.extend(true, { length: _pluginsExtensions[LEXICON.l] }, _pluginsExtensions);
                }
                else if (extNameTypeString) {
                    if (COMPATIBILITY.type(extension) == TYPES.f) {
                        //register extension
                        _pluginsExtensions.push({
                            name: extensionName,
                            extensionFactory: extension,
                            defaultOptions: defaultOptions
                        });
                    }
                    else {
                        for (; i < _pluginsExtensions[LEXICON.l]; i++) {
                            if (_pluginsExtensions[i].name === extensionName) {
                                if (argLen > 1)
                                    _pluginsExtensions.splice(i, 1); //remove extension
                                else
                                    return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]); //return extension with the given name
                            }
                        }
                    }
                }
            };

            return _plugin;
        })();

        if (JQUERY && JQUERY.fn) {
            /**
             * The jQuery initialization interface.
             * @param options The initial options for the construction of the plugin. To initialize the plugin, this option has to be a object! If it isn't a object, the instance(s) are returned and the plugin wont be initialized.
             * @param extensions The extension(s) which shall be added right after initialization.
             * @returns {*} After initialization it returns the jQuery element array, else it returns the instance(s) of the elements which are selected.
             */
            JQUERY.fn.overlayScrollbars = function (options, extensions) {
                var _elements = this;
                if (JQUERY.isPlainObject(options)) {
                    JQUERY.each(_elements, function () { PLUGIN(this, options, extensions); });
                    return _elements;
                }
                else
                    return PLUGIN(_elements, options);
            };
        }
        return PLUGIN;
    }
));
